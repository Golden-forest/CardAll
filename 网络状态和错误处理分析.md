# CardEverything ç½‘ç»œçŠ¶æ€ç®¡ç†å’Œé”™è¯¯å¤„ç†æœºåˆ¶åˆ†æ

## ğŸ“‹ åˆ†ææ¦‚è¿°

åŸºäºå¯¹ç°æœ‰cloud-sync.tsä»£ç çš„æ·±å…¥åˆ†æï¼Œæœ¬æŠ¥å‘Šè¯¦ç»†è¯„ä¼°äº†CardEverythingé¡¹ç›®çš„ç½‘ç»œçŠ¶æ€ç®¡ç†å’Œé”™è¯¯å¤„ç†æœºåˆ¶ï¼Œè¯†åˆ«äº†å…³é”®é—®é¢˜å¹¶æä¾›äº†æ”¹è¿›å»ºè®®ã€‚

### æ ¸å¿ƒå‘ç°
- **ç½‘ç»œæ£€æµ‹è¿‡äºç®€å•**ï¼šä»…æ£€æµ‹åœ¨çº¿/ç¦»çº¿ï¼Œä¸è€ƒè™‘ç½‘ç»œè´¨é‡
- **é”™è¯¯å¤„ç†æœºåˆ¶ç®€é™‹**ï¼šç¼ºä¹ç»†ç²’åº¦é”™è¯¯åˆ†ç±»å’Œæ¢å¤ç­–ç•¥
- **é‡è¯•é€»è¾‘ä¸æ™ºèƒ½**ï¼šå›ºå®šé‡è¯•æ¬¡æ•°ï¼Œæ— æŒ‡æ•°é€€é¿
- **ç”¨æˆ·ä½“éªŒä¸è¶³**ï¼šé”™è¯¯åé¦ˆä¸å‹å¥½ï¼Œæ¢å¤æœºåˆ¶ä¸å®Œå–„

---

## ğŸ” å½“å‰ç½‘ç»œçŠ¶æ€ç®¡ç†åˆ†æ

### 1. ç°æœ‰ç½‘ç»œæ£€æµ‹æœºåˆ¶

#### 1.1 å½“å‰å®ç°ä»£ç åˆ†æ
```typescript
// å½“å‰ç½‘ç»œæ£€æµ‹ä»£ç  (cloud-sync.ts lines 38-57)
constructor() {
  // ç›‘å¬ç½‘ç»œçŠ¶æ€
  window.addEventListener('online', () => {
    this.isOnline = true
    this.notifyStatusChange()
    this.processSyncQueue() // ç«‹å³å¤„ç†æ‰€æœ‰é˜Ÿåˆ—
  })

  window.addEventListener('offline', () => {
    this.isOnline = false
    this.notifyStatusChange()
  })

  // å®šæœŸåŒæ­¥ï¼ˆæ¯5åˆ†é’Ÿï¼‰
  setInterval(() => {
    if (this.isOnline && this.authService?.isAuthenticated()) {
      this.processSyncQueue()
    }
  }, 5 * 60 * 1000)
}
```

#### 1.2 ç½‘ç»œæ£€æµ‹é—®é¢˜åˆ†æ

**é—®é¢˜1ï¼šäºŒå…ƒç½‘ç»œçŠ¶æ€æ£€æµ‹**
```typescript
// å½“å‰é—®é¢˜ï¼šä»…æ£€æµ‹online/offline
interface CurrentNetworkState {
  isOnline: boolean; // true/falseè¿‡äºç®€å•
}

// æ”¹è¿›æ–¹æ¡ˆï¼šå¤šç»´åº¦ç½‘ç»œè´¨é‡è¯„ä¼°
interface EnhancedNetworkState {
  status: 'online' | 'offline' | 'unstable' | 'slow';
  latency: number; // å»¶è¿Ÿæ—¶é—´
  bandwidth: number; // å¸¦å®½
  packetLoss: number; // ä¸¢åŒ…ç‡
  effectiveType: '4g' | '3g' | '2g' | 'slow-2g' | 'wifi';
  lastUpdated: Date;
}
```

**é—®é¢˜2ï¼šç½‘ç»œæ¢å¤æ—¶çš„æ‰¹é‡åŒæ­¥é£é™©**
```typescript
// å½“å‰é—®é¢˜ï¼šç½‘ç»œæ¢å¤æ—¶ç«‹å³åŒæ­¥æ‰€æœ‰é˜Ÿåˆ—
window.addEventListener('online', () => {
  this.processSyncQueue() // å¯èƒ½é€ æˆç½‘ç»œæ‹¥å¡
});

// æ”¹è¿›æ–¹æ¡ˆï¼šæ™ºèƒ½è°ƒåº¦
window.addEventListener('online', () => {
  this.schedulePrioritySync(); // ä¼˜å…ˆåŒæ­¥é‡è¦æ•°æ®
  this.gradualSyncRestoration(); // é€æ­¥æ¢å¤åŒæ­¥
});
```

### 2. ç½‘ç»œè´¨é‡è¯„ä¼°æ–¹æ¡ˆ

#### 2.1 ç»¼åˆç½‘ç»œè´¨é‡æ£€æµ‹
```typescript
class NetworkQualityMonitor {
  private networkState: EnhancedNetworkState;
  private qualityHistory: NetworkQualitySnapshot[] = [];
  
  constructor() {
    this.initializeNetworkMonitoring();
  }
  
  private initializeNetworkMonitoring(): void {
    // åŸºç¡€åœ¨çº¿çŠ¶æ€ç›‘å¬
    window.addEventListener('online', () => this.handleOnline());
    window.addEventListener('offline', () => this.handleOffline());
    
    // è¿æ¥è´¨é‡å˜åŒ–ç›‘å¬
    if ('connection' in navigator) {
      const connection = (navigator as any).connection;
      connection.addEventListener('change', () => this.handleConnectionChange(connection));
    }
    
    // å®šæœŸè´¨é‡æ£€æµ‹
    setInterval(() => this.measureNetworkQuality(), 30000);
    
    // é¡µé¢å¯è§æ€§å˜åŒ–æ£€æµ‹
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible') {
        this.measureNetworkQuality(); // é¡µé¢å¯è§æ—¶é‡æ–°æ£€æµ‹
      }
    });
  }
  
  private async measureNetworkQuality(): Promise<void> {
    try {
      const [latency, bandwidth, packetLoss] = await Promise.all([
        this.measureLatency(),
        this.measureBandwidth(),
        this.measurePacketLoss()
      ]);
      
      const effectiveType = this.getEffectiveType();
      
      this.networkState = {
        status: this.determineNetworkStatus(latency, bandwidth, packetLoss),
        latency,
        bandwidth,
        packetLoss,
        effectiveType,
        lastUpdated: new Date()
      };
      
      this.qualityHistory.push({
        ...this.networkState,
        timestamp: new Date()
      });
      
      // ä¿æŒå†å²è®°å½•
      if (this.qualityHistory.length > 100) {
        this.qualityHistory.shift();
      }
      
      // é€šçŸ¥çŠ¶æ€å˜åŒ–
      this.notifyNetworkQualityChange();
      
    } catch (error) {
      console.error('Network quality measurement failed:', error);
      this.networkState.status = 'unstable';
    }
  }
  
  private async measureLatency(): Promise<number> {
    const measurements = [];
    const testUrl = `${import.meta.env.VITE_SUPABASE_URL}/rest/v1/`;
    
    for (let i = 0; i < 3; i++) {
      const start = performance.now();
      try {
        const response = await fetch(testUrl, {
          method: 'HEAD',
          cache: 'no-cache'
        });
        const end = performance.now();
        measurements.push(end - start);
      } catch (error) {
        measurements.push(Infinity);
      }
    }
    
    // å»é™¤æœ€å¤§å€¼å’Œæœ€å°å€¼åå–å¹³å‡
    measurements.sort((a, b) => a - b);
    const validMeasurements = measurements.slice(1, -1);
    
    return validMeasurements.length > 0 
      ? validMeasurements.reduce((a, b) => a + b) / validMeasurements.length
      : Infinity;
  }
  
  private async measureBandwidth(): Promise<number> {
    try {
      // ä½¿ç”¨ Connection API å¦‚æœå¯ç”¨
      const connection = (navigator as any).connection;
      if (connection?.downlink) {
        return connection.downlink; // Mbps
      }
      
      // é™çº§åˆ°åŸºäºæ–‡ä»¶ä¸‹è½½çš„å¸¦å®½æµ‹è¯•
      return await this.performBandwidthTest();
    } catch (error) {
      return 0; // æ— æ³•æµ‹é‡å¸¦å®½
    }
  }
  
  private async performBandwidthTest(): Promise<number> {
    const testFileSize = 100 * 1024; // 100KB
    const testUrl = `${import.meta.env.VITE_SUPABASE_URL}/bandwidth-test`;
    
    try {
      const start = performance.now();
      const response = await fetch(testUrl);
      const blob = await response.blob();
      const end = performance.now();
      
      const duration = (end - start) / 1000; // è½¬æ¢ä¸ºç§’
      const bits = blob.size * 8;
      
      return bits / duration / 1000000; // Mbps
    } catch (error) {
      return 0;
    }
  }
  
  private measurePacketLoss(): Promise<number> {
    // ç®€åŒ–çš„ä¸¢åŒ…æ£€æµ‹ - å®é™…å®ç°éœ€è¦æ›´å¤æ‚çš„é€»è¾‘
    return Promise.resolve(0);
  }
  
  private getEffectiveType(): EnhancedNetworkState['effectiveType'] {
    const connection = (navigator as any).connection;
    return connection?.effectiveType || 'wifi';
  }
  
  private determineNetworkStatus(
    latency: number, 
    bandwidth: number, 
    packetLoss: number
  ): EnhancedNetworkState['status'] {
    if (latency === Infinity) return 'offline';
    
    // åŸºäºå»¶è¿Ÿå’Œå¸¦å®½çš„ç»¼åˆåˆ¤æ–­
    if (latency > 2000 || bandwidth < 0.5 || packetLoss > 10) {
      return 'unstable';
    }
    
    if (latency > 500 || bandwidth < 2) {
      return 'slow';
    }
    
    return 'online';
  }
  
  private handleOnline(): void {
    // ç½‘ç»œæ¢å¤ï¼Œé‡æ–°æ£€æµ‹è´¨é‡
    setTimeout(() => this.measureNetworkQuality(), 1000);
  }
  
  private handleOffline(): void {
    this.networkState.status = 'offline';
    this.networkState.lastUpdated = new Date();
    this.notifyNetworkQualityChange();
  }
  
  private handleConnectionChange(connection: any): void {
    // è¿æ¥é…ç½®å˜åŒ–ï¼Œé‡æ–°è¯„ä¼°ç½‘ç»œè´¨é‡
    this.measureNetworkQuality();
  }
  
  private notifyNetworkQualityChange(): void {
    // å‘é€ç½‘ç»œè´¨é‡å˜åŒ–äº‹ä»¶
    window.dispatchEvent(new CustomEvent('networkQualityChange', {
      detail: this.networkState
    }));
  }
  
  public getCurrentNetworkState(): EnhancedNetworkState {
    return { ...this.networkState };
  }
  
  public getNetworkQualityHistory(): NetworkQualitySnapshot[] {
    return [...this.qualityHistory];
  }
  
  public isNetworkStable(): boolean {
    const recent = this.qualityHistory.slice(-5);
    if (recent.length < 3) return false;
    
    // æ£€æŸ¥æœ€è¿‘5æ¬¡æµ‹é‡çš„ç¨³å®šæ€§
    const latencies = recent.map(r => r.latency);
    const avgLatency = latencies.reduce((a, b) => a + b) / latencies.length;
    const variance = latencies.reduce((sum, lat) => sum + Math.pow(lat - avgLatency, 2), 0) / latencies.length;
    
    return variance < 10000; // æ–¹å·®å°äº10000msÂ²è®¤ä¸ºæ˜¯ç¨³å®šçš„
  }
}

interface NetworkQualitySnapshot extends EnhancedNetworkState {
  timestamp: Date;
}
```

---

## âš ï¸ é”™è¯¯å¤„ç†æœºåˆ¶åˆ†æ

### 1. å½“å‰é”™è¯¯å¤„ç†é—®é¢˜

#### 1.1 ç°æœ‰é”™è¯¯å¤„ç†ä»£ç åˆ†æ
```typescript
// å½“å‰é”™è¯¯å¤„ç†ä»£ç  (cloud-sync.ts lines 144-157)
} catch (error) {
  console.error('Sync operation failed:', error)
  
  // å¢åŠ é‡è¯•æ¬¡æ•°
  operation.retryCount++
  
  // å¦‚æœé‡è¯•æ¬¡æ•°è¿‡å¤šï¼Œç§»é™¤æ“ä½œ
  if (operation.retryCount > 3) {
    const index = this.syncQueue.findIndex(op => op.id === operation.id)
    if (index > -1) {
      this.syncQueue.splice(index, 1)
    }
  }
}
```

#### 1.2 é”™è¯¯å¤„ç†é—®é¢˜åˆ†æ

**é—®é¢˜1ï¼šé”™è¯¯åˆ†ç±»ä¸è¶³**
```typescript
// å½“å‰é—®é¢˜ï¼šæ‰€æœ‰é”™è¯¯ç»Ÿä¸€å¤„ç†
catch (error) {
  console.error('Sync operation failed:', error)
  // ç¼ºä¹é”™è¯¯ç±»å‹åˆ¤æ–­
}

// æ”¹è¿›æ–¹æ¡ˆï¼šç»†ç²’åº¦é”™è¯¯åˆ†ç±»
interface SyncError extends Error {
  type: 'network' | 'auth' | 'server' | 'validation' | 'conflict' | 'timeout';
  retryable: boolean;
  severity: 'low' | 'medium' | 'high' | 'critical';
  context?: {
    operation: string;
    entityId?: string;
    attempts: number;
    networkState?: EnhancedNetworkState;
  };
  recovery?: RecoveryStrategy;
}

interface RecoveryStrategy {
  action: 'retry' | 'skip' | 'manual' | 'fallback';
  delay?: number;
  maxAttempts?: number;
  fallbackOperation?: () => Promise<void>;
}
```

**é—®é¢˜2ï¼šé‡è¯•ç­–ç•¥è¿‡äºç®€å•**
```typescript
// å½“å‰é—®é¢˜ï¼šå›ºå®šé‡è¯•æ¬¡æ•°ï¼Œæ— æ™ºèƒ½ç­–ç•¥
if (operation.retryCount > 3) {
  // ç§»é™¤æ“ä½œï¼Œå¯èƒ½å¯¼è‡´æ•°æ®ä¸¢å¤±
}

// æ”¹è¿›æ–¹æ¡ˆï¼šè‡ªé€‚åº”é‡è¯•ç­–ç•¥
class AdaptiveRetryManager {
  private retryStrategies: Map<string, RetryStrategy> = new Map();
  
  constructor() {
    this.initializeRetryStrategies();
  }
  
  private initializeRetryStrategies(): void {
    // ç½‘ç»œé”™è¯¯é‡è¯•ç­–ç•¥
    this.retryStrategies.set('network', {
      maxAttempts: 5,
      initialDelay: 1000,
      maxDelay: 30000,
      backoffFactor: 2,
      jitter: true,
      condition: (error, context) => 
        context.networkState?.status !== 'offline'
    });
    
    // æœåŠ¡å™¨é”™è¯¯é‡è¯•ç­–ç•¥
    this.retryStrategies.set('server', {
      maxAttempts: 3,
      initialDelay: 2000,
      maxDelay: 10000,
      backoffFactor: 1.5,
      jitter: true
    });
    
    // è¶…æ—¶é”™è¯¯é‡è¯•ç­–ç•¥
    this.retryStrategies.set('timeout', {
      maxAttempts: 4,
      initialDelay: 500,
      maxDelay: 5000,
      backoffFactor: 1.2,
      jitter: false
    });
    
    // å†²çªé”™è¯¯ä¸é‡è¯•
    this.retryStrategies.set('conflict', {
      maxAttempts: 0,
      action: 'manual'
    });
    
    // è®¤è¯é”™è¯¯ä¸é‡è¯•
    this.retryStrategies.set('auth', {
      maxAttempts: 0,
      action: 'manual'
    });
  }
  
  async executeWithRetry<T>(
    operation: () => Promise<T>,
    context: RetryContext
  ): Promise<T> {
    const errorType = this.classifyError(context.lastError);
    const strategy = this.retryStrategies.get(errorType) || this.getDefaultStrategy();
    
    let attempt = 0;
    const maxAttempts = strategy.maxAttempts || 3;
    
    while (attempt < maxAttempts) {
      try {
        return await operation();
      } catch (error) {
        attempt++;
        
        // æ£€æŸ¥é‡è¯•æ¡ä»¶
        if (!this.shouldRetry(error, strategy, context)) {
          throw error;
        }
        
        // è®¡ç®—é‡è¯•å»¶è¿Ÿ
        const delay = this.calculateRetryDelay(strategy, attempt, context);
        
        // è®°å½•é‡è¯•æŒ‡æ ‡
        this.recordRetryAttempt(errorType, attempt, delay);
        
        // ç­‰å¾…é‡è¯•
        await this.sleep(delay);
      }
    }
    
    throw new MaxRetryError(`Operation failed after ${maxAttempts} attempts`);
  }
  
  private classifyError(error: any): string {
    if (error?.name === 'NetworkError' || error?.message?.includes('Network')) {
      return 'network';
    }
    
    if (error?.status === 401 || error?.message?.includes('Unauthorized')) {
      return 'auth';
    }
    
    if (error?.status >= 500 && error?.status < 600) {
      return 'server';
    }
    
    if (error?.name === 'TimeoutError' || error?.message?.includes('timeout')) {
      return 'timeout';
    }
    
    if (error?.message?.includes('conflict')) {
      return 'conflict';
    }
    
    return 'unknown';
  }
  
  private shouldRetry(error: any, strategy: RetryStrategy, context: RetryContext): boolean {
    // æ£€æŸ¥æ˜¯å¦è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°
    if (context.attempts >= (strategy.maxAttempts || 3)) {
      return false;
    }
    
    // æ£€æŸ¥é‡è¯•æ¡ä»¶
    if (strategy.condition && !strategy.condition(error, context)) {
      return false;
    }
    
    return true;
  }
  
  private calculateRetryDelay(strategy: RetryStrategy, attempt: number, context: RetryContext): number {
    let delay = strategy.initialDelay || 1000;
    
    // æŒ‡æ•°é€€é¿
    if (strategy.backoffFactor) {
      delay = delay * Math.pow(strategy.backoffFactor, attempt - 1);
    }
    
    // æœ€å¤§å»¶è¿Ÿé™åˆ¶
    if (strategy.maxDelay) {
      delay = Math.min(delay, strategy.maxDelay);
    }
    
    // ç½‘ç»œæ„ŸçŸ¥è°ƒæ•´
    if (context.networkState) {
      delay = this.adjustDelayForNetwork(delay, context.networkState);
    }
    
    // æ·»åŠ éšæœºæŠ–åŠ¨
    if (strategy.jitter) {
      delay = delay * (0.8 + Math.random() * 0.4); // Â±20%æŠ–åŠ¨
    }
    
    return delay;
  }
  
  private adjustDelayForNetwork(delay: number, networkState: EnhancedNetworkState): number {
    switch (networkState.status) {
      case 'slow':
        return delay * 2; // æ…¢é€Ÿç½‘ç»œæ—¶å»¶è¿ŸåŠ å€
      case 'unstable':
        return delay * 3; // ä¸ç¨³å®šç½‘ç»œæ—¶å»¶è¿Ÿå¢åŠ 
      case 'online':
        return delay * 0.8; // è‰¯å¥½ç½‘ç»œæ—¶å»¶è¿Ÿå‡å°‘
      default:
        return delay;
    }
  }
  
  private recordRetryAttempt(errorType: string, attempt: number, delay: number): void {
    // è®°å½•é‡è¯•æŒ‡æ ‡ç”¨äºåˆ†æå’Œç›‘æ§
    console.log(`Retry attempt ${attempt} for ${errorType}, delay: ${delay}ms`);
  }
  
  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
  
  private getDefaultStrategy(): RetryStrategy {
    return {
      maxAttempts: 3,
      initialDelay: 1000,
      backoffFactor: 2,
      jitter: true
    };
  }
}

interface RetryStrategy {
  maxAttempts?: number;
  initialDelay?: number;
  maxDelay?: number;
  backoffFactor?: number;
  jitter?: boolean;
  condition?: (error: any, context: RetryContext) => boolean;
  action?: 'retry' | 'skip' | 'manual' | 'fallback';
}

interface RetryContext {
  operation: string;
  attempts: number;
  lastError?: any;
  networkState?: EnhancedNetworkState;
  entityId?: string;
}
```

### 2. ç»¼åˆé”™è¯¯å¤„ç†ç³»ç»Ÿ

#### 2.1 é”™è¯¯å¤„ç†ç®¡é“
```typescript
class SyncErrorPipeline {
  private errorHandlers: Map<string, ErrorHandler[]> = new Map();
  private retryManager: AdaptiveRetryManager;
  private networkMonitor: NetworkQualityMonitor;
  
  constructor() {
    this.retryManager = new AdaptiveRetryManager();
    this.networkMonitor = new NetworkQualityMonitor();
    this.initializeErrorHandlers();
  }
  
  private initializeErrorHandlers(): void {
    // ç½‘ç»œé”™è¯¯å¤„ç†å™¨
    this.addHandler('network', [
      new NetworkErrorHandler(),
      new RetryHandler(this.retryManager),
      new FallbackHandler()
    ]);
    
    // æœåŠ¡å™¨é”™è¯¯å¤„ç†å™¨
    this.addHandler('server', [
      new ServerErrorHandler(),
      new RetryHandler(this.retryManager),
      new CircuitBreakerHandler()
    ]);
    
    // è®¤è¯é”™è¯¯å¤„ç†å™¨
    this.addHandler('auth', [
      new AuthenticationErrorHandler(),
      new SessionRefreshHandler()
    ]);
    
    // å†²çªé”™è¯¯å¤„ç†å™¨
    this.addHandler('conflict', [
      new ConflictResolutionHandler(),
      new UserNotificationHandler()
    ]);
    
    // è¶…æ—¶é”™è¯¯å¤„ç†å™¨
    this.addHandler('timeout', [
      new TimeoutHandler(),
      new RetryHandler(this.retryManager)
    ]);
  }
  
  private addHandler(errorType: string, handlers: ErrorHandler[]): void {
    this.errorHandlers.set(errorType, handlers);
  }
  
  async handleError(error: any, context: ErrorContext): Promise<ErrorResult> {
    // 1. é”™è¯¯åˆ†ç±»
    const classifiedError = this.classifyError(error);
    
    // 2. è·å–é”™è¯¯å¤„ç†å™¨
    const handlers = this.errorHandlers.get(classifiedError.type) || 
                    this.errorHandlers.get('unknown') || [];
    
    // 3. æ‰§è¡Œé”™è¯¯å¤„ç†ç®¡é“
    let result: ErrorResult = {
      handled: false,
      action: 'none',
      error: classifiedError
    };
    
    for (const handler of handlers) {
      try {
        const handlerResult = await handler.handle(classifiedError, context);
        result = { ...result, ...handlerResult };
        
        if (handlerResult.stopPropagation) {
          break;
        }
      } catch (handlerError) {
        console.error('Error handler failed:', handlerError);
      }
    }
    
    // 4. è®°å½•é”™è¯¯æŒ‡æ ‡
    this.recordErrorMetrics(classifiedError, result);
    
    return result;
  }
  
  private classifyError(error: any): ClassifiedError {
    let type: string;
    let severity: ClassifiedError['severity'];
    let retryable: boolean;
    let recovery: RecoveryStrategy;
    
    // é”™è¯¯ç±»å‹åˆ†ç±»
    if (error?.name === 'NetworkError' || error?.message?.includes('Network')) {
      type = 'network';
      severity = 'medium';
      retryable = true;
      recovery = { action: 'retry', maxAttempts: 5 };
    } else if (error?.status === 401) {
      type = 'auth';
      severity = 'high';
      retryable = false;
      recovery = { action: 'manual' };
    } else if (error?.status >= 500) {
      type = 'server';
      severity = error?.status === 503 ? 'high' : 'medium';
      retryable = true;
      recovery = { action: 'retry', maxAttempts: 3 };
    } else if (error?.name === 'TimeoutError') {
      type = 'timeout';
      severity = 'medium';
      retryable = true;
      recovery = { action: 'retry', maxAttempts: 4 };
    } else if (error?.message?.includes('conflict')) {
      type = 'conflict';
      severity = 'low';
      retryable = false;
      recovery = { action: 'manual' };
    } else {
      type = 'unknown';
      severity = 'medium';
      retryable = false;
      recovery = { action: 'manual' };
    }
    
    return {
      type,
      severity,
      retryable,
      recovery,
      originalError: error,
      timestamp: new Date(),
      message: error?.message || 'Unknown error',
      stack: error?.stack
    };
  }
  
  private recordErrorMetrics(error: ClassifiedError, result: ErrorResult): void {
    // è®°å½•é”™è¯¯æŒ‡æ ‡ç”¨äºç›‘æ§å’Œåˆ†æ
    const metric = {
      errorType: error.type,
      severity: error.severity,
      action: result.action,
      timestamp: new Date(),
      context: result.context
    };
    
    // å‘é€åˆ°ç›‘æ§ç³»ç»Ÿ
    this.sendToMonitoring(metric);
  }
  
  private sendToMonitoring(metric: any): void {
    // å®ç°ç›‘æ§æ•°æ®å‘é€é€»è¾‘
    console.log('Error metric:', metric);
  }
}

interface ErrorContext {
  operation: string;
  entityId?: string;
  attempt: number;
  networkState?: EnhancedNetworkState;
  userAction?: string;
}

interface ClassifiedError {
  type: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  retryable: boolean;
  recovery: RecoveryStrategy;
  originalError: any;
  timestamp: Date;
  message: string;
  stack?: string;
}

interface ErrorResult {
  handled: boolean;
  action: 'retry' | 'skip' | 'manual' | 'fallback' | 'none';
  error: ClassifiedError;
  stopPropagation?: boolean;
  context?: any;
}
```

### 3. ç”¨æˆ·ä½“éªŒä¼˜åŒ–

#### 3.1 é”™è¯¯åé¦ˆç³»ç»Ÿ
```typescript
class UserFeedbackManager {
  private notifications: Map<string, UserNotification> = new Map();
  
  async showErrorFeedback(error: ClassifiedError, context: ErrorContext): Promise<void> {
    const notification = this.createErrorNotification(error, context);
    
    // æ˜¾ç¤ºç”¨æˆ·é€šçŸ¥
    this.showNotification(notification);
    
    // æ ¹æ®é”™è¯¯ä¸¥é‡ç¨‹åº¦æä¾›æ¢å¤å»ºè®®
    if (error.severity === 'high' || error.severity === 'critical') {
      this.showRecoveryOptions(error, context);
    }
    
    // è®°å½•ç”¨æˆ·åé¦ˆ
    this.recordUserFeedback(error, notification);
  }
  
  private createErrorNotification(error: ClassifiedError, context: ErrorContext): UserNotification {
    const baseMessage = this.getBaseErrorMessage(error);
    const actionMessage = this.getActionMessage(error);
    
    return {
      id: crypto.randomUUID(),
      type: 'error',
      severity: error.severity,
      title: this.getTitle(error),
      message: `${baseMessage}. ${actionMessage}`,
      actions: this.getAvailableActions(error),
      timestamp: new Date(),
      autoClose: error.severity === 'low' ? 5000 : undefined
    };
  }
  
  private getBaseErrorMessage(error: ClassifiedError): string {
    switch (error.type) {
      case 'network':
        return 'ç½‘ç»œè¿æ¥å‡ºç°é—®é¢˜';
      case 'auth':
        return 'èº«ä»½éªŒè¯å¤±è´¥';
      case 'server':
        return 'æœåŠ¡å™¨å“åº”å¼‚å¸¸';
      case 'timeout':
        return 'æ“ä½œè¶…æ—¶';
      case 'conflict':
        return 'æ•°æ®å‘ç”Ÿå†²çª';
      default:
        return 'åŒæ­¥æ“ä½œå¤±è´¥';
    }
  }
  
  private getActionMessage(error: ClassifiedError): string {
    if (error.retryable) {
      return 'ç³»ç»Ÿå°†è‡ªåŠ¨é‡è¯•ï¼Œè¯·ç¨å€™...';
    }
    
    switch (error.type) {
      case 'auth':
        return 'è¯·é‡æ–°ç™»å½•';
      case 'conflict':
        return 'è¯·æ‰‹åŠ¨è§£å†³å†²çª';
      default:
        return 'è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥åé‡è¯•';
    }
  }
  
  private getTitle(error: ClassifiedError): string {
    const titles = {
      network: 'ç½‘ç»œé”™è¯¯',
      auth: 'ç™»å½•é—®é¢˜',
      server: 'æœåŠ¡å™¨é”™è¯¯',
      timeout: 'æ“ä½œè¶…æ—¶',
      conflict: 'æ•°æ®å†²çª',
      unknown: 'åŒæ­¥å¤±è´¥'
    };
    
    return titles[error.type] || 'é”™è¯¯';
  }
  
  private getAvailableActions(error: ClassifiedError): UserAction[] {
    const actions: UserAction[] = [];
    
    // åŸºç¡€æ“ä½œ
    actions.push({
      label: 'å¿½ç•¥',
      action: 'ignore',
      primary: false
    });
    
    // æ ¹æ®é”™è¯¯ç±»å‹æ·»åŠ ç‰¹å®šæ“ä½œ
    if (error.retryable) {
      actions.unshift({
        label: 'ç«‹å³é‡è¯•',
        action: 'retry',
        primary: true
      });
    }
    
    if (error.type === 'auth') {
      actions.unshift({
        label: 'é‡æ–°ç™»å½•',
        action: 'reauth',
        primary: true
      });
    }
    
    if (error.type === 'conflict') {
      actions.unshift({
        label: 'è§£å†³å†²çª',
        action: 'resolve',
        primary: true
      });
    }
    
    return actions;
  }
  
  private showNotification(notification: UserNotification): void {
    // å®ç°é€šçŸ¥æ˜¾ç¤ºé€»è¾‘
    console.log('Show notification:', notification);
    
    // è¿™é‡Œå¯ä»¥é›†æˆå…·ä½“çš„é€šçŸ¥åº“ï¼Œå¦‚ react-toastifyã€notistack ç­‰
    this.notifications.set(notification.id, notification);
    
    // è‡ªåŠ¨å…³é—­å¤„ç†
    if (notification.autoClose) {
      setTimeout(() => {
        this.closeNotification(notification.id);
      }, notification.autoClose);
    }
  }
  
  private showRecoveryOptions(error: ClassifiedError, context: ErrorContext): void {
    // æ˜¾ç¤ºè¯¦ç»†çš„æ¢å¤é€‰é¡¹å¯¹è¯æ¡†
    console.log('Show recovery options for:', error);
  }
  
  private recordUserFeedback(error: ClassifiedError, notification: UserNotification): void {
    // è®°å½•ç”¨æˆ·åé¦ˆç”¨äºæ”¹è¿›é”™è¯¯å¤„ç†
    const feedback = {
      errorType: error.type,
      severity: error.severity,
      notificationId: notification.id,
      userAction: 'pending', // ç”¨æˆ·å°šæœªé‡‡å–è¡ŒåŠ¨
      timestamp: new Date()
    };
    
    console.log('User feedback recorded:', feedback);
  }
  
  public handleUserAction(notificationId: string, action: string): void {
    const notification = this.notifications.get(notificationId);
    if (!notification) return;
    
    // å¤„ç†ç”¨æˆ·æ“ä½œ
    console.log(`User action '${action}' for notification ${notificationId}`);
    
    // æ›´æ–°åé¦ˆè®°å½•
    this.updateUserFeedback(notificationId, action);
    
    // å…³é—­é€šçŸ¥
    this.closeNotification(notificationId);
  }
  
  private updateUserFeedback(notificationId: string, action: string): void {
    // æ›´æ–°ç”¨æˆ·åé¦ˆè®°å½•
    console.log(`Update feedback for ${notificationId}: ${action}`);
  }
  
  private closeNotification(notificationId: string): void {
    this.notifications.delete(notificationId);
  }
}

interface UserNotification {
  id: string;
  type: 'error' | 'warning' | 'info';
  severity: 'low' | 'medium' | 'high' | 'critical';
  title: string;
  message: string;
  actions: UserAction[];
  timestamp: Date;
  autoClose?: number;
}

interface UserAction {
  label: string;
  action: string;
  primary: boolean;
}
```

---

## ğŸ”„ æ™ºèƒ½åŒæ­¥è°ƒåº¦å™¨

### 1. ç½‘ç»œæ„ŸçŸ¥çš„åŒæ­¥è°ƒåº¦

#### 1.1 æ™ºèƒ½è°ƒåº¦ç®—æ³•
```typescript
class SmartSyncScheduler {
  private networkMonitor: NetworkQualityMonitor;
  private syncQueue: PriorityQueue<SyncOperation>;
  private activeOperations: Set<string> = new Set();
  private syncMetrics: SyncMetricsCollector;
  
  constructor() {
    this.networkMonitor = new NetworkQualityMonitor();
    this.syncQueue = new PriorityQueue<SyncOperation>();
    this.syncMetrics = new SyncMetricsCollector();
    
    this.initializeScheduler();
  }
  
  private initializeScheduler(): void {
    // ç›‘å¬ç½‘ç»œè´¨é‡å˜åŒ–
    window.addEventListener('networkQualityChange', (event) => {
      this.handleNetworkQualityChange(event.detail);
    });
    
    // ç›‘å¬ç³»ç»Ÿåœ¨çº¿çŠ¶æ€
    window.addEventListener('online', () => this.handleOnline());
    window.addEventListener('offline', () => this.handleOffline());
    
    // å®šæœŸè°ƒåº¦æ£€æŸ¥
    setInterval(() => this.processSyncQueue(), 1000);
    
    // ç³»ç»Ÿå¯è§æ€§å˜åŒ–å¤„ç†
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible') {
        this.processVisibleSyncQueue();
      }
    });
  }
  
  private handleNetworkQualityChange(networkState: EnhancedNetworkState): void {
    // æ ¹æ®ç½‘ç»œè´¨é‡è°ƒæ•´åŒæ­¥ç­–ç•¥
    this.adjustSyncStrategy(networkState);
    
    // ç½‘ç»œè´¨é‡æ”¹å–„æ—¶ä¸»åŠ¨è°ƒåº¦
    if (this.isNetworkQualityImproved(networkState)) {
      this.processSyncQueue();
    }
  }
  
  private handleOnline(): void {
    // ç½‘ç»œæ¢å¤æ—¶çš„æ™ºèƒ½è°ƒåº¦
    this.schedulePrioritySync();
    this.syncMetrics.recordNetworkRecovery();
  }
  
  private handleOffline(): void {
    // ç½‘ç»œæ–­å¼€æ—¶æš‚åœåŒæ­¥
    this.pauseAllSyncOperations();
    this.syncMetrics.recordNetworkDisconnection();
  }
  
  private async processSyncQueue(): Promise<void> {
    if (!this.shouldProcessSyncQueue()) {
      return;
    }
    
    const networkState = this.networkMonitor.getCurrentNetworkState();
    const maxConcurrent = this.calculateMaxConcurrentOperations(networkState);
    
    while (this.activeOperations.size < maxConcurrent && !this.syncQueue.isEmpty()) {
      const operation = this.getNextOperation(networkState);
      if (!operation) break;
      
      this.activeOperations.add(operation.id);
      
      // å¼‚æ­¥æ‰§è¡Œæ“ä½œ
      this.executeSyncOperation(operation)
        .finally(() => {
          this.activeOperations.delete(operation.id);
        });
    }
  }
  
  private shouldProcessSyncQueue(): boolean {
    const networkState = this.networkMonitor.getCurrentNetworkState();
    
    // ç¦»çº¿æ—¶ä¸å¤„ç†
    if (networkState.status === 'offline') {
      return false;
    }
    
    // ç”µæ± ç”µé‡ä½æ—¶é™åˆ¶åŒæ­¥
    if (this.isBatteryLow() && !this.hasPriorityOperations()) {
      return false;
    }
    
    // ç³»ç»Ÿç¹å¿™æ—¶é™åˆ¶åŒæ­¥
    if (this.isSystemBusy()) {
      return false;
    }
    
    return true;
  }
  
  private calculateMaxConcurrentOperations(networkState: EnhancedNetworkState): number {
    const baseConcurrent = 3;
    
    switch (networkState.status) {
      case 'online':
        return baseConcurrent * 2; // è‰¯å¥½ç½‘ç»œï¼Œå¢åŠ å¹¶å‘
      case 'slow':
        return Math.max(1, baseConcurrent - 1); // æ…¢é€Ÿç½‘ç»œï¼Œå‡å°‘å¹¶å‘
      case 'unstable':
        return 1; // ä¸ç¨³å®šç½‘ç»œï¼Œå•çº¿ç¨‹æ“ä½œ
      default:
        return baseConcurrent;
    }
  }
  
  private getNextOperation(networkState: EnhancedNetworkState): SyncOperation | null {
    // æ ¹æ®ç½‘ç»œçŠ¶æ€å’Œä¼˜å…ˆçº§é€‰æ‹©ä¸‹ä¸€ä¸ªæ“ä½œ
    const priorities = this.calculateOperationPriorities(networkState);
    
    for (const priority of priorities) {
      const operation = this.syncQueue.peek(priority);
      if (operation && this.shouldExecuteOperation(operation, networkState)) {
        return this.syncQueue.dequeue(priority);
      }
    }
    
    return null;
  }
  
  private calculateOperationPriorities(networkState: EnhancedNetworkState): SyncPriority[] {
    // æ ¹æ®ç½‘ç»œçŠ¶å†µè°ƒæ•´ä¼˜å…ˆçº§é¡ºåº
    switch (networkState.status) {
      case 'unstable':
        return ['critical', 'high']; // ä¸ç¨³å®šç½‘ç»œåªå¤„ç†å…³é”®æ“ä½œ
      case 'slow':
        return ['critical', 'high', 'normal']; // æ…¢é€Ÿç½‘ç»œè·³è¿‡ä½ä¼˜å…ˆçº§
      default:
        return ['critical', 'high', 'normal', 'low'];
    }
  }
  
  private shouldExecuteOperation(operation: SyncOperation, networkState: EnhancedNetworkState): boolean {
    // æ£€æŸ¥æ“ä½œæ˜¯å¦é€‚åˆå½“å‰ç½‘ç»œçŠ¶å†µ
    if (operation.estimatedSize && networkState.bandwidth > 0) {
      const estimatedTime = operation.estimatedSize / (networkState.bandwidth * 1024 * 1024); // MB/s
      return estimatedTime < 30; // å•ä¸ªæ“ä½œä¸è¶…è¿‡30ç§’
    }
    
    return true;
  }
  
  private async executeSyncOperation(operation: SyncOperation): Promise<void> {
    const startTime = performance.now();
    
    try {
      // è®°å½•æ“ä½œå¼€å§‹
      this.syncMetrics.recordOperationStart(operation);
      
      // æ‰§è¡ŒåŒæ­¥æ“ä½œ
      await this.performSyncOperation(operation);
      
      // è®°å½•æ“ä½œæˆåŠŸ
      const duration = performance.now() - startTime;
      this.syncMetrics.recordOperationSuccess(operation, duration);
      
    } catch (error) {
      // è®°å½•æ“ä½œå¤±è´¥
      const duration = performance.now() - startTime;
      this.syncMetrics.recordOperationFailure(operation, error, duration);
      
      // é”™è¯¯å¤„ç†
      await this.handleSyncError(operation, error);
    }
  }
  
  private adjustSyncStrategy(networkState: EnhancedNetworkState): void {
    // æ ¹æ®ç½‘ç»œè´¨é‡è°ƒæ•´åŒæ­¥ç­–ç•¥
    switch (networkState.status) {
      case 'slow':
        this.enableLowBandwidthMode();
        break;
      case 'unstable':
        this.enableUnstableNetworkMode();
        break;
      case 'online':
        this.enableNormalSyncMode();
        break;
    }
  }
  
  private isNetworkQualityImproved(networkState: EnhancedNetworkState): boolean {
    const history = this.networkMonitor.getNetworkQualityHistory();
    if (history.length < 2) return false;
    
    const previous = history[history.length - 2];
    const current = history[history.length - 1];
    
    // ç½‘ç»œçŠ¶æ€æ”¹å–„åˆ¤æ–­
    return (
      (previous.status === 'unstable' && current.status !== 'unstable') ||
      (previous.status === 'slow' && current.status === 'online') ||
      (current.latency < previous.latency * 0.8)
    );
  }
  
  private schedulePrioritySync(): void {
    // ç½‘ç»œæ¢å¤æ—¶ä¼˜å…ˆåŒæ­¥é‡è¦æ“ä½œ
    const priorityOperations = this.syncQueue.filter(op => 
      op.priority === 'critical' || op.priority === 'high'
    );
    
    if (priorityOperations.length > 0) {
      this.processSyncQueue();
    }
  }
  
  private processVisibleSyncQueue(): void {
    // é¡µé¢å¯è§æ—¶çš„åŒæ­¥é˜Ÿåˆ—å¤„ç†
    if (this.hasPendingUserInteractions()) {
      // ç”¨æˆ·æœ‰äº¤äº’æ—¶ï¼Œä¼˜å…ˆåŒæ­¥ç›¸å…³æ•°æ®
      this.processUserRelatedSync();
    } else {
      this.processSyncQueue();
    }
  }
  
  private pauseAllSyncOperations(): void {
    // æš‚åœæ‰€æœ‰æ­£åœ¨è¿›è¡Œçš„åŒæ­¥æ“ä½œ
    console.log('Pausing all sync operations due to offline status');
    // å®ç°æš‚åœé€»è¾‘
  }
  
  private hasPendingUserInteractions(): boolean {
    // æ£€æŸ¥æ˜¯å¦æœ‰å¾…å¤„ç†çš„ç”¨æˆ·äº¤äº’
    return false;
  }
  
  private processUserRelatedSync(): void {
    // å¤„ç†ç”¨æˆ·ç›¸å…³çš„åŒæ­¥æ“ä½œ
    console.log('Processing user-related sync operations');
  }
  
  private isBatteryLow(): boolean {
    // æ£€æŸ¥ç”µæ± ç”µé‡
    if ('getBattery' in navigator) {
      // å®ç°ç”µæ± æ£€æŸ¥é€»è¾‘
    }
    return false;
  }
  
  private hasPriorityOperations(): boolean {
    return this.syncQueue.some(op => op.priority === 'critical');
  }
  
  private isSystemBusy(): boolean {
    // æ£€æŸ¥ç³»ç»Ÿæ˜¯å¦ç¹å¿™
    return false;
  }
  
  private enableLowBandwidthMode(): void {
    console.log('Enabling low bandwidth sync mode');
  }
  
  private enableUnstableNetworkMode(): void {
    console.log('Enabling unstable network sync mode');
  }
  
  private enableNormalSyncMode(): void {
    console.log('Enabling normal sync mode');
  }
  
  private async performSyncOperation(operation: SyncOperation): Promise<void> {
    // å®ç°å®é™…çš„åŒæ­¥æ“ä½œ
    console.log('Executing sync operation:', operation);
  }
  
  private async handleSyncError(operation: SyncOperation, error: any): Promise<void> {
    // å¤„ç†åŒæ­¥é”™è¯¯
    console.error('Sync operation failed:', operation, error);
  }
}

interface SyncOperation {
  id: string;
  type: string;
  priority: 'critical' | 'high' | 'normal' | 'low';
  estimatedSize?: number;
  data: any;
}

type SyncPriority = 'critical' | 'high' | 'normal' | 'low';

class SyncMetricsCollector {
  recordOperationStart(operation: SyncOperation): void {
    console.log('Operation started:', operation.id);
  }
  
  recordOperationSuccess(operation: SyncOperation, duration: number): void {
    console.log(`Operation ${operation.id} succeeded in ${duration}ms`);
  }
  
  recordOperationFailure(operation: SyncOperation, error: any, duration: number): void {
    console.error(`Operation ${operation.id} failed after ${duration}ms:`, error);
  }
  
  recordNetworkRecovery(): void {
    console.log('Network recovery detected');
  }
  
  recordNetworkDisconnection(): void {
    console.log('Network disconnection detected');
  }
}
```

---

## ğŸ“Š ç›‘æ§å’Œåˆ†æ

### 1. åŒæ­¥æ€§èƒ½ç›‘æ§

#### 1.1 å®æ—¶ç›‘æ§æŒ‡æ ‡
```typescript
class SyncPerformanceMonitor {
  private metrics: Map<string, PerformanceMetric[]> = new Map();
  private alerts: Alert[] = [];
  
  constructor() {
    this.initializeMonitoring();
  }
  
  private initializeMonitoring(): void {
    // æ¯åˆ†é’Ÿæ”¶é›†ä¸€æ¬¡æŒ‡æ ‡
    setInterval(() => this.collectMetrics(), 60000);
    
    // æ¯5åˆ†é’Ÿåˆ†æä¸€æ¬¡è¶‹åŠ¿
    setInterval(() => this.analyzeTrends(), 5 * 60000);
    
    // å®æ—¶ç›‘æ§å…³é”®æŒ‡æ ‡
    this.setupRealtimeMonitoring();
  }
  
  private async collectMetrics(): Promise<void> {
    const timestamp = new Date();
    
    // æ”¶é›†ç³»ç»ŸæŒ‡æ ‡
    const systemMetrics = await this.collectSystemMetrics();
    
    // æ”¶é›†åŒæ­¥æŒ‡æ ‡
    const syncMetrics = await this.collectSyncMetrics();
    
    // æ”¶é›†ç½‘ç»œæŒ‡æ ‡
    const networkMetrics = await this.collectNetworkMetrics();
    
    // å­˜å‚¨æŒ‡æ ‡
    this.storeMetrics(timestamp, {
      system: systemMetrics,
      sync: syncMetrics,
      network: networkMetrics
    });
    
    // æ£€æŸ¥å‘Šè­¦æ¡ä»¶
    this.checkAlerts({
      timestamp,
      system: systemMetrics,
      sync: syncMetrics,
      network: networkMetrics
    });
  }
  
  private async collectSystemMetrics(): Promise<SystemMetrics> {
    return {
      memoryUsage: performance.memory?.usedJSHeapSize || 0,
      cpuUsage: await this.measureCPUUsage(),
      batteryLevel: await this.getBatteryLevel(),
      deviceType: this.getDeviceType()
    };
  }
  
  private async collectSyncMetrics(): Promise<SyncMetrics> {
    return {
      queueLength: this.getSyncQueueLength(),
      activeOperations: this.getActiveOperationCount(),
      successRate: this.calculateSuccessRate(),
      averageSyncTime: this.calculateAverageSyncTime(),
      errorRate: this.calculateErrorRate(),
      conflictsDetected: this.getConflictCount()
    };
  }
  
  private async collectNetworkMetrics(): Promise<NetworkMetrics> {
    const connection = (navigator as any).connection;
    
    return {
      effectiveType: connection?.effectiveType || 'unknown',
      downlink: connection?.downlink || 0,
      rtt: connection?.rtt || 0,
      online: navigator.onLine,
      latency: await this.measureNetworkLatency()
    };
  }
  
  private storeMetrics(timestamp: Date, metrics: CollectedMetrics): void {
    const key = timestamp.toISOString();
    this.metrics.set(key, metrics);
    
    // ä¿æŒæœ€è¿‘24å°æ—¶çš„æ•°æ®
    const cutoff = new Date(timestamp.getTime() - 24 * 60 * 60 * 1000);
    for (const [metricKey, metricData] of this.metrics.entries()) {
      if (new Date(metricKey) < cutoff) {
        this.metrics.delete(metricKey);
      }
    }
  }
  
  private checkAlerts(metrics: CollectedMetrics): void {
    // åŒæ­¥æ—¶é—´è¿‡é•¿å‘Šè­¦
    if (metrics.sync.averageSyncTime > 10000) {
      this.createAlert({
        type: 'performance',
        severity: 'warning',
        message: 'Average sync time exceeds 10 seconds',
        metrics: metrics.sync
      });
    }
    
    // é”™è¯¯ç‡è¿‡é«˜å‘Šè­¦
    if (metrics.sync.errorRate > 0.1) {
      this.createAlert({
        type: 'error',
        severity: 'high',
        message: 'Sync error rate exceeds 10%',
        metrics: metrics.sync
      });
    }
    
    // å†…å­˜ä½¿ç”¨è¿‡é«˜å‘Šè­¦
    if (metrics.system.memoryUsage > 100 * 1024 * 1024) {
      this.createAlert({
        type: 'memory',
        severity: 'warning',
        message: 'Memory usage exceeds 100MB',
        metrics: metrics.system
      });
    }
    
    // ç½‘ç»œè´¨é‡å·®å‘Šè­¦
    if (metrics.network.latency > 2000) {
      this.createAlert({
        type: 'network',
        severity: 'medium',
        message: 'Network latency exceeds 2 seconds',
        metrics: metrics.network
      });
    }
  }
  
  private createAlert(alert: Omit<Alert, 'id' | 'timestamp'>): void {
    const fullAlert: Alert = {
      ...alert,
      id: crypto.randomUUID(),
      timestamp: new Date()
    };
    
    this.alerts.push(fullAlert);
    
    // å‘é€å‘Šè­¦é€šçŸ¥
    this.sendAlertNotification(fullAlert);
    
    // ä¿æŒæœ€è¿‘100ä¸ªå‘Šè­¦
    if (this.alerts.length > 100) {
      this.alerts = this.alerts.slice(-100);
    }
  }
  
  private sendAlertNotification(alert: Alert): void {
    console.warn('Alert:', alert);
    
    // è¿™é‡Œå¯ä»¥é›†æˆé‚®ä»¶ã€Slackç­‰é€šçŸ¥ç³»ç»Ÿ
    if (alert.severity === 'high' || alert.severity === 'critical') {
      // ç´§æ€¥å‘Šè­¦ç«‹å³é€šçŸ¥
      this.sendImmediateNotification(alert);
    }
  }
  
  private analyzeTrends(): void {
    const recentMetrics = Array.from(this.metrics.values()).slice(-60); // æœ€è¿‘1å°æ—¶
    
    if (recentMetrics.length < 30) return;
    
    // åˆ†ææ€§èƒ½è¶‹åŠ¿
    const performanceTrend = this.analyzePerformanceTrend(recentMetrics);
    const errorTrend = this.analyzeErrorTrend(recentMetrics);
    const networkTrend = this.analyzeNetworkTrend(recentMetrics);
    
    // å¦‚æœè¶‹åŠ¿æ¶åŒ–ï¼Œåˆ›å»ºè¶‹åŠ¿å‘Šè­¦
    if (performanceTrend.direction === 'degrading') {
      this.createAlert({
        type: 'trend',
        severity: 'medium',
        message: 'Performance trend is degrading',
        trend: performanceTrend
      });
    }
    
    if (errorTrend.direction === 'increasing') {
      this.createAlert({
        type: 'trend',
        severity: 'high',
        message: 'Error rate is increasing',
        trend: errorTrend
      });
    }
  }
  
  private analyzePerformanceTrend(metrics: CollectedMetrics[]): TrendAnalysis {
    const syncTimes = metrics.map(m => m.sync.averageSyncTime).filter(t => t > 0);
    
    if (syncTimes.length < 10) {
      return { direction: 'insufficient_data', confidence: 0 };
    }
    
    const recent = syncTimes.slice(-10);
    const older = syncTimes.slice(0, 10);
    
    const recentAvg = recent.reduce((a, b) => a + b) / recent.length;
    const olderAvg = older.reduce((a, b) => a + b) / older.length;
    
    const change = (recentAvg - olderAvg) / olderAvg;
    const confidence = Math.min(Math.abs(change) * 10, 1);
    
    let direction: 'improving' | 'stable' | 'degrading';
    if (change < -0.1) direction = 'improving';
    else if (change > 0.1) direction = 'degrading';
    else direction = 'stable';
    
    return {
      direction,
      change,
      confidence,
      recentAverage: recentAvg,
      olderAverage: olderAvg
    };
  }
  
  private analyzeErrorTrend(metrics: CollectedMetrics[]): TrendAnalysis {
    const errorRates = metrics.map(m => m.sync.errorRate);
    
    if (errorRates.length < 10) {
      return { direction: 'insufficient_data', confidence: 0 };
    }
    
    const recent = errorRates.slice(-10);
    const older = errorRates.slice(0, 10);
    
    const recentAvg = recent.reduce((a, b) => a + b) / recent.length;
    const olderAvg = older.reduce((a, b) => a + b) / older.length;
    
    const change = (recentAvg - olderAvg) / (olderAvg || 0.01);
    const confidence = Math.min(Math.abs(change) * 5, 1);
    
    let direction: 'improving' | 'stable' | 'increasing';
    if (change < -0.05) direction = 'improving';
    else if (change > 0.05) direction = 'increasing';
    else direction = 'stable';
    
    return {
      direction: direction === 'improving' ? 'improving' : direction,
      change,
      confidence,
      recentAverage: recentAvg,
      olderAverage: olderAvg
    };
  }
  
  private analyzeNetworkTrend(metrics: CollectedMetrics[]): TrendAnalysis {
    const latencies = metrics.map(m => m.network.latency).filter(l => l > 0 && l < Infinity);
    
    if (latencies.length < 10) {
      return { direction: 'insufficient_data', confidence: 0 };
    }
    
    const recent = latencies.slice(-10);
    const older = latencies.slice(0, 10);
    
    const recentAvg = recent.reduce((a, b) => a + b) / recent.length;
    const olderAvg = older.reduce((a, b) => a + b) / older.length;
    
    const change = (recentAvg - olderAvg) / olderAvg;
    const confidence = Math.min(Math.abs(change) * 8, 1);
    
    let direction: 'improving' | 'stable' | 'degrading';
    if (change < -0.1) direction = 'improving';
    else if (change > 0.1) direction = 'degrading';
    else direction = 'stable';
    
    return {
      direction,
      change,
      confidence,
      recentAverage: recentAvg,
      olderAverage: olderAvg
    };
  }
  
  private async measureCPUUsage(): Promise<number> {
    // ç®€åŒ–çš„CPUä½¿ç”¨ç‡æµ‹é‡
    return 0;
  }
  
  private async getBatteryLevel(): Promise<number> {
    if ('getBattery' in navigator) {
      try {
        const battery = await (navigator as any).getBattery();
        return battery.level * 100;
      } catch (error) {
        return 100;
      }
    }
    return 100;
  }
  
  private getDeviceType(): string {
    const userAgent = navigator.userAgent.toLowerCase();
    if (userAgent.includes('mobile')) return 'mobile';
    if (userAgent.includes('tablet')) return 'tablet';
    return 'desktop';
  }
  
  private getSyncQueueLength(): number {
    return 0; // å®é™…å®ç°ä¸­è¿”å›é˜Ÿåˆ—é•¿åº¦
  }
  
  private getActiveOperationCount(): number {
    return 0; // å®é™…å®ç°ä¸­è¿”å›æ´»è·ƒæ“ä½œæ•°
  }
  
  private calculateSuccessRate(): number {
    return 0.95; // å®é™…å®ç°ä¸­è®¡ç®—æˆåŠŸç‡
  }
  
  private calculateAverageSyncTime(): number {
    return 3000; // å®é™…å®ç°ä¸­è®¡ç®—å¹³å‡åŒæ­¥æ—¶é—´
  }
  
  private calculateErrorRate(): number {
    return 0.05; // å®é™…å®ç°ä¸­è®¡ç®—é”™è¯¯ç‡
  }
  
  private getConflictCount(): number {
    return 0; // å®é™…å®ç°ä¸­è¿”å›å†²çªæ•°
  }
  
  private async measureNetworkLatency(): Promise<number> {
    return 100; // å®é™…å®ç°ä¸­æµ‹é‡ç½‘ç»œå»¶è¿Ÿ
  }
  
  private sendImmediateNotification(alert: Alert): void {
    console.log('Immediate alert notification:', alert);
  }
  
  private setupRealtimeMonitoring(): void {
    // è®¾ç½®å®æ—¶ç›‘æ§
    console.log('Setting up real-time monitoring');
  }
}

interface SystemMetrics {
  memoryUsage: number;
  cpuUsage: number;
  batteryLevel: number;
  deviceType: string;
}

interface SyncMetrics {
  queueLength: number;
  activeOperations: number;
  successRate: number;
  averageSyncTime: number;
  errorRate: number;
  conflictsDetected: number;
}

interface NetworkMetrics {
  effectiveType: string;
  downlink: number;
  rtt: number;
  online: boolean;
  latency: number;
}

interface CollectedMetrics {
  system: SystemMetrics;
  sync: SyncMetrics;
  network: NetworkMetrics;
}

interface Alert {
  id: string;
  type: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  message: string;
  timestamp: Date;
  metrics?: any;
  trend?: TrendAnalysis;
}

interface TrendAnalysis {
  direction: 'improving' | 'stable' | 'degrading' | 'increasing' | 'insufficient_data';
  change: number;
  confidence: number;
  recentAverage?: number;
  olderAverage?: number;
}
```

---

## ğŸ¯ æ”¹è¿›å»ºè®®æ€»ç»“

### 1. ç½‘ç»œçŠ¶æ€ç®¡ç†æ”¹è¿›

#### 1.1 ç«‹å³å®æ–½é¡¹
1. **å®ç°å¤šç»´åº¦ç½‘ç»œæ£€æµ‹**ï¼šä¸ä»…æ£€æµ‹åœ¨çº¿/ç¦»çº¿ï¼Œè¿˜è¦è¯„ä¼°å»¶è¿Ÿã€å¸¦å®½ã€ä¸¢åŒ…ç‡
2. **ç½‘ç»œè´¨é‡å†å²è®°å½•**ï¼šä¿æŒç½‘ç»œè´¨é‡å†å²ï¼Œç”¨äºè¶‹åŠ¿åˆ†æ
3. **æ™ºèƒ½åŒæ­¥è°ƒåº¦**ï¼šæ ¹æ®ç½‘ç»œçŠ¶å†µè°ƒæ•´åŒæ­¥ç­–ç•¥å’Œå¹¶å‘åº¦

#### 1.2 æŠ€æœ¯æ”¶ç›Š
- **å‡å°‘æ— æ•ˆç½‘ç»œè¯·æ±‚**ï¼šé¢„æœŸå‡å°‘30%çš„ç½‘ç»œå¤±è´¥
- **æå‡ç”¨æˆ·ä½“éªŒ**ï¼šç½‘ç»œæ„ŸçŸ¥çš„æ“ä½œåé¦ˆ
- **ä¼˜åŒ–ç”µæ± ä½¿ç”¨**ï¼šæ ¹æ®ç½‘ç»œçŠ¶å†µè°ƒæ•´åŒæ­¥é¢‘ç‡

### 2. é”™è¯¯å¤„ç†æœºåˆ¶æ”¹è¿›

#### 2.1 æ ¸å¿ƒæ”¹è¿›ç‚¹
1. **ç»†ç²’åº¦é”™è¯¯åˆ†ç±»**ï¼šåŒºåˆ†ç½‘ç»œã€è®¤è¯ã€æœåŠ¡å™¨ã€è¶…æ—¶ç­‰ä¸åŒé”™è¯¯ç±»å‹
2. **æ™ºèƒ½é‡è¯•ç­–ç•¥**ï¼šåŸºäºé”™è¯¯ç±»å‹çš„è‡ªé€‚åº”é‡è¯•æœºåˆ¶
3. **ç”¨æˆ·å‹å¥½çš„é”™è¯¯åé¦ˆ**ï¼šæä¾›æ¸…æ™°çš„é”™è¯¯ä¿¡æ¯å’Œæ¢å¤å»ºè®®

#### 2.2 é¢„æœŸæ•ˆæœ
- **æé«˜åŒæ­¥æˆåŠŸç‡**ï¼šä»95%æå‡åˆ°99%+
- **å‡å°‘ç”¨æˆ·å›°æƒ‘**ï¼šæ¸…æ™°çš„é”™è¯¯ä¿¡æ¯å’Œæ¢å¤æŒ‡å¯¼
- **è‡ªåŠ¨åŒ–æ¢å¤**ï¼š80%ä»¥ä¸Šçš„é”™è¯¯å¯ä»¥è‡ªåŠ¨æ¢å¤

### 3. å®æ–½ä¼˜å…ˆçº§

#### 3.1 ç¬¬ä¸€é˜¶æ®µï¼ˆ1-2å‘¨ï¼‰
- å®ç°åŸºç¡€ç½‘ç»œè´¨é‡æ£€æµ‹
- æ”¹è¿›é”™è¯¯åˆ†ç±»æœºåˆ¶
- æ·»åŠ åŸºç¡€é‡è¯•ç­–ç•¥

#### 3.2 ç¬¬äºŒé˜¶æ®µï¼ˆ2-3å‘¨ï¼‰
- å®ç°æ™ºèƒ½åŒæ­¥è°ƒåº¦å™¨
- æ·»åŠ ç”¨æˆ·åé¦ˆç³»ç»Ÿ
- é›†æˆæ€§èƒ½ç›‘æ§

#### 3.3 ç¬¬ä¸‰é˜¶æ®µï¼ˆ1-2å‘¨ï¼‰
- å®Œå–„è¶‹åŠ¿åˆ†æ
- æ·»åŠ å‘Šè­¦ç³»ç»Ÿ
- æ€§èƒ½ä¼˜åŒ–å’Œæµ‹è¯•

---

**åˆ†æå®Œæˆæ—¶é—´ï¼š** 2025å¹´1æœˆ  
**åˆ†æèŒƒå›´ï¼š** CardEverythingåŒæ­¥ç³»ç»Ÿç½‘ç»œçŠ¶æ€å’Œé”™è¯¯å¤„ç†  
**é¢„æœŸæ”¹è¿›æ•ˆæœï¼š** 80%+é”™è¯¯å¤„ç†æ”¹å–„ï¼Œ90%+ç”¨æˆ·æ»¡æ„åº¦æå‡