{"file":"D:\\Projects\\CardEverything\\cardall-prototype\\node_modules\\jest-axe\\node_modules\\jest-diff\\build\\getAlignedDiffs.js","mappings":"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","names":[],"sources":["D:\\Projects\\CardEverything\\cardall-prototype\\node_modules\\jest-axe\\node_modules\\jest-diff\\build\\getAlignedDiffs.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\nvar _cleanupSemantic = require('./cleanupSemantic');\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// Given change op and array of diffs, return concatenated string:\n// * include common strings\n// * include change strings which have argument op with changeColor\n// * exclude change strings which have opposite op\nconst concatenateRelevantDiffs = (op, diffs, changeColor) =>\n  diffs.reduce(\n    (reduced, diff) =>\n      reduced +\n      (diff[0] === _cleanupSemantic.DIFF_EQUAL\n        ? diff[1]\n        : diff[0] === op && diff[1].length !== 0 // empty if change is newline\n        ? changeColor(diff[1])\n        : ''),\n    ''\n  );\n\n// Encapsulate change lines until either a common newline or the end.\nclass ChangeBuffer {\n  op;\n  line; // incomplete line\n  lines; // complete lines\n  changeColor;\n  constructor(op, changeColor) {\n    this.op = op;\n    this.line = [];\n    this.lines = [];\n    this.changeColor = changeColor;\n  }\n  pushSubstring(substring) {\n    this.pushDiff(new _cleanupSemantic.Diff(this.op, substring));\n  }\n  pushLine() {\n    // Assume call only if line has at least one diff,\n    // therefore an empty line must have a diff which has an empty string.\n\n    // If line has multiple diffs, then assume it has a common diff,\n    // therefore change diffs have change color;\n    // otherwise then it has line color only.\n    this.lines.push(\n      this.line.length !== 1\n        ? new _cleanupSemantic.Diff(\n            this.op,\n            concatenateRelevantDiffs(this.op, this.line, this.changeColor)\n          )\n        : this.line[0][0] === this.op\n        ? this.line[0] // can use instance\n        : new _cleanupSemantic.Diff(this.op, this.line[0][1]) // was common diff\n    );\n\n    this.line.length = 0;\n  }\n  isLineEmpty() {\n    return this.line.length === 0;\n  }\n\n  // Minor input to buffer.\n  pushDiff(diff) {\n    this.line.push(diff);\n  }\n\n  // Main input to buffer.\n  align(diff) {\n    const string = diff[1];\n    if (string.includes('\\n')) {\n      const substrings = string.split('\\n');\n      const iLast = substrings.length - 1;\n      substrings.forEach((substring, i) => {\n        if (i < iLast) {\n          // The first substring completes the current change line.\n          // A middle substring is a change line.\n          this.pushSubstring(substring);\n          this.pushLine();\n        } else if (substring.length !== 0) {\n          // The last substring starts a change line, if it is not empty.\n          // Important: This non-empty condition also automatically omits\n          // the newline appended to the end of expected and received strings.\n          this.pushSubstring(substring);\n        }\n      });\n    } else {\n      // Append non-multiline string to current change line.\n      this.pushDiff(diff);\n    }\n  }\n\n  // Output from buffer.\n  moveLinesTo(lines) {\n    if (!this.isLineEmpty()) {\n      this.pushLine();\n    }\n    lines.push(...this.lines);\n    this.lines.length = 0;\n  }\n}\n\n// Encapsulate common and change lines.\nclass CommonBuffer {\n  deleteBuffer;\n  insertBuffer;\n  lines;\n  constructor(deleteBuffer, insertBuffer) {\n    this.deleteBuffer = deleteBuffer;\n    this.insertBuffer = insertBuffer;\n    this.lines = [];\n  }\n  pushDiffCommonLine(diff) {\n    this.lines.push(diff);\n  }\n  pushDiffChangeLines(diff) {\n    const isDiffEmpty = diff[1].length === 0;\n\n    // An empty diff string is redundant, unless a change line is empty.\n    if (!isDiffEmpty || this.deleteBuffer.isLineEmpty()) {\n      this.deleteBuffer.pushDiff(diff);\n    }\n    if (!isDiffEmpty || this.insertBuffer.isLineEmpty()) {\n      this.insertBuffer.pushDiff(diff);\n    }\n  }\n  flushChangeLines() {\n    this.deleteBuffer.moveLinesTo(this.lines);\n    this.insertBuffer.moveLinesTo(this.lines);\n  }\n\n  // Input to buffer.\n  align(diff) {\n    const op = diff[0];\n    const string = diff[1];\n    if (string.includes('\\n')) {\n      const substrings = string.split('\\n');\n      const iLast = substrings.length - 1;\n      substrings.forEach((substring, i) => {\n        if (i === 0) {\n          const subdiff = new _cleanupSemantic.Diff(op, substring);\n          if (\n            this.deleteBuffer.isLineEmpty() &&\n            this.insertBuffer.isLineEmpty()\n          ) {\n            // If both current change lines are empty,\n            // then the first substring is a common line.\n            this.flushChangeLines();\n            this.pushDiffCommonLine(subdiff);\n          } else {\n            // If either current change line is non-empty,\n            // then the first substring completes the change lines.\n            this.pushDiffChangeLines(subdiff);\n            this.flushChangeLines();\n          }\n        } else if (i < iLast) {\n          // A middle substring is a common line.\n          this.pushDiffCommonLine(new _cleanupSemantic.Diff(op, substring));\n        } else if (substring.length !== 0) {\n          // The last substring starts a change line, if it is not empty.\n          // Important: This non-empty condition also automatically omits\n          // the newline appended to the end of expected and received strings.\n          this.pushDiffChangeLines(new _cleanupSemantic.Diff(op, substring));\n        }\n      });\n    } else {\n      // Append non-multiline string to current change lines.\n      // Important: It cannot be at the end following empty change lines,\n      // because newline appended to the end of expected and received strings.\n      this.pushDiffChangeLines(diff);\n    }\n  }\n\n  // Output from buffer.\n  getLines() {\n    this.flushChangeLines();\n    return this.lines;\n  }\n}\n\n// Given diffs from expected and received strings,\n// return new array of diffs split or joined into lines.\n//\n// To correctly align a change line at the end, the algorithm:\n// * assumes that a newline was appended to the strings\n// * omits the last newline from the output array\n//\n// Assume the function is not called:\n// * if either expected or received is empty string\n// * if neither expected nor received is multiline string\nconst getAlignedDiffs = (diffs, changeColor) => {\n  const deleteBuffer = new ChangeBuffer(\n    _cleanupSemantic.DIFF_DELETE,\n    changeColor\n  );\n  const insertBuffer = new ChangeBuffer(\n    _cleanupSemantic.DIFF_INSERT,\n    changeColor\n  );\n  const commonBuffer = new CommonBuffer(deleteBuffer, insertBuffer);\n  diffs.forEach(diff => {\n    switch (diff[0]) {\n      case _cleanupSemantic.DIFF_DELETE:\n        deleteBuffer.align(diff);\n        break;\n      case _cleanupSemantic.DIFF_INSERT:\n        insertBuffer.align(diff);\n        break;\n      default:\n        commonBuffer.align(diff);\n    }\n  });\n  return commonBuffer.getLines();\n};\nvar _default = getAlignedDiffs;\nexports.default = _default;\n"],"version":3}