{"file":"D:\\Projects\\CardEverything\\cardall-prototype\\node_modules\\jest-axe\\node_modules\\jest-diff\\build\\cleanupSemantic.js","mappings":"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","names":[],"sources":["D:\\Projects\\CardEverything\\cardall-prototype\\node_modules\\jest-axe\\node_modules\\jest-diff\\build\\cleanupSemantic.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.cleanupSemantic =\n  exports.Diff =\n  exports.DIFF_INSERT =\n  exports.DIFF_EQUAL =\n  exports.DIFF_DELETE =\n    void 0;\n/**\n * Diff Match and Patch\n * Copyright 2018 The diff-match-patch Authors.\n * https://github.com/google/diff-match-patch\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Computes the difference between two texts to create a patch.\n * Applies the patch onto another text, allowing for errors.\n * @author fraser@google.com (Neil Fraser)\n */\n\n/**\n * CHANGES by pedrottimark to diff_match_patch_uncompressed.ts file:\n *\n * 1. Delete anything not needed to use diff_cleanupSemantic method\n * 2. Convert from prototype properties to var declarations\n * 3. Convert Diff to class from constructor and prototype\n * 4. Add type annotations for arguments and return values\n * 5. Add exports\n */\n\n/**\n * The data structure representing a diff is an array of tuples:\n * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n */\nvar DIFF_DELETE = -1;\nexports.DIFF_DELETE = DIFF_DELETE;\nvar DIFF_INSERT = 1;\nexports.DIFF_INSERT = DIFF_INSERT;\nvar DIFF_EQUAL = 0;\n\n/**\n * Class representing one diff tuple.\n * Attempts to look like a two-element array (which is what this used to be).\n * @param {number} op Operation, one of: DIFF_DELETE, DIFF_INSERT, DIFF_EQUAL.\n * @param {string} text Text to be deleted, inserted, or retained.\n * @constructor\n */\nexports.DIFF_EQUAL = DIFF_EQUAL;\nclass Diff {\n  0;\n  1;\n  constructor(op, text) {\n    this[0] = op;\n    this[1] = text;\n  }\n}\n\n/**\n * Determine the common prefix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the start of each\n *     string.\n */\nexports.Diff = Diff;\nvar diff_commonPrefix = function (text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {\n    return 0;\n  }\n  // Binary search.\n  // Performance analysis: https://neil.fraser.name/news/2007/10/09/\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerstart = 0;\n  while (pointermin < pointermid) {\n    if (\n      text1.substring(pointerstart, pointermid) ==\n      text2.substring(pointerstart, pointermid)\n    ) {\n      pointermin = pointermid;\n      pointerstart = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n  return pointermid;\n};\n\n/**\n * Determine the common suffix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of each string.\n */\nvar diff_commonSuffix = function (text1, text2) {\n  // Quick check for common null cases.\n  if (\n    !text1 ||\n    !text2 ||\n    text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)\n  ) {\n    return 0;\n  }\n  // Binary search.\n  // Performance analysis: https://neil.fraser.name/news/2007/10/09/\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerend = 0;\n  while (pointermin < pointermid) {\n    if (\n      text1.substring(text1.length - pointermid, text1.length - pointerend) ==\n      text2.substring(text2.length - pointermid, text2.length - pointerend)\n    ) {\n      pointermin = pointermid;\n      pointerend = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n  return pointermid;\n};\n\n/**\n * Determine if the suffix of one string is the prefix of another.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of the first\n *     string and the start of the second string.\n * @private\n */\nvar diff_commonOverlap_ = function (text1, text2) {\n  // Cache the text lengths to prevent multiple calls.\n  var text1_length = text1.length;\n  var text2_length = text2.length;\n  // Eliminate the null case.\n  if (text1_length == 0 || text2_length == 0) {\n    return 0;\n  }\n  // Truncate the longer string.\n  if (text1_length > text2_length) {\n    text1 = text1.substring(text1_length - text2_length);\n  } else if (text1_length < text2_length) {\n    text2 = text2.substring(0, text1_length);\n  }\n  var text_length = Math.min(text1_length, text2_length);\n  // Quick check for the worst case.\n  if (text1 == text2) {\n    return text_length;\n  }\n\n  // Start by looking for a single character match\n  // and increase length until no match is found.\n  // Performance analysis: https://neil.fraser.name/news/2010/11/04/\n  var best = 0;\n  var length = 1;\n  while (true) {\n    var pattern = text1.substring(text_length - length);\n    var found = text2.indexOf(pattern);\n    if (found == -1) {\n      return best;\n    }\n    length += found;\n    if (\n      found == 0 ||\n      text1.substring(text_length - length) == text2.substring(0, length)\n    ) {\n      best = length;\n      length++;\n    }\n  }\n};\n\n/**\n * Reduce the number of edits by eliminating semantically trivial equalities.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\nvar diff_cleanupSemantic = function (diffs) {\n  var changes = false;\n  var equalities = []; // Stack of indices where equalities are found.\n  var equalitiesLength = 0; // Keeping our own length var is faster in JS.\n  /** @type {?string} */\n  var lastEquality = null;\n  // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n  var pointer = 0; // Index of current position.\n  // Number of characters that changed prior to the equality.\n  var length_insertions1 = 0;\n  var length_deletions1 = 0;\n  // Number of characters that changed after the equality.\n  var length_insertions2 = 0;\n  var length_deletions2 = 0;\n  while (pointer < diffs.length) {\n    if (diffs[pointer][0] == DIFF_EQUAL) {\n      // Equality found.\n      equalities[equalitiesLength++] = pointer;\n      length_insertions1 = length_insertions2;\n      length_deletions1 = length_deletions2;\n      length_insertions2 = 0;\n      length_deletions2 = 0;\n      lastEquality = diffs[pointer][1];\n    } else {\n      // An insertion or deletion.\n      if (diffs[pointer][0] == DIFF_INSERT) {\n        length_insertions2 += diffs[pointer][1].length;\n      } else {\n        length_deletions2 += diffs[pointer][1].length;\n      }\n      // Eliminate an equality that is smaller or equal to the edits on both\n      // sides of it.\n      if (\n        lastEquality &&\n        lastEquality.length <=\n          Math.max(length_insertions1, length_deletions1) &&\n        lastEquality.length <= Math.max(length_insertions2, length_deletions2)\n      ) {\n        // Duplicate record.\n        diffs.splice(\n          equalities[equalitiesLength - 1],\n          0,\n          new Diff(DIFF_DELETE, lastEquality)\n        );\n        // Change second copy to insert.\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n        // Throw away the equality we just deleted.\n        equalitiesLength--;\n        // Throw away the previous equality (it needs to be reevaluated).\n        equalitiesLength--;\n        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\n        length_insertions1 = 0; // Reset the counters.\n        length_deletions1 = 0;\n        length_insertions2 = 0;\n        length_deletions2 = 0;\n        lastEquality = null;\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n\n  // Normalize the diff.\n  if (changes) {\n    diff_cleanupMerge(diffs);\n  }\n  diff_cleanupSemanticLossless(diffs);\n\n  // Find any overlaps between deletions and insertions.\n  // e.g: <del>abcxxx</del><ins>xxxdef</ins>\n  //   -> <del>abc</del>xxx<ins>def</ins>\n  // e.g: <del>xxxabc</del><ins>defxxx</ins>\n  //   -> <ins>def</ins>xxx<del>abc</del>\n  // Only extract an overlap if it is as big as the edit ahead or behind it.\n  pointer = 1;\n  while (pointer < diffs.length) {\n    if (\n      diffs[pointer - 1][0] == DIFF_DELETE &&\n      diffs[pointer][0] == DIFF_INSERT\n    ) {\n      var deletion = diffs[pointer - 1][1];\n      var insertion = diffs[pointer][1];\n      var overlap_length1 = diff_commonOverlap_(deletion, insertion);\n      var overlap_length2 = diff_commonOverlap_(insertion, deletion);\n      if (overlap_length1 >= overlap_length2) {\n        if (\n          overlap_length1 >= deletion.length / 2 ||\n          overlap_length1 >= insertion.length / 2\n        ) {\n          // Overlap found.  Insert an equality and trim the surrounding edits.\n          diffs.splice(\n            pointer,\n            0,\n            new Diff(DIFF_EQUAL, insertion.substring(0, overlap_length1))\n          );\n          diffs[pointer - 1][1] = deletion.substring(\n            0,\n            deletion.length - overlap_length1\n          );\n          diffs[pointer + 1][1] = insertion.substring(overlap_length1);\n          pointer++;\n        }\n      } else {\n        if (\n          overlap_length2 >= deletion.length / 2 ||\n          overlap_length2 >= insertion.length / 2\n        ) {\n          // Reverse overlap found.\n          // Insert an equality and swap and trim the surrounding edits.\n          diffs.splice(\n            pointer,\n            0,\n            new Diff(DIFF_EQUAL, deletion.substring(0, overlap_length2))\n          );\n          diffs[pointer - 1][0] = DIFF_INSERT;\n          diffs[pointer - 1][1] = insertion.substring(\n            0,\n            insertion.length - overlap_length2\n          );\n          diffs[pointer + 1][0] = DIFF_DELETE;\n          diffs[pointer + 1][1] = deletion.substring(overlap_length2);\n          pointer++;\n        }\n      }\n      pointer++;\n    }\n    pointer++;\n  }\n};\n\n/**\n * Look for single edits surrounded on both sides by equalities\n * which can be shifted sideways to align the edit to a word boundary.\n * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\nexports.cleanupSemantic = diff_cleanupSemantic;\nvar diff_cleanupSemanticLossless = function (diffs) {\n  /**\n   * Given two strings, compute a score representing whether the internal\n   * boundary falls on logical boundaries.\n   * Scores range from 6 (best) to 0 (worst).\n   * Closure, but does not reference any external variables.\n   * @param {string} one First string.\n   * @param {string} two Second string.\n   * @return {number} The score.\n   * @private\n   */\n  function diff_cleanupSemanticScore_(one, two) {\n    if (!one || !two) {\n      // Edges are the best.\n      return 6;\n    }\n\n    // Each port of this function behaves slightly differently due to\n    // subtle differences in each language's definition of things like\n    // 'whitespace'.  Since this function's purpose is largely cosmetic,\n    // the choice has been made to use each language's native features\n    // rather than force total conformity.\n    var char1 = one.charAt(one.length - 1);\n    var char2 = two.charAt(0);\n    var nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex_);\n    var nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex_);\n    var whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex_);\n    var whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex_);\n    var lineBreak1 = whitespace1 && char1.match(linebreakRegex_);\n    var lineBreak2 = whitespace2 && char2.match(linebreakRegex_);\n    var blankLine1 = lineBreak1 && one.match(blanklineEndRegex_);\n    var blankLine2 = lineBreak2 && two.match(blanklineStartRegex_);\n    if (blankLine1 || blankLine2) {\n      // Five points for blank lines.\n      return 5;\n    } else if (lineBreak1 || lineBreak2) {\n      // Four points for line breaks.\n      return 4;\n    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {\n      // Three points for end of sentences.\n      return 3;\n    } else if (whitespace1 || whitespace2) {\n      // Two points for whitespace.\n      return 2;\n    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {\n      // One point for non-alphanumeric.\n      return 1;\n    }\n    return 0;\n  }\n  var pointer = 1;\n  // Intentionally ignore the first and last element (don't need checking).\n  while (pointer < diffs.length - 1) {\n    if (\n      diffs[pointer - 1][0] == DIFF_EQUAL &&\n      diffs[pointer + 1][0] == DIFF_EQUAL\n    ) {\n      // This is a single edit surrounded by equalities.\n      var equality1 = diffs[pointer - 1][1];\n      var edit = diffs[pointer][1];\n      var equality2 = diffs[pointer + 1][1];\n\n      // First, shift the edit as far left as possible.\n      var commonOffset = diff_commonSuffix(equality1, edit);\n      if (commonOffset) {\n        var commonString = edit.substring(edit.length - commonOffset);\n        equality1 = equality1.substring(0, equality1.length - commonOffset);\n        edit = commonString + edit.substring(0, edit.length - commonOffset);\n        equality2 = commonString + equality2;\n      }\n\n      // Second, step character by character right, looking for the best fit.\n      var bestEquality1 = equality1;\n      var bestEdit = edit;\n      var bestEquality2 = equality2;\n      var bestScore =\n        diff_cleanupSemanticScore_(equality1, edit) +\n        diff_cleanupSemanticScore_(edit, equality2);\n      while (edit.charAt(0) === equality2.charAt(0)) {\n        equality1 += edit.charAt(0);\n        edit = edit.substring(1) + equality2.charAt(0);\n        equality2 = equality2.substring(1);\n        var score =\n          diff_cleanupSemanticScore_(equality1, edit) +\n          diff_cleanupSemanticScore_(edit, equality2);\n        // The >= encourages trailing rather than leading whitespace on edits.\n        if (score >= bestScore) {\n          bestScore = score;\n          bestEquality1 = equality1;\n          bestEdit = edit;\n          bestEquality2 = equality2;\n        }\n      }\n      if (diffs[pointer - 1][1] != bestEquality1) {\n        // We have an improvement, save it back to the diff.\n        if (bestEquality1) {\n          diffs[pointer - 1][1] = bestEquality1;\n        } else {\n          diffs.splice(pointer - 1, 1);\n          pointer--;\n        }\n        diffs[pointer][1] = bestEdit;\n        if (bestEquality2) {\n          diffs[pointer + 1][1] = bestEquality2;\n        } else {\n          diffs.splice(pointer + 1, 1);\n          pointer--;\n        }\n      }\n    }\n    pointer++;\n  }\n};\n\n// Define some regex patterns for matching boundaries.\nvar nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;\nvar whitespaceRegex_ = /\\s/;\nvar linebreakRegex_ = /[\\r\\n]/;\nvar blanklineEndRegex_ = /\\n\\r?\\n$/;\nvar blanklineStartRegex_ = /^\\r?\\n\\r?\\n/;\n\n/**\n * Reorder and merge like edit sections.  Merge equalities.\n * Any edit section can move as long as it doesn't cross an equality.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\nvar diff_cleanupMerge = function (diffs) {\n  // Add a dummy entry at the end.\n  diffs.push(new Diff(DIFF_EQUAL, ''));\n  var pointer = 0;\n  var count_delete = 0;\n  var count_insert = 0;\n  var text_delete = '';\n  var text_insert = '';\n  var commonlength;\n  while (pointer < diffs.length) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        count_insert++;\n        text_insert += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_DELETE:\n        count_delete++;\n        text_delete += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_EQUAL:\n        // Upon reaching an equality, check for prior redundancies.\n        if (count_delete + count_insert > 1) {\n          if (count_delete !== 0 && count_insert !== 0) {\n            // Factor out any common prefixies.\n            commonlength = diff_commonPrefix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              if (\n                pointer - count_delete - count_insert > 0 &&\n                diffs[pointer - count_delete - count_insert - 1][0] ==\n                  DIFF_EQUAL\n              ) {\n                diffs[pointer - count_delete - count_insert - 1][1] +=\n                  text_insert.substring(0, commonlength);\n              } else {\n                diffs.splice(\n                  0,\n                  0,\n                  new Diff(DIFF_EQUAL, text_insert.substring(0, commonlength))\n                );\n                pointer++;\n              }\n              text_insert = text_insert.substring(commonlength);\n              text_delete = text_delete.substring(commonlength);\n            }\n            // Factor out any common suffixies.\n            commonlength = diff_commonSuffix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              diffs[pointer][1] =\n                text_insert.substring(text_insert.length - commonlength) +\n                diffs[pointer][1];\n              text_insert = text_insert.substring(\n                0,\n                text_insert.length - commonlength\n              );\n              text_delete = text_delete.substring(\n                0,\n                text_delete.length - commonlength\n              );\n            }\n          }\n          // Delete the offending records and add the merged ones.\n          pointer -= count_delete + count_insert;\n          diffs.splice(pointer, count_delete + count_insert);\n          if (text_delete.length) {\n            diffs.splice(pointer, 0, new Diff(DIFF_DELETE, text_delete));\n            pointer++;\n          }\n          if (text_insert.length) {\n            diffs.splice(pointer, 0, new Diff(DIFF_INSERT, text_insert));\n            pointer++;\n          }\n          pointer++;\n        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {\n          // Merge this equality with the previous one.\n          diffs[pointer - 1][1] += diffs[pointer][1];\n          diffs.splice(pointer, 1);\n        } else {\n          pointer++;\n        }\n        count_insert = 0;\n        count_delete = 0;\n        text_delete = '';\n        text_insert = '';\n        break;\n    }\n  }\n  if (diffs[diffs.length - 1][1] === '') {\n    diffs.pop(); // Remove the dummy entry at the end.\n  }\n\n  // Second pass: look for single edits surrounded on both sides by equalities\n  // which can be shifted sideways to eliminate an equality.\n  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n  var changes = false;\n  pointer = 1;\n  // Intentionally ignore the first and last element (don't need checking).\n  while (pointer < diffs.length - 1) {\n    if (\n      diffs[pointer - 1][0] == DIFF_EQUAL &&\n      diffs[pointer + 1][0] == DIFF_EQUAL\n    ) {\n      // This is a single edit surrounded by equalities.\n      if (\n        diffs[pointer][1].substring(\n          diffs[pointer][1].length - diffs[pointer - 1][1].length\n        ) == diffs[pointer - 1][1]\n      ) {\n        // Shift the edit over the previous equality.\n        diffs[pointer][1] =\n          diffs[pointer - 1][1] +\n          diffs[pointer][1].substring(\n            0,\n            diffs[pointer][1].length - diffs[pointer - 1][1].length\n          );\n        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\n        diffs.splice(pointer - 1, 1);\n        changes = true;\n      } else if (\n        diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==\n        diffs[pointer + 1][1]\n      ) {\n        // Shift the edit over the next equality.\n        diffs[pointer - 1][1] += diffs[pointer + 1][1];\n        diffs[pointer][1] =\n          diffs[pointer][1].substring(diffs[pointer + 1][1].length) +\n          diffs[pointer + 1][1];\n        diffs.splice(pointer + 1, 1);\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n  // If shifts were made, the diff needs reordering and another shift sweep.\n  if (changes) {\n    diff_cleanupMerge(diffs);\n  }\n};\n"],"version":3}