{"file":"D:\\Projects\\CardEverything\\cardall-prototype\\node_modules\\diff-sequences\\build\\index.js","mappings":"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","names":[],"sources":["D:\\Projects\\CardEverything\\cardall-prototype\\node_modules\\diff-sequences\\build\\index.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = diffSequence;\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// This diff-sequences package implements the linear space variation in\n// An O(ND) Difference Algorithm and Its Variations by Eugene W. Myers\n\n// Relationship in notation between Myers paper and this package:\n// A is a\n// N is aLength, aEnd - aStart, and so on\n// x is aIndex, aFirst, aLast, and so on\n// B is b\n// M is bLength, bEnd - bStart, and so on\n// y is bIndex, bFirst, bLast, and so on\n// Δ = N - M is negative of baDeltaLength = bLength - aLength\n// D is d\n// k is kF\n// k + Δ is kF = kR - baDeltaLength\n// V is aIndexesF or aIndexesR (see comment below about Indexes type)\n// index intervals [1, N] and [1, M] are [0, aLength) and [0, bLength)\n// starting point in forward direction (0, 0) is (-1, -1)\n// starting point in reverse direction (N + 1, M + 1) is (aLength, bLength)\n\n// The “edit graph” for sequences a and b corresponds to items:\n// in a on the horizontal axis\n// in b on the vertical axis\n//\n// Given a-coordinate of a point in a diagonal, you can compute b-coordinate.\n//\n// Forward diagonals kF:\n// zero diagonal intersects top left corner\n// positive diagonals intersect top edge\n// negative diagonals insersect left edge\n//\n// Reverse diagonals kR:\n// zero diagonal intersects bottom right corner\n// positive diagonals intersect right edge\n// negative diagonals intersect bottom edge\n\n// The graph contains a directed acyclic graph of edges:\n// horizontal: delete an item from a\n// vertical: insert an item from b\n// diagonal: common item in a and b\n//\n// The algorithm solves dual problems in the graph analogy:\n// Find longest common subsequence: path with maximum number of diagonal edges\n// Find shortest edit script: path with minimum number of non-diagonal edges\n\n// Input callback function compares items at indexes in the sequences.\n\n// Output callback function receives the number of adjacent items\n// and starting indexes of each common subsequence.\n// Either original functions or wrapped to swap indexes if graph is transposed.\n// Indexes in sequence a of last point of forward or reverse paths in graph.\n// Myers algorithm indexes by diagonal k which for negative is bad deopt in V8.\n// This package indexes by iF and iR which are greater than or equal to zero.\n// and also updates the index arrays in place to cut memory in half.\n// kF = 2 * iF - d\n// kR = d - 2 * iR\n// Division of index intervals in sequences a and b at the middle change.\n// Invariant: intervals do not have common items at the start or end.\nconst pkg = 'diff-sequences'; // for error messages\nconst NOT_YET_SET = 0; // small int instead of undefined to avoid deopt in V8\n\n// Return the number of common items that follow in forward direction.\n// The length of what Myers paper calls a “snake” in a forward path.\nconst countCommonItemsF = (aIndex, aEnd, bIndex, bEnd, isCommon) => {\n  let nCommon = 0;\n  while (aIndex < aEnd && bIndex < bEnd && isCommon(aIndex, bIndex)) {\n    aIndex += 1;\n    bIndex += 1;\n    nCommon += 1;\n  }\n  return nCommon;\n};\n\n// Return the number of common items that precede in reverse direction.\n// The length of what Myers paper calls a “snake” in a reverse path.\nconst countCommonItemsR = (aStart, aIndex, bStart, bIndex, isCommon) => {\n  let nCommon = 0;\n  while (aStart <= aIndex && bStart <= bIndex && isCommon(aIndex, bIndex)) {\n    aIndex -= 1;\n    bIndex -= 1;\n    nCommon += 1;\n  }\n  return nCommon;\n};\n\n// A simple function to extend forward paths from (d - 1) to d changes\n// when forward and reverse paths cannot yet overlap.\nconst extendPathsF = (\n  d,\n  aEnd,\n  bEnd,\n  bF,\n  isCommon,\n  aIndexesF,\n  iMaxF // return the value because optimization might decrease it\n) => {\n  // Unroll the first iteration.\n  let iF = 0;\n  let kF = -d; // kF = 2 * iF - d\n  let aFirst = aIndexesF[iF]; // in first iteration always insert\n  let aIndexPrev1 = aFirst; // prev value of [iF - 1] in next iteration\n  aIndexesF[iF] += countCommonItemsF(\n    aFirst + 1,\n    aEnd,\n    bF + aFirst - kF + 1,\n    bEnd,\n    isCommon\n  );\n\n  // Optimization: skip diagonals in which paths cannot ever overlap.\n  const nF = d < iMaxF ? d : iMaxF;\n\n  // The diagonals kF are odd when d is odd and even when d is even.\n  for (iF += 1, kF += 2; iF <= nF; iF += 1, kF += 2) {\n    // To get first point of path segment, move one change in forward direction\n    // from last point of previous path segment in an adjacent diagonal.\n    // In last possible iteration when iF === d and kF === d always delete.\n    if (iF !== d && aIndexPrev1 < aIndexesF[iF]) {\n      aFirst = aIndexesF[iF]; // vertical to insert from b\n    } else {\n      aFirst = aIndexPrev1 + 1; // horizontal to delete from a\n\n      if (aEnd <= aFirst) {\n        // Optimization: delete moved past right of graph.\n        return iF - 1;\n      }\n    }\n\n    // To get last point of path segment, move along diagonal of common items.\n    aIndexPrev1 = aIndexesF[iF];\n    aIndexesF[iF] =\n      aFirst +\n      countCommonItemsF(aFirst + 1, aEnd, bF + aFirst - kF + 1, bEnd, isCommon);\n  }\n  return iMaxF;\n};\n\n// A simple function to extend reverse paths from (d - 1) to d changes\n// when reverse and forward paths cannot yet overlap.\nconst extendPathsR = (\n  d,\n  aStart,\n  bStart,\n  bR,\n  isCommon,\n  aIndexesR,\n  iMaxR // return the value because optimization might decrease it\n) => {\n  // Unroll the first iteration.\n  let iR = 0;\n  let kR = d; // kR = d - 2 * iR\n  let aFirst = aIndexesR[iR]; // in first iteration always insert\n  let aIndexPrev1 = aFirst; // prev value of [iR - 1] in next iteration\n  aIndexesR[iR] -= countCommonItemsR(\n    aStart,\n    aFirst - 1,\n    bStart,\n    bR + aFirst - kR - 1,\n    isCommon\n  );\n\n  // Optimization: skip diagonals in which paths cannot ever overlap.\n  const nR = d < iMaxR ? d : iMaxR;\n\n  // The diagonals kR are odd when d is odd and even when d is even.\n  for (iR += 1, kR -= 2; iR <= nR; iR += 1, kR -= 2) {\n    // To get first point of path segment, move one change in reverse direction\n    // from last point of previous path segment in an adjacent diagonal.\n    // In last possible iteration when iR === d and kR === -d always delete.\n    if (iR !== d && aIndexesR[iR] < aIndexPrev1) {\n      aFirst = aIndexesR[iR]; // vertical to insert from b\n    } else {\n      aFirst = aIndexPrev1 - 1; // horizontal to delete from a\n\n      if (aFirst < aStart) {\n        // Optimization: delete moved past left of graph.\n        return iR - 1;\n      }\n    }\n\n    // To get last point of path segment, move along diagonal of common items.\n    aIndexPrev1 = aIndexesR[iR];\n    aIndexesR[iR] =\n      aFirst -\n      countCommonItemsR(\n        aStart,\n        aFirst - 1,\n        bStart,\n        bR + aFirst - kR - 1,\n        isCommon\n      );\n  }\n  return iMaxR;\n};\n\n// A complete function to extend forward paths from (d - 1) to d changes.\n// Return true if a path overlaps reverse path of (d - 1) changes in its diagonal.\nconst extendOverlappablePathsF = (\n  d,\n  aStart,\n  aEnd,\n  bStart,\n  bEnd,\n  isCommon,\n  aIndexesF,\n  iMaxF,\n  aIndexesR,\n  iMaxR,\n  division // update prop values if return true\n) => {\n  const bF = bStart - aStart; // bIndex = bF + aIndex - kF\n  const aLength = aEnd - aStart;\n  const bLength = bEnd - bStart;\n  const baDeltaLength = bLength - aLength; // kF = kR - baDeltaLength\n\n  // Range of diagonals in which forward and reverse paths might overlap.\n  const kMinOverlapF = -baDeltaLength - (d - 1); // -(d - 1) <= kR\n  const kMaxOverlapF = -baDeltaLength + (d - 1); // kR <= (d - 1)\n\n  let aIndexPrev1 = NOT_YET_SET; // prev value of [iF - 1] in next iteration\n\n  // Optimization: skip diagonals in which paths cannot ever overlap.\n  const nF = d < iMaxF ? d : iMaxF;\n\n  // The diagonals kF = 2 * iF - d are odd when d is odd and even when d is even.\n  for (let iF = 0, kF = -d; iF <= nF; iF += 1, kF += 2) {\n    // To get first point of path segment, move one change in forward direction\n    // from last point of previous path segment in an adjacent diagonal.\n    // In first iteration when iF === 0 and kF === -d always insert.\n    // In last possible iteration when iF === d and kF === d always delete.\n    const insert = iF === 0 || (iF !== d && aIndexPrev1 < aIndexesF[iF]);\n    const aLastPrev = insert ? aIndexesF[iF] : aIndexPrev1;\n    const aFirst = insert\n      ? aLastPrev // vertical to insert from b\n      : aLastPrev + 1; // horizontal to delete from a\n\n    // To get last point of path segment, move along diagonal of common items.\n    const bFirst = bF + aFirst - kF;\n    const nCommonF = countCommonItemsF(\n      aFirst + 1,\n      aEnd,\n      bFirst + 1,\n      bEnd,\n      isCommon\n    );\n    const aLast = aFirst + nCommonF;\n    aIndexPrev1 = aIndexesF[iF];\n    aIndexesF[iF] = aLast;\n    if (kMinOverlapF <= kF && kF <= kMaxOverlapF) {\n      // Solve for iR of reverse path with (d - 1) changes in diagonal kF:\n      // kR = kF + baDeltaLength\n      // kR = (d - 1) - 2 * iR\n      const iR = (d - 1 - (kF + baDeltaLength)) / 2;\n\n      // If this forward path overlaps the reverse path in this diagonal,\n      // then this is the middle change of the index intervals.\n      if (iR <= iMaxR && aIndexesR[iR] - 1 <= aLast) {\n        // Unlike the Myers algorithm which finds only the middle “snake”\n        // this package can find two common subsequences per division.\n        // Last point of previous path segment is on an adjacent diagonal.\n        const bLastPrev = bF + aLastPrev - (insert ? kF + 1 : kF - 1);\n\n        // Because of invariant that intervals preceding the middle change\n        // cannot have common items at the end,\n        // move in reverse direction along a diagonal of common items.\n        const nCommonR = countCommonItemsR(\n          aStart,\n          aLastPrev,\n          bStart,\n          bLastPrev,\n          isCommon\n        );\n        const aIndexPrevFirst = aLastPrev - nCommonR;\n        const bIndexPrevFirst = bLastPrev - nCommonR;\n        const aEndPreceding = aIndexPrevFirst + 1;\n        const bEndPreceding = bIndexPrevFirst + 1;\n        division.nChangePreceding = d - 1;\n        if (d - 1 === aEndPreceding + bEndPreceding - aStart - bStart) {\n          // Optimization: number of preceding changes in forward direction\n          // is equal to number of items in preceding interval,\n          // therefore it cannot contain any common items.\n          division.aEndPreceding = aStart;\n          division.bEndPreceding = bStart;\n        } else {\n          division.aEndPreceding = aEndPreceding;\n          division.bEndPreceding = bEndPreceding;\n        }\n        division.nCommonPreceding = nCommonR;\n        if (nCommonR !== 0) {\n          division.aCommonPreceding = aEndPreceding;\n          division.bCommonPreceding = bEndPreceding;\n        }\n        division.nCommonFollowing = nCommonF;\n        if (nCommonF !== 0) {\n          division.aCommonFollowing = aFirst + 1;\n          division.bCommonFollowing = bFirst + 1;\n        }\n        const aStartFollowing = aLast + 1;\n        const bStartFollowing = bFirst + nCommonF + 1;\n        division.nChangeFollowing = d - 1;\n        if (d - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing) {\n          // Optimization: number of changes in reverse direction\n          // is equal to number of items in following interval,\n          // therefore it cannot contain any common items.\n          division.aStartFollowing = aEnd;\n          division.bStartFollowing = bEnd;\n        } else {\n          division.aStartFollowing = aStartFollowing;\n          division.bStartFollowing = bStartFollowing;\n        }\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n// A complete function to extend reverse paths from (d - 1) to d changes.\n// Return true if a path overlaps forward path of d changes in its diagonal.\nconst extendOverlappablePathsR = (\n  d,\n  aStart,\n  aEnd,\n  bStart,\n  bEnd,\n  isCommon,\n  aIndexesF,\n  iMaxF,\n  aIndexesR,\n  iMaxR,\n  division // update prop values if return true\n) => {\n  const bR = bEnd - aEnd; // bIndex = bR + aIndex - kR\n  const aLength = aEnd - aStart;\n  const bLength = bEnd - bStart;\n  const baDeltaLength = bLength - aLength; // kR = kF + baDeltaLength\n\n  // Range of diagonals in which forward and reverse paths might overlap.\n  const kMinOverlapR = baDeltaLength - d; // -d <= kF\n  const kMaxOverlapR = baDeltaLength + d; // kF <= d\n\n  let aIndexPrev1 = NOT_YET_SET; // prev value of [iR - 1] in next iteration\n\n  // Optimization: skip diagonals in which paths cannot ever overlap.\n  const nR = d < iMaxR ? d : iMaxR;\n\n  // The diagonals kR = d - 2 * iR are odd when d is odd and even when d is even.\n  for (let iR = 0, kR = d; iR <= nR; iR += 1, kR -= 2) {\n    // To get first point of path segment, move one change in reverse direction\n    // from last point of previous path segment in an adjacent diagonal.\n    // In first iteration when iR === 0 and kR === d always insert.\n    // In last possible iteration when iR === d and kR === -d always delete.\n    const insert = iR === 0 || (iR !== d && aIndexesR[iR] < aIndexPrev1);\n    const aLastPrev = insert ? aIndexesR[iR] : aIndexPrev1;\n    const aFirst = insert\n      ? aLastPrev // vertical to insert from b\n      : aLastPrev - 1; // horizontal to delete from a\n\n    // To get last point of path segment, move along diagonal of common items.\n    const bFirst = bR + aFirst - kR;\n    const nCommonR = countCommonItemsR(\n      aStart,\n      aFirst - 1,\n      bStart,\n      bFirst - 1,\n      isCommon\n    );\n    const aLast = aFirst - nCommonR;\n    aIndexPrev1 = aIndexesR[iR];\n    aIndexesR[iR] = aLast;\n    if (kMinOverlapR <= kR && kR <= kMaxOverlapR) {\n      // Solve for iF of forward path with d changes in diagonal kR:\n      // kF = kR - baDeltaLength\n      // kF = 2 * iF - d\n      const iF = (d + (kR - baDeltaLength)) / 2;\n\n      // If this reverse path overlaps the forward path in this diagonal,\n      // then this is a middle change of the index intervals.\n      if (iF <= iMaxF && aLast - 1 <= aIndexesF[iF]) {\n        const bLast = bFirst - nCommonR;\n        division.nChangePreceding = d;\n        if (d === aLast + bLast - aStart - bStart) {\n          // Optimization: number of changes in reverse direction\n          // is equal to number of items in preceding interval,\n          // therefore it cannot contain any common items.\n          division.aEndPreceding = aStart;\n          division.bEndPreceding = bStart;\n        } else {\n          division.aEndPreceding = aLast;\n          division.bEndPreceding = bLast;\n        }\n        division.nCommonPreceding = nCommonR;\n        if (nCommonR !== 0) {\n          // The last point of reverse path segment is start of common subsequence.\n          division.aCommonPreceding = aLast;\n          division.bCommonPreceding = bLast;\n        }\n        division.nChangeFollowing = d - 1;\n        if (d === 1) {\n          // There is no previous path segment.\n          division.nCommonFollowing = 0;\n          division.aStartFollowing = aEnd;\n          division.bStartFollowing = bEnd;\n        } else {\n          // Unlike the Myers algorithm which finds only the middle “snake”\n          // this package can find two common subsequences per division.\n          // Last point of previous path segment is on an adjacent diagonal.\n          const bLastPrev = bR + aLastPrev - (insert ? kR - 1 : kR + 1);\n\n          // Because of invariant that intervals following the middle change\n          // cannot have common items at the start,\n          // move in forward direction along a diagonal of common items.\n          const nCommonF = countCommonItemsF(\n            aLastPrev,\n            aEnd,\n            bLastPrev,\n            bEnd,\n            isCommon\n          );\n          division.nCommonFollowing = nCommonF;\n          if (nCommonF !== 0) {\n            // The last point of reverse path segment is start of common subsequence.\n            division.aCommonFollowing = aLastPrev;\n            division.bCommonFollowing = bLastPrev;\n          }\n          const aStartFollowing = aLastPrev + nCommonF; // aFirstPrev\n          const bStartFollowing = bLastPrev + nCommonF; // bFirstPrev\n\n          if (d - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing) {\n            // Optimization: number of changes in forward direction\n            // is equal to number of items in following interval,\n            // therefore it cannot contain any common items.\n            division.aStartFollowing = aEnd;\n            division.bStartFollowing = bEnd;\n          } else {\n            division.aStartFollowing = aStartFollowing;\n            division.bStartFollowing = bStartFollowing;\n          }\n        }\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n// Given index intervals and input function to compare items at indexes,\n// divide at the middle change.\n//\n// DO NOT CALL if start === end, because interval cannot contain common items\n// and because this function will throw the “no overlap” error.\nconst divide = (\n  nChange,\n  aStart,\n  aEnd,\n  bStart,\n  bEnd,\n  isCommon,\n  aIndexesF,\n  aIndexesR,\n  division // output\n) => {\n  const bF = bStart - aStart; // bIndex = bF + aIndex - kF\n  const bR = bEnd - aEnd; // bIndex = bR + aIndex - kR\n  const aLength = aEnd - aStart;\n  const bLength = bEnd - bStart;\n\n  // Because graph has square or portrait orientation,\n  // length difference is minimum number of items to insert from b.\n  // Corresponding forward and reverse diagonals in graph\n  // depend on length difference of the sequences:\n  // kF = kR - baDeltaLength\n  // kR = kF + baDeltaLength\n  const baDeltaLength = bLength - aLength;\n\n  // Optimization: max diagonal in graph intersects corner of shorter side.\n  let iMaxF = aLength;\n  let iMaxR = aLength;\n\n  // Initialize no changes yet in forward or reverse direction:\n  aIndexesF[0] = aStart - 1; // at open start of interval, outside closed start\n  aIndexesR[0] = aEnd; // at open end of interval\n\n  if (baDeltaLength % 2 === 0) {\n    // The number of changes in paths is 2 * d if length difference is even.\n    const dMin = (nChange || baDeltaLength) / 2;\n    const dMax = (aLength + bLength) / 2;\n    for (let d = 1; d <= dMax; d += 1) {\n      iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);\n      if (d < dMin) {\n        iMaxR = extendPathsR(d, aStart, bStart, bR, isCommon, aIndexesR, iMaxR);\n      } else if (\n        // If a reverse path overlaps a forward path in the same diagonal,\n        // return a division of the index intervals at the middle change.\n        extendOverlappablePathsR(\n          d,\n          aStart,\n          aEnd,\n          bStart,\n          bEnd,\n          isCommon,\n          aIndexesF,\n          iMaxF,\n          aIndexesR,\n          iMaxR,\n          division\n        )\n      ) {\n        return;\n      }\n    }\n  } else {\n    // The number of changes in paths is 2 * d - 1 if length difference is odd.\n    const dMin = ((nChange || baDeltaLength) + 1) / 2;\n    const dMax = (aLength + bLength + 1) / 2;\n\n    // Unroll first half iteration so loop extends the relevant pairs of paths.\n    // Because of invariant that intervals have no common items at start or end,\n    // and limitation not to call divide with empty intervals,\n    // therefore it cannot be called if a forward path with one change\n    // would overlap a reverse path with no changes, even if dMin === 1.\n    let d = 1;\n    iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);\n    for (d += 1; d <= dMax; d += 1) {\n      iMaxR = extendPathsR(\n        d - 1,\n        aStart,\n        bStart,\n        bR,\n        isCommon,\n        aIndexesR,\n        iMaxR\n      );\n      if (d < dMin) {\n        iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);\n      } else if (\n        // If a forward path overlaps a reverse path in the same diagonal,\n        // return a division of the index intervals at the middle change.\n        extendOverlappablePathsF(\n          d,\n          aStart,\n          aEnd,\n          bStart,\n          bEnd,\n          isCommon,\n          aIndexesF,\n          iMaxF,\n          aIndexesR,\n          iMaxR,\n          division\n        )\n      ) {\n        return;\n      }\n    }\n  }\n\n  /* istanbul ignore next */\n  throw new Error(\n    `${pkg}: no overlap aStart=${aStart} aEnd=${aEnd} bStart=${bStart} bEnd=${bEnd}`\n  );\n};\n\n// Given index intervals and input function to compare items at indexes,\n// return by output function the number of adjacent items and starting indexes\n// of each common subsequence. Divide and conquer with only linear space.\n//\n// The index intervals are half open [start, end) like array slice method.\n// DO NOT CALL if start === end, because interval cannot contain common items\n// and because divide function will throw the “no overlap” error.\nconst findSubsequences = (\n  nChange,\n  aStart,\n  aEnd,\n  bStart,\n  bEnd,\n  transposed,\n  callbacks,\n  aIndexesF,\n  aIndexesR,\n  division // temporary memory, not input nor output\n) => {\n  if (bEnd - bStart < aEnd - aStart) {\n    // Transpose graph so it has portrait instead of landscape orientation.\n    // Always compare shorter to longer sequence for consistency and optimization.\n    transposed = !transposed;\n    if (transposed && callbacks.length === 1) {\n      // Lazily wrap callback functions to swap args if graph is transposed.\n      const {foundSubsequence, isCommon} = callbacks[0];\n      callbacks[1] = {\n        foundSubsequence: (nCommon, bCommon, aCommon) => {\n          foundSubsequence(nCommon, aCommon, bCommon);\n        },\n        isCommon: (bIndex, aIndex) => isCommon(aIndex, bIndex)\n      };\n    }\n    const tStart = aStart;\n    const tEnd = aEnd;\n    aStart = bStart;\n    aEnd = bEnd;\n    bStart = tStart;\n    bEnd = tEnd;\n  }\n  const {foundSubsequence, isCommon} = callbacks[transposed ? 1 : 0];\n\n  // Divide the index intervals at the middle change.\n  divide(\n    nChange,\n    aStart,\n    aEnd,\n    bStart,\n    bEnd,\n    isCommon,\n    aIndexesF,\n    aIndexesR,\n    division\n  );\n  const {\n    nChangePreceding,\n    aEndPreceding,\n    bEndPreceding,\n    nCommonPreceding,\n    aCommonPreceding,\n    bCommonPreceding,\n    nCommonFollowing,\n    aCommonFollowing,\n    bCommonFollowing,\n    nChangeFollowing,\n    aStartFollowing,\n    bStartFollowing\n  } = division;\n\n  // Unless either index interval is empty, they might contain common items.\n  if (aStart < aEndPreceding && bStart < bEndPreceding) {\n    // Recursely find and return common subsequences preceding the division.\n    findSubsequences(\n      nChangePreceding,\n      aStart,\n      aEndPreceding,\n      bStart,\n      bEndPreceding,\n      transposed,\n      callbacks,\n      aIndexesF,\n      aIndexesR,\n      division\n    );\n  }\n\n  // Return common subsequences that are adjacent to the middle change.\n  if (nCommonPreceding !== 0) {\n    foundSubsequence(nCommonPreceding, aCommonPreceding, bCommonPreceding);\n  }\n  if (nCommonFollowing !== 0) {\n    foundSubsequence(nCommonFollowing, aCommonFollowing, bCommonFollowing);\n  }\n\n  // Unless either index interval is empty, they might contain common items.\n  if (aStartFollowing < aEnd && bStartFollowing < bEnd) {\n    // Recursely find and return common subsequences following the division.\n    findSubsequences(\n      nChangeFollowing,\n      aStartFollowing,\n      aEnd,\n      bStartFollowing,\n      bEnd,\n      transposed,\n      callbacks,\n      aIndexesF,\n      aIndexesR,\n      division\n    );\n  }\n};\nconst validateLength = (name, arg) => {\n  if (typeof arg !== 'number') {\n    throw new TypeError(`${pkg}: ${name} typeof ${typeof arg} is not a number`);\n  }\n  if (!Number.isSafeInteger(arg)) {\n    throw new RangeError(`${pkg}: ${name} value ${arg} is not a safe integer`);\n  }\n  if (arg < 0) {\n    throw new RangeError(`${pkg}: ${name} value ${arg} is a negative integer`);\n  }\n};\nconst validateCallback = (name, arg) => {\n  const type = typeof arg;\n  if (type !== 'function') {\n    throw new TypeError(`${pkg}: ${name} typeof ${type} is not a function`);\n  }\n};\n\n// Compare items in two sequences to find a longest common subsequence.\n// Given lengths of sequences and input function to compare items at indexes,\n// return by output function the number of adjacent items and starting indexes\n// of each common subsequence.\nfunction diffSequence(aLength, bLength, isCommon, foundSubsequence) {\n  validateLength('aLength', aLength);\n  validateLength('bLength', bLength);\n  validateCallback('isCommon', isCommon);\n  validateCallback('foundSubsequence', foundSubsequence);\n\n  // Count common items from the start in the forward direction.\n  const nCommonF = countCommonItemsF(0, aLength, 0, bLength, isCommon);\n  if (nCommonF !== 0) {\n    foundSubsequence(nCommonF, 0, 0);\n  }\n\n  // Unless both sequences consist of common items only,\n  // find common items in the half-trimmed index intervals.\n  if (aLength !== nCommonF || bLength !== nCommonF) {\n    // Invariant: intervals do not have common items at the start.\n    // The start of an index interval is closed like array slice method.\n    const aStart = nCommonF;\n    const bStart = nCommonF;\n\n    // Count common items from the end in the reverse direction.\n    const nCommonR = countCommonItemsR(\n      aStart,\n      aLength - 1,\n      bStart,\n      bLength - 1,\n      isCommon\n    );\n\n    // Invariant: intervals do not have common items at the end.\n    // The end of an index interval is open like array slice method.\n    const aEnd = aLength - nCommonR;\n    const bEnd = bLength - nCommonR;\n\n    // Unless one sequence consists of common items only,\n    // therefore the other trimmed index interval consists of changes only,\n    // find common items in the trimmed index intervals.\n    const nCommonFR = nCommonF + nCommonR;\n    if (aLength !== nCommonFR && bLength !== nCommonFR) {\n      const nChange = 0; // number of change items is not yet known\n      const transposed = false; // call the original unwrapped functions\n      const callbacks = [\n        {\n          foundSubsequence,\n          isCommon\n        }\n      ];\n\n      // Indexes in sequence a of last points in furthest reaching paths\n      // from outside the start at top left in the forward direction:\n      const aIndexesF = [NOT_YET_SET];\n      // from the end at bottom right in the reverse direction:\n      const aIndexesR = [NOT_YET_SET];\n\n      // Initialize one object as output of all calls to divide function.\n      const division = {\n        aCommonFollowing: NOT_YET_SET,\n        aCommonPreceding: NOT_YET_SET,\n        aEndPreceding: NOT_YET_SET,\n        aStartFollowing: NOT_YET_SET,\n        bCommonFollowing: NOT_YET_SET,\n        bCommonPreceding: NOT_YET_SET,\n        bEndPreceding: NOT_YET_SET,\n        bStartFollowing: NOT_YET_SET,\n        nChangeFollowing: NOT_YET_SET,\n        nChangePreceding: NOT_YET_SET,\n        nCommonFollowing: NOT_YET_SET,\n        nCommonPreceding: NOT_YET_SET\n      };\n\n      // Find and return common subsequences in the trimmed index intervals.\n      findSubsequences(\n        nChange,\n        aStart,\n        aEnd,\n        bStart,\n        bEnd,\n        transposed,\n        callbacks,\n        aIndexesF,\n        aIndexesR,\n        division\n      );\n    }\n    if (nCommonR !== 0) {\n      foundSubsequence(nCommonR, aEnd, bEnd);\n    }\n  }\n}\n"],"version":3}