{"file":"D:\\Projects\\CardEverything\\cardall-prototype\\node_modules\\react-dnd\\dist\\internals\\wrapConnectorHooks.js","mappings":"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","names":[],"sources":["D:\\Projects\\CardEverything\\cardall-prototype\\node_modules\\react-dnd\\dist\\internals\\wrapConnectorHooks.js"],"sourcesContent":["import { invariant } from '@react-dnd/invariant';\nimport { cloneElement, isValidElement } from 'react';\nfunction throwIfCompositeComponentElement(element) {\n    // Custom components can no longer be wrapped directly in React DnD 2.0\n    // so that we don't need to depend on findDOMNode() from react-dom.\n    if (typeof element.type === 'string') {\n        return;\n    }\n    const displayName = element.type.displayName || element.type.name || 'the component';\n    throw new Error('Only native element nodes can now be passed to React DnD connectors.' + `You can either wrap ${displayName} into a <div>, or turn it into a ` + 'drag source or a drop target itself.');\n}\nfunction wrapHookToRecognizeElement(hook) {\n    return (elementOrNode = null, options = null)=>{\n        // When passed a node, call the hook straight away.\n        if (!isValidElement(elementOrNode)) {\n            const node = elementOrNode;\n            hook(node, options);\n            // return the node so it can be chained (e.g. when within callback refs\n            // <div ref={node => connectDragSource(connectDropTarget(node))}/>\n            return node;\n        }\n        // If passed a ReactElement, clone it and attach this function as a ref.\n        // This helps us achieve a neat API where user doesn't even know that refs\n        // are being used under the hood.\n        const element = elementOrNode;\n        throwIfCompositeComponentElement(element);\n        // When no options are passed, use the hook directly\n        const ref = options ? (node)=>hook(node, options)\n         : hook;\n        return cloneWithRef(element, ref);\n    };\n}\nexport function wrapConnectorHooks(hooks) {\n    const wrappedHooks = {};\n    Object.keys(hooks).forEach((key)=>{\n        const hook = hooks[key];\n        // ref objects should be passed straight through without wrapping\n        if (key.endsWith('Ref')) {\n            wrappedHooks[key] = hooks[key];\n        } else {\n            const wrappedHook = wrapHookToRecognizeElement(hook);\n            wrappedHooks[key] = ()=>wrappedHook\n            ;\n        }\n    });\n    return wrappedHooks;\n}\nfunction setRef(ref, node) {\n    if (typeof ref === 'function') {\n        ref(node);\n    } else {\n        ref.current = node;\n    }\n}\nfunction cloneWithRef(element, newRef) {\n    const previousRef = element.ref;\n    invariant(typeof previousRef !== 'string', 'Cannot connect React DnD to an element with an existing string ref. ' + 'Please convert it to use a callback ref instead, or wrap it into a <span> or <div>. ' + 'Read more: https://reactjs.org/docs/refs-and-the-dom.html#callback-refs');\n    if (!previousRef) {\n        // When there is no ref on the element, use the new ref directly\n        return cloneElement(element, {\n            ref: newRef\n        });\n    } else {\n        return cloneElement(element, {\n            ref: (node)=>{\n                setRef(previousRef, node);\n                setRef(newRef, node);\n            }\n        });\n    }\n}\n\n//# sourceMappingURL=wrapConnectorHooks.js.map"],"version":3}