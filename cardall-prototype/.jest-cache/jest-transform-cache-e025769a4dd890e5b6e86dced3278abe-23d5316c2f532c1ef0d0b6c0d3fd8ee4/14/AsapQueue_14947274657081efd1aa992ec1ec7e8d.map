{"file":"D:\\Projects\\CardEverything\\cardall-prototype\\node_modules\\@react-dnd\\asap\\dist\\AsapQueue.js","mappings":"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","names":[],"sources":["D:\\Projects\\CardEverything\\cardall-prototype\\node_modules\\@react-dnd\\asap\\dist\\AsapQueue.js"],"sourcesContent":["/* eslint-disable no-restricted-globals, @typescript-eslint/ban-ts-comment, @typescript-eslint/no-unused-vars, @typescript-eslint/no-non-null-assertion */ import { makeRequestCall, makeRequestCallFromTimer } from './makeRequestCall.js';\nexport class AsapQueue {\n    // Use the fastest means possible to execute a task in its own turn, with\n    // priority over other events including IO, animation, reflow, and redraw\n    // events in browsers.\n    //\n    // An exception thrown by a task will permanently interrupt the processing of\n    // subsequent tasks. The higher level `asap` function ensures that if an\n    // exception is thrown by a task, that the task queue will continue flushing as\n    // soon as possible, but if you use `rawAsap` directly, you are responsible to\n    // either ensure that no exceptions are thrown from your task, or to manually\n    // call `rawAsap.requestFlush` if an exception is thrown.\n    enqueueTask(task) {\n        const { queue: q , requestFlush  } = this;\n        if (!q.length) {\n            requestFlush();\n            this.flushing = true;\n        }\n        // Equivalent to push, but avoids a function call.\n        q[q.length] = task;\n    }\n    constructor(){\n        this.queue = [];\n        // We queue errors to ensure they are thrown in right order (FIFO).\n        // Array-as-queue is good enough here, since we are just dealing with exceptions.\n        this.pendingErrors = [];\n        // Once a flush has been requested, no further calls to `requestFlush` are\n        // necessary until the next `flush` completes.\n        // @ts-ignore\n        this.flushing = false;\n        // The position of the next task to execute in the task queue. This is\n        // preserved between calls to `flush` so that it can be resumed if\n        // a task throws an exception.\n        this.index = 0;\n        // If a task schedules additional tasks recursively, the task queue can grow\n        // unbounded. To prevent memory exhaustion, the task queue will periodically\n        // truncate already-completed tasks.\n        this.capacity = 1024;\n        // The flush function processes all tasks that have been scheduled with\n        // `rawAsap` unless and until one of those tasks throws an exception.\n        // If a task throws an exception, `flush` ensures that its state will remain\n        // consistent and will resume where it left off when called again.\n        // However, `flush` does not make any arrangements to be called again if an\n        // exception is thrown.\n        this.flush = ()=>{\n            const { queue: q  } = this;\n            while(this.index < q.length){\n                const currentIndex = this.index;\n                // Advance the index before calling the task. This ensures that we will\n                // begin flushing on the next task the task throws an error.\n                this.index++;\n                q[currentIndex].call();\n                // Prevent leaking memory for long chains of recursive calls to `asap`.\n                // If we call `asap` within tasks scheduled by `asap`, the queue will\n                // grow, but to avoid an O(n) walk for every task we execute, we don't\n                // shift tasks off the queue after they have been executed.\n                // Instead, we periodically shift 1024 tasks off the queue.\n                if (this.index > this.capacity) {\n                    // Manually shift all values starting at the index back to the\n                    // beginning of the queue.\n                    for(let scan = 0, newLength = q.length - this.index; scan < newLength; scan++){\n                        q[scan] = q[scan + this.index];\n                    }\n                    q.length -= this.index;\n                    this.index = 0;\n                }\n            }\n            q.length = 0;\n            this.index = 0;\n            this.flushing = false;\n        };\n        // In a web browser, exceptions are not fatal. However, to avoid\n        // slowing down the queue of pending tasks, we rethrow the error in a\n        // lower priority turn.\n        this.registerPendingError = (err)=>{\n            this.pendingErrors.push(err);\n            this.requestErrorThrow();\n        };\n        // `requestFlush` requests that the high priority event queue be flushed as\n        // soon as possible.\n        // This is useful to prevent an error thrown in a task from stalling the event\n        // queue if the exception handled by Node.jsâ€™s\n        // `process.on(\"uncaughtException\")` or by a domain.\n        // `requestFlush` is implemented using a strategy based on data collected from\n        // every available SauceLabs Selenium web driver worker at time of writing.\n        // https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593\n        this.requestFlush = makeRequestCall(this.flush);\n        this.requestErrorThrow = makeRequestCallFromTimer(()=>{\n            // Throw first error\n            if (this.pendingErrors.length) {\n                throw this.pendingErrors.shift();\n            }\n        });\n    }\n} // The message channel technique was discovered by Malte Ubl and was the\n // original foundation for this library.\n // http://www.nonblocking.io/2011/06/windownexttick.html\n // Safari 6.0.5 (at least) intermittently fails to create message ports on a\n // page's first load. Thankfully, this version of Safari supports\n // MutationObservers, so we don't need to fall back in that case.\n // function makeRequestCallFromMessageChannel(callback) {\n //     var channel = new MessageChannel();\n //     channel.port1.onmessage = callback;\n //     return function requestCall() {\n //         channel.port2.postMessage(0);\n //     };\n // }\n // For reasons explained above, we are also unable to use `setImmediate`\n // under any circumstances.\n // Even if we were, there is another bug in Internet Explorer 10.\n // It is not sufficient to assign `setImmediate` to `requestFlush` because\n // `setImmediate` must be called *by name* and therefore must be wrapped in a\n // closure.\n // Never forget.\n // function makeRequestCallFromSetImmediate(callback) {\n //     return function requestCall() {\n //         setImmediate(callback);\n //     };\n // }\n // Safari 6.0 has a problem where timers will get lost while the user is\n // scrolling. This problem does not impact ASAP because Safari 6.0 supports\n // mutation observers, so that implementation is used instead.\n // However, if we ever elect to use timers in Safari, the prevalent work-around\n // is to add a scroll event listener that calls for a flush.\n // `setTimeout` does not call the passed callback if the delay is less than\n // approximately 7 in web workers in Firefox 8 through 18, and sometimes not\n // even then.\n // This is for `asap.js` only.\n // Its name will be periodically randomized to break any code that depends on\n // // its existence.\n // rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer\n // ASAP was originally a nextTick shim included in Q. This was factored out\n // into this ASAP package. It was later adapted to RSVP which made further\n // amendments. These decisions, particularly to marginalize MessageChannel and\n // to capture the MutationObserver implementation in a closure, were integrated\n // back into ASAP proper.\n // https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js\n\n//# sourceMappingURL=AsapQueue.js.map"],"version":3}