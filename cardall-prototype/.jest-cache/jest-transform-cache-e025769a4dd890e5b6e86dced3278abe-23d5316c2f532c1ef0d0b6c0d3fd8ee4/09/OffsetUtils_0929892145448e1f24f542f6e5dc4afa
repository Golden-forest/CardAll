e31bae7703adc67990380ff387c0142b
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getNodeClientOffset = getNodeClientOffset;
exports.getEventClientOffset = getEventClientOffset;
exports.getDragPreviewOffset = getDragPreviewOffset;
const BrowserDetector_js_1 = require("./BrowserDetector.js");
const MonotonicInterpolant_js_1 = require("./MonotonicInterpolant.js");
const ELEMENT_NODE = 1;
function getNodeClientOffset(node) {
    const el = node.nodeType === ELEMENT_NODE ? node : node.parentElement;
    if (!el) {
        return null;
    }
    const { top, left } = el.getBoundingClientRect();
    return {
        x: left,
        y: top
    };
}
function getEventClientOffset(e) {
    return {
        x: e.clientX,
        y: e.clientY
    };
}
function isImageNode(node) {
    var ref;
    return node.nodeName === 'IMG' && ((0, BrowserDetector_js_1.isFirefox)() || !((ref = document.documentElement) === null || ref === void 0 ? void 0 : ref.contains(node)));
}
function getDragPreviewSize(isImage, dragPreview, sourceWidth, sourceHeight) {
    let dragPreviewWidth = isImage ? dragPreview.width : sourceWidth;
    let dragPreviewHeight = isImage ? dragPreview.height : sourceHeight;
    // Work around @2x coordinate discrepancies in browsers
    if ((0, BrowserDetector_js_1.isSafari)() && isImage) {
        dragPreviewHeight /= window.devicePixelRatio;
        dragPreviewWidth /= window.devicePixelRatio;
    }
    return {
        dragPreviewWidth,
        dragPreviewHeight
    };
}
function getDragPreviewOffset(sourceNode, dragPreview, clientOffset, anchorPoint, offsetPoint) {
    // The browsers will use the image intrinsic size under different conditions.
    // Firefox only cares if it's an image, but WebKit also wants it to be detached.
    const isImage = isImageNode(dragPreview);
    const dragPreviewNode = isImage ? sourceNode : dragPreview;
    const dragPreviewNodeOffsetFromClient = getNodeClientOffset(dragPreviewNode);
    const offsetFromDragPreview = {
        x: clientOffset.x - dragPreviewNodeOffsetFromClient.x,
        y: clientOffset.y - dragPreviewNodeOffsetFromClient.y
    };
    const { offsetWidth: sourceWidth, offsetHeight: sourceHeight } = sourceNode;
    const { anchorX, anchorY } = anchorPoint;
    const { dragPreviewWidth, dragPreviewHeight } = getDragPreviewSize(isImage, dragPreview, sourceWidth, sourceHeight);
    const calculateYOffset = () => {
        const interpolantY = new MonotonicInterpolant_js_1.MonotonicInterpolant([
            0,
            0.5,
            1
        ], [
            // Dock to the top
            offsetFromDragPreview.y,
            // Align at the center
            (offsetFromDragPreview.y / sourceHeight) * dragPreviewHeight,
            // Dock to the bottom
            offsetFromDragPreview.y + dragPreviewHeight - sourceHeight,
        ]);
        let y = interpolantY.interpolate(anchorY);
        // Work around Safari 8 positioning bug
        if ((0, BrowserDetector_js_1.isSafari)() && isImage) {
            // We'll have to wait for @3x to see if this is entirely correct
            y += (window.devicePixelRatio - 1) * dragPreviewHeight;
        }
        return y;
    };
    const calculateXOffset = () => {
        // Interpolate coordinates depending on anchor point
        // If you know a simpler way to do this, let me know
        const interpolantX = new MonotonicInterpolant_js_1.MonotonicInterpolant([
            0,
            0.5,
            1
        ], [
            // Dock to the left
            offsetFromDragPreview.x,
            // Align at the center
            (offsetFromDragPreview.x / sourceWidth) * dragPreviewWidth,
            // Dock to the right
            offsetFromDragPreview.x + dragPreviewWidth - sourceWidth,
        ]);
        return interpolantX.interpolate(anchorX);
    };
    // Force offsets if specified in the options.
    const { offsetX, offsetY } = offsetPoint;
    const isManualOffsetX = offsetX === 0 || offsetX;
    const isManualOffsetY = offsetY === 0 || offsetY;
    return {
        x: isManualOffsetX ? offsetX : calculateXOffset(),
        y: isManualOffsetY ? offsetY : calculateYOffset()
    };
}
//# sourceMappingURL=OffsetUtils.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiRDpcXFByb2plY3RzXFxDYXJkRXZlcnl0aGluZ1xcY2FyZGFsbC1wcm90b3R5cGVcXG5vZGVfbW9kdWxlc1xccmVhY3QtZG5kLWh0bWw1LWJhY2tlbmRcXGRpc3RcXE9mZnNldFV0aWxzLmpzIiwibWFwcGluZ3MiOiI7O0FBR0Esa0RBVUM7QUFDRCxvREFLQztBQWtCRCxvREEyREM7QUFoR0QsNkRBQTJEO0FBQzNELHVFQUFpRTtBQUNqRSxNQUFNLFlBQVksR0FBRyxDQUFDLENBQUM7QUFDdkIsU0FBZ0IsbUJBQW1CLENBQUMsSUFBSTtJQUNwQyxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsUUFBUSxLQUFLLFlBQVksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDO0lBQ3RFLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQztRQUNOLE9BQU8sSUFBSSxDQUFDO0lBQ2hCLENBQUM7SUFDRCxNQUFNLEVBQUUsR0FBRyxFQUFHLElBQUksRUFBRyxHQUFHLEVBQUUsQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO0lBQ25ELE9BQU87UUFDSCxDQUFDLEVBQUUsSUFBSTtRQUNQLENBQUMsRUFBRSxHQUFHO0tBQ1QsQ0FBQztBQUNOLENBQUM7QUFDRCxTQUFnQixvQkFBb0IsQ0FBQyxDQUFDO0lBQ2xDLE9BQU87UUFDSCxDQUFDLEVBQUUsQ0FBQyxDQUFDLE9BQU87UUFDWixDQUFDLEVBQUUsQ0FBQyxDQUFDLE9BQU87S0FDZixDQUFDO0FBQ04sQ0FBQztBQUNELFNBQVMsV0FBVyxDQUFDLElBQUk7SUFDckIsSUFBSSxHQUFHLENBQUM7SUFDUixPQUFPLElBQUksQ0FBQyxRQUFRLEtBQUssS0FBSyxJQUFJLENBQUMsSUFBQSw4QkFBUyxHQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLFFBQVEsQ0FBQyxlQUFlLENBQUMsS0FBSyxJQUFJLElBQUksR0FBRyxLQUFLLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFD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Q25CLHFCQUFxQixDQUFDLENBQUM7WUFDdkIsc0JBQXNCO1lBQ3RCLENBQUMscUJBQXFCLENBQUMsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxHQUFHLGdCQUFnQjtZQUMxRCxvQkFBb0I7WUFDcEIscUJBQXFCLENBQUMsQ0FBQyxHQUFHLGdCQUFnQixHQUFHLFdBQVc7U0FDM0QsQ0FBQyxDQUFDO1FBQ0gsT0FBTyxZQUFZLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQzdDLENBQUMsQ0FBQztJQUNGLDZDQUE2QztJQUM3QyxNQUFNLEVBQUUsT0FBTyxFQUFHLE9BQU8sRUFBRyxHQUFHLFdBQVcsQ0FBQztJQUMzQyxNQUFNLGVBQWUsR0FBRyxPQUFPLEtBQUssQ0FBQyxJQUFJLE9BQU8sQ0FBQztJQUNqRCxNQUFNLGVBQWUsR0FBRyxPQUFPLEtBQUssQ0FBQyxJQUFJLE9BQU8sQ0FBQztJQUNqRCxPQUFPO1FBQ0gsQ0FBQyxFQUFFLGVBQWUsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxnQkFBZ0IsRUFBRTtRQUNqRCxDQUFDLEVBQUUsZUFBZSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLGdCQUFnQixFQUFFO0tBQ3BELENBQUM7QUFDTixDQUFDO0FBRUQsdUNBQXVDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkQ6XFxQcm9qZWN0c1xcQ2FyZEV2ZXJ5dGhpbmdcXGNhcmRhbGwtcHJvdG90eXBlXFxub2RlX21vZHVsZXNcXHJlYWN0LWRuZC1odG1sNS1iYWNrZW5kXFxkaXN0XFxPZmZzZXRVdGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc0ZpcmVmb3gsIGlzU2FmYXJpIH0gZnJvbSAnLi9Ccm93c2VyRGV0ZWN0b3IuanMnO1xuaW1wb3J0IHsgTW9ub3RvbmljSW50ZXJwb2xhbnQgfSBmcm9tICcuL01vbm90b25pY0ludGVycG9sYW50LmpzJztcbmNvbnN0IEVMRU1FTlRfTk9ERSA9IDE7XG5leHBvcnQgZnVuY3Rpb24gZ2V0Tm9kZUNsaWVudE9mZnNldChub2RlKSB7XG4gICAgY29uc3QgZWwgPSBub2RlLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUgPyBub2RlIDogbm9kZS5wYXJlbnRFbGVtZW50O1xuICAgIGlmICghZWwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHsgdG9wICwgbGVmdCAgfSA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IGxlZnQsXG4gICAgICAgIHk6IHRvcFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0RXZlbnRDbGllbnRPZmZzZXQoZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IGUuY2xpZW50WCxcbiAgICAgICAgeTogZS5jbGllbnRZXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGlzSW1hZ2VOb2RlKG5vZGUpIHtcbiAgICB2YXIgcmVmO1xuICAgIHJldHVybiBub2RlLm5vZGVOYW1lID09PSAnSU1HJyAmJiAoaXNGaXJlZm94KCkgfHwgISgocmVmID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZi5jb250YWlucyhub2RlKSkpO1xufVxuZnVuY3Rpb24gZ2V0RHJhZ1ByZXZpZXdTaXplKGlzSW1hZ2UsIGRyYWdQcmV2aWV3LCBzb3VyY2VXaWR0aCwgc291cmNlSGVpZ2h0KSB7XG4gICAgbGV0IGRyYWdQcmV2aWV3V2lkdGggPSBpc0ltYWdlID8gZHJhZ1ByZXZpZXcud2lkdGggOiBzb3VyY2VXaWR0aDtcbiAgICBsZXQgZHJhZ1ByZXZpZXdIZWlnaHQgPSBpc0ltYWdlID8gZHJhZ1ByZXZpZXcuaGVpZ2h0IDogc291cmNlSGVpZ2h0O1xuICAgIC8vIFdvcmsgYXJvdW5kIEAyeCBjb29yZGluYXRlIGRpc2NyZXBhbmNpZXMgaW4gYnJvd3NlcnNcbiAgICBpZiAoaXNTYWZhcmkoKSAmJiBpc0ltYWdlKSB7XG4gICAgICAgIGRyYWdQcmV2aWV3SGVpZ2h0IC89IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgICBkcmFnUHJldmlld1dpZHRoIC89IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBkcmFnUHJldmlld1dpZHRoLFxuICAgICAgICBkcmFnUHJldmlld0hlaWdodFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0RHJhZ1ByZXZpZXdPZmZzZXQoc291cmNlTm9kZSwgZHJhZ1ByZXZpZXcsIGNsaWVudE9mZnNldCwgYW5jaG9yUG9pbnQsIG9mZnNldFBvaW50KSB7XG4gICAgLy8gVGhlIGJyb3dzZXJzIHdpbGwgdXNlIHRoZSBpbWFnZSBpbnRyaW5zaWMgc2l6ZSB1bmRlciBkaWZmZXJlbnQgY29uZGl0aW9ucy5cbiAgICAvLyBGaXJlZm94IG9ubHkgY2FyZXMgaWYgaXQncyBhbiBpbWFnZSwgYnV0IFdlYktpdCBhbHNvIHdhbnRzIGl0IHRvIGJlIGRldGFjaGVkLlxuICAgIGNvbnN0IGlzSW1hZ2UgPSBpc0ltYWdlTm9kZShkcmFnUHJldmlldyk7XG4gICAgY29uc3QgZHJhZ1ByZXZpZXdOb2RlID0gaXNJbWFnZSA/IHNvdXJjZU5vZGUgOiBkcmFnUHJldmlldztcbiAgICBjb25zdCBkcmFnUHJldmlld05vZGVPZmZzZXRGcm9tQ2xpZW50ID0gZ2V0Tm9kZUNsaWVudE9mZnNldChkcmFnUHJldmlld05vZGUpO1xuICAgIGNvbnN0IG9mZnNldEZyb21EcmFnUHJldmlldyA9IHtcbiAgICAgICAgeDogY2xpZW50T2Zmc2V0LnggLSBkcmFnUHJldmlld05vZGVPZmZzZXRGcm9tQ2xpZW50LngsXG4gICAgICAgIHk6IGNsaWVudE9mZnNldC55IC0gZHJhZ1ByZXZpZXdOb2RlT2Zmc2V0RnJvbUNsaWVudC55XG4gICAgfTtcbiAgICBjb25zdCB7IG9mZnNldFdpZHRoOiBzb3VyY2VXaWR0aCAsIG9mZnNldEhlaWdodDogc291cmNlSGVpZ2h0ICB9ID0gc291cmNlTm9kZTtcbiAgICBjb25zdCB7IGFuY2hvclggLCBhbmNob3JZICB9ID0gYW5jaG9yUG9pbnQ7XG4gICAgY29uc3QgeyBkcmFnUHJldmlld1dpZHRoICwgZHJhZ1ByZXZpZXdIZWlnaHQgIH0gPSBnZXREcmFnUHJldmlld1NpemUoaXNJbWFnZSwgZHJhZ1ByZXZpZXcsIHNvdXJjZVdpZHRoLCBzb3VyY2VIZWlnaHQpO1xuICAgIGNvbnN0IGNhbGN1bGF0ZVlPZmZzZXQgPSAoKT0+e1xuICAgICAgICBjb25zdCBpbnRlcnBvbGFudFkgPSBuZXcgTW9ub3RvbmljSW50ZXJwb2xhbnQoW1xuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAuNSxcbiAgICAgICAgICAgIDFcbiAgICAgICAgXSwgW1xuICAgICAgICAgICAgLy8gRG9jayB0byB0aGUgdG9wXG4gICAgICAgICAgICBvZmZzZXRGcm9tRHJhZ1ByZXZpZXcueSxcbiAgICAgICAgICAgIC8vIEFsaWduIGF0IHRoZSBjZW50ZXJcbiAgICAgICAgICAgIChvZmZzZXRGcm9tRHJhZ1ByZXZpZXcueSAvIHNvdXJjZUhlaWdodCkgKiBkcmFnUHJldmlld0hlaWdodCxcbiAgICAgICAgICAgIC8vIERvY2sgdG8gdGhlIGJvdHRvbVxuICAgICAgICAgICAgb2Zmc2V0RnJvbURyYWdQcmV2aWV3LnkgKyBkcmFnUHJldmlld0hlaWdodCAtIHNvdXJjZUhlaWdodCwgXG4gICAgICAgIF0pO1xuICAgICAgICBsZXQgeSA9IGludGVycG9sYW50WS5pbnRlcnBvbGF0ZShhbmNob3JZKTtcbiAgICAgICAgLy8gV29yayBhcm91bmQgU2FmYXJpIDggcG9zaXRpb25pbmcgYnVnXG4gICAgICAgIGlmIChpc1NhZmFyaSgpICYmIGlzSW1hZ2UpIHtcbiAgICAgICAgICAgIC8vIFdlJ2xsIGhhdmUgdG8gd2FpdCBmb3IgQDN4IHRvIHNlZSBpZiB0aGlzIGlzIGVudGlyZWx5IGNvcnJlY3RcbiAgICAgICAgICAgIHkgKz0gKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIC0gMSkgKiBkcmFnUHJldmlld0hlaWdodDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geTtcbiAgICB9O1xuICAgIGNvbnN0IGNhbGN1bGF0ZVhPZmZzZXQgPSAoKT0+e1xuICAgICAgICAvLyBJbnRlcnBvbGF0ZSBjb29yZGluYXRlcyBkZXBlbmRpbmcgb24gYW5jaG9yIHBvaW50XG4gICAgICAgIC8vIElmIHlvdSBrbm93IGEgc2ltcGxlciB3YXkgdG8gZG8gdGhpcywgbGV0IG1lIGtub3dcbiAgICAgICAgY29uc3QgaW50ZXJwb2xhbnRYID0gbmV3IE1vbm90b25pY0ludGVycG9sYW50KFtcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAwLjUsXG4gICAgICAgICAgICAxXG4gICAgICAgIF0sIFtcbiAgICAgICAgICAgIC8vIERvY2sgdG8gdGhlIGxlZnRcbiAgICAgICAgICAgIG9mZnNldEZyb21EcmFnUHJldmlldy54LFxuICAgICAgICAgICAgLy8gQWxpZ24gYXQgdGhlIGNlbnRlclxuICAgICAgICAgICAgKG9mZnNldEZyb21EcmFnUHJldmlldy54IC8gc291cmNlV2lkdGgpICogZHJhZ1ByZXZpZXdXaWR0aCxcbiAgICAgICAgICAgIC8vIERvY2sgdG8gdGhlIHJpZ2h0XG4gICAgICAgICAgICBvZmZzZXRGcm9tRHJhZ1ByZXZpZXcueCArIGRyYWdQcmV2aWV3V2lkdGggLSBzb3VyY2VXaWR0aCwgXG4gICAgICAgIF0pO1xuICAgICAgICByZXR1cm4gaW50ZXJwb2xhbnRYLmludGVycG9sYXRlKGFuY2hvclgpO1xuICAgIH07XG4gICAgLy8gRm9yY2Ugb2Zmc2V0cyBpZiBzcGVjaWZpZWQgaW4gdGhlIG9wdGlvbnMuXG4gICAgY29uc3QgeyBvZmZzZXRYICwgb2Zmc2V0WSAgfSA9IG9mZnNldFBvaW50O1xuICAgIGNvbnN0IGlzTWFudWFsT2Zmc2V0WCA9IG9mZnNldFggPT09IDAgfHwgb2Zmc2V0WDtcbiAgICBjb25zdCBpc01hbnVhbE9mZnNldFkgPSBvZmZzZXRZID09PSAwIHx8IG9mZnNldFk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogaXNNYW51YWxPZmZzZXRYID8gb2Zmc2V0WCA6IGNhbGN1bGF0ZVhPZmZzZXQoKSxcbiAgICAgICAgeTogaXNNYW51YWxPZmZzZXRZID8gb2Zmc2V0WSA6IGNhbGN1bGF0ZVlPZmZzZXQoKVxuICAgIH07XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9mZnNldFV0aWxzLmpzLm1hcCJdLCJ2ZXJzaW9uIjozfQ==