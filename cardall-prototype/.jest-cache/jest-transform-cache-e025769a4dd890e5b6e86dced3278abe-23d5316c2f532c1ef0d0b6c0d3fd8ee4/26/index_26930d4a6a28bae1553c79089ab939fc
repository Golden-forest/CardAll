7e14b706991b5689d3d2939c064c878b
'use strict';
Object.defineProperty(exports, '__esModule', {
    value: true
});
exports.printReceived =
    exports.printExpected =
        exports.printDiffOrStringify =
            exports.pluralize =
                exports.matcherHint =
                    exports.matcherErrorMessage =
                        exports.highlightTrailingWhitespace =
                            exports.getLabelPrinter =
                                exports.ensureNumbers =
                                    exports.ensureNoExpected =
                                        exports.ensureExpectedIsNumber =
                                            exports.ensureExpectedIsNonNegativeInteger =
                                                exports.ensureActualIsNumber =
                                                    exports.diff =
                                                        exports.SUGGEST_TO_CONTAIN_EQUAL =
                                                            exports.RECEIVED_COLOR =
                                                                exports.INVERTED_COLOR =
                                                                    exports.EXPECTED_COLOR =
                                                                        exports.DIM_COLOR =
                                                                            exports.BOLD_WEIGHT =
                                                                                void 0;
exports.printWithType = printWithType;
exports.replaceMatchedToAsymmetricMatcher = replaceMatchedToAsymmetricMatcher;
exports.stringify = void 0;
var _chalk = _interopRequireDefault(require('chalk'));
var _jestDiff = require('jest-diff');
var _jestGetType = require('jest-get-type');
var _prettyFormat = require('pretty-format');
var _Replaceable = _interopRequireDefault(require('./Replaceable'));
var _deepCyclicCopyReplaceable = _interopRequireDefault(require('./deepCyclicCopyReplaceable'));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}
/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/* eslint-disable local/ban-types-eventually */
const { AsymmetricMatcher, DOMCollection, DOMElement, Immutable, ReactElement, ReactTestComponent } = _prettyFormat.plugins;
const PLUGINS = [
    ReactTestComponent,
    ReactElement,
    DOMElement,
    DOMCollection,
    Immutable,
    AsymmetricMatcher
];
const EXPECTED_COLOR = _chalk.default.green;
exports.EXPECTED_COLOR = EXPECTED_COLOR;
const RECEIVED_COLOR = _chalk.default.red;
exports.RECEIVED_COLOR = RECEIVED_COLOR;
const INVERTED_COLOR = _chalk.default.inverse;
exports.INVERTED_COLOR = INVERTED_COLOR;
const BOLD_WEIGHT = _chalk.default.bold;
exports.BOLD_WEIGHT = BOLD_WEIGHT;
const DIM_COLOR = _chalk.default.dim;
exports.DIM_COLOR = DIM_COLOR;
const MULTILINE_REGEXP = /\n/;
const SPACE_SYMBOL = '\u{00B7}'; // middle dot
const NUMBERS = [
    'zero',
    'one',
    'two',
    'three',
    'four',
    'five',
    'six',
    'seven',
    'eight',
    'nine',
    'ten',
    'eleven',
    'twelve',
    'thirteen'
];
const SUGGEST_TO_CONTAIN_EQUAL = _chalk.default.dim('Looks like you wanted to test for object/array equality with the stricter `toContain` matcher. You probably need to use `toContainEqual` instead.');
exports.SUGGEST_TO_CONTAIN_EQUAL = SUGGEST_TO_CONTAIN_EQUAL;
const stringify = (object, maxDepth = 10, maxWidth = 10) => {
    const MAX_LENGTH = 10000;
    let result;
    try {
        result = (0, _prettyFormat.format)(object, {
            maxDepth,
            maxWidth,
            min: true,
            plugins: PLUGINS
        });
    }
    catch {
        result = (0, _prettyFormat.format)(object, {
            callToJSON: false,
            maxDepth,
            maxWidth,
            min: true,
            plugins: PLUGINS
        });
    }
    if (result.length >= MAX_LENGTH && maxDepth > 1) {
        return stringify(object, Math.floor(maxDepth / 2), maxWidth);
    }
    else if (result.length >= MAX_LENGTH && maxWidth > 1) {
        return stringify(object, maxDepth, Math.floor(maxWidth / 2));
    }
    else {
        return result;
    }
};
exports.stringify = stringify;
const highlightTrailingWhitespace = text => text.replace(/\s+$/gm, _chalk.default.inverse('$&'));
// Instead of inverse highlight which now implies a change,
// replace common spaces with middle dot at the end of any line.
exports.highlightTrailingWhitespace = highlightTrailingWhitespace;
const replaceTrailingSpaces = text => text.replace(/\s+$/gm, spaces => SPACE_SYMBOL.repeat(spaces.length));
const printReceived = object => RECEIVED_COLOR(replaceTrailingSpaces(stringify(object)));
exports.printReceived = printReceived;
const printExpected = value => EXPECTED_COLOR(replaceTrailingSpaces(stringify(value)));
exports.printExpected = printExpected;
function printWithType(name, value, print) {
    const type = (0, _jestGetType.getType)(value);
    const hasType = type !== 'null' && type !== 'undefined'
        ? `${name} has type:  ${type}\n`
        : '';
    const hasValue = `${name} has value: ${print(value)}`;
    return hasType + hasValue;
}
const ensureNoExpected = (expected, matcherName, options) => {
    if (typeof expected !== 'undefined') {
        // Prepend maybe not only for backward compatibility.
        const matcherString = (options ? '' : '[.not]') + matcherName;
        throw new Error(matcherErrorMessage(matcherHint(matcherString, undefined, '', options), 
        // Because expected is omitted in hint above,
        // expected is black instead of green in message below.
        'this matcher must not have an expected argument', printWithType('Expected', expected, printExpected)));
    }
};
/**
 * Ensures that `actual` is of type `number | bigint`
 */
exports.ensureNoExpected = ensureNoExpected;
const ensureActualIsNumber = (actual, matcherName, options) => {
    if (typeof actual !== 'number' && typeof actual !== 'bigint') {
        // Prepend maybe not only for backward compatibility.
        const matcherString = (options ? '' : '[.not]') + matcherName;
        throw new Error(matcherErrorMessage(matcherHint(matcherString, undefined, undefined, options), `${RECEIVED_COLOR('received')} value must be a number or bigint`, printWithType('Received', actual, printReceived)));
    }
};
/**
 * Ensures that `expected` is of type `number | bigint`
 */
exports.ensureActualIsNumber = ensureActualIsNumber;
const ensureExpectedIsNumber = (expected, matcherName, options) => {
    if (typeof expected !== 'number' && typeof expected !== 'bigint') {
        // Prepend maybe not only for backward compatibility.
        const matcherString = (options ? '' : '[.not]') + matcherName;
        throw new Error(matcherErrorMessage(matcherHint(matcherString, undefined, undefined, options), `${EXPECTED_COLOR('expected')} value must be a number or bigint`, printWithType('Expected', expected, printExpected)));
    }
};
/**
 * Ensures that `actual` & `expected` are of type `number | bigint`
 */
exports.ensureExpectedIsNumber = ensureExpectedIsNumber;
const ensureNumbers = (actual, expected, matcherName, options) => {
    ensureActualIsNumber(actual, matcherName, options);
    ensureExpectedIsNumber(expected, matcherName, options);
};
exports.ensureNumbers = ensureNumbers;
const ensureExpectedIsNonNegativeInteger = (expected, matcherName, options) => {
    if (typeof expected !== 'number' ||
        !Number.isSafeInteger(expected) ||
        expected < 0) {
        // Prepend maybe not only for backward compatibility.
        const matcherString = (options ? '' : '[.not]') + matcherName;
        throw new Error(matcherErrorMessage(matcherHint(matcherString, undefined, undefined, options), `${EXPECTED_COLOR('expected')} value must be a non-negative integer`, printWithType('Expected', expected, printExpected)));
    }
};
// Given array of diffs, return concatenated string:
// * include common substrings
// * exclude change substrings which have opposite op
// * include change substrings which have argument op
//   with inverse highlight only if there is a common substring
exports.ensureExpectedIsNonNegativeInteger = ensureExpectedIsNonNegativeInteger;
const getCommonAndChangedSubstrings = (diffs, op, hasCommonDiff) => diffs.reduce((reduced, diff) => reduced +
    (diff[0] === _jestDiff.DIFF_EQUAL
        ? diff[1]
        : diff[0] !== op
            ? ''
            : hasCommonDiff
                ? INVERTED_COLOR(diff[1])
                : diff[1]), '');
const isLineDiffable = (expected, received) => {
    const expectedType = (0, _jestGetType.getType)(expected);
    const receivedType = (0, _jestGetType.getType)(received);
    if (expectedType !== receivedType) {
        return false;
    }
    if ((0, _jestGetType.isPrimitive)(expected)) {
        // Print generic line diff for strings only:
        // * if neither string is empty
        // * if either string has more than one line
        return (typeof expected === 'string' &&
            typeof received === 'string' &&
            expected.length !== 0 &&
            received.length !== 0 &&
            (MULTILINE_REGEXP.test(expected) || MULTILINE_REGEXP.test(received)));
    }
    if (expectedType === 'date' ||
        expectedType === 'function' ||
        expectedType === 'regexp') {
        return false;
    }
    if (expected instanceof Error && received instanceof Error) {
        return false;
    }
    if (receivedType === 'object' &&
        typeof received.asymmetricMatch === 'function') {
        return false;
    }
    return true;
};
const MAX_DIFF_STRING_LENGTH = 20000;
const printDiffOrStringify = (expected, received, expectedLabel, receivedLabel, expand // CLI options: true if `--expand` or false if `--no-expand`
) => {
    if (typeof expected === 'string' &&
        typeof received === 'string' &&
        expected.length !== 0 &&
        received.length !== 0 &&
        expected.length <= MAX_DIFF_STRING_LENGTH &&
        received.length <= MAX_DIFF_STRING_LENGTH &&
        expected !== received) {
        if (expected.includes('\n') || received.includes('\n')) {
            return (0, _jestDiff.diffStringsUnified)(expected, received, {
                aAnnotation: expectedLabel,
                bAnnotation: receivedLabel,
                changeLineTrailingSpaceColor: _chalk.default.bgYellow,
                commonLineTrailingSpaceColor: _chalk.default.bgYellow,
                emptyFirstOrLastLinePlaceholder: '↵',
                // U+21B5
                expand,
                includeChangeCounts: true
            });
        }
        const diffs = (0, _jestDiff.diffStringsRaw)(expected, received, true);
        const hasCommonDiff = diffs.some(diff => diff[0] === _jestDiff.DIFF_EQUAL);
        const printLabel = getLabelPrinter(expectedLabel, receivedLabel);
        const expectedLine = printLabel(expectedLabel) +
            printExpected(getCommonAndChangedSubstrings(diffs, _jestDiff.DIFF_DELETE, hasCommonDiff));
        const receivedLine = printLabel(receivedLabel) +
            printReceived(getCommonAndChangedSubstrings(diffs, _jestDiff.DIFF_INSERT, hasCommonDiff));
        return `${expectedLine}\n${receivedLine}`;
    }
    if (isLineDiffable(expected, received)) {
        const { replacedExpected, replacedReceived } = replaceMatchedToAsymmetricMatcher(expected, received, [], []);
        const difference = (0, _jestDiff.diff)(replacedExpected, replacedReceived, {
            aAnnotation: expectedLabel,
            bAnnotation: receivedLabel,
            expand,
            includeChangeCounts: true
        });
        if (typeof difference === 'string' &&
            difference.includes(`- ${expectedLabel}`) &&
            difference.includes(`+ ${receivedLabel}`)) {
            return difference;
        }
    }
    const printLabel = getLabelPrinter(expectedLabel, receivedLabel);
    const expectedLine = printLabel(expectedLabel) + printExpected(expected);
    const receivedLine = printLabel(receivedLabel) +
        (stringify(expected) === stringify(received)
            ? 'serializes to the same string'
            : printReceived(received));
    return `${expectedLine}\n${receivedLine}`;
};
// Sometimes, e.g. when comparing two numbers, the output from jest-diff
// does not contain more information than the `Expected:` / `Received:` already gives.
// In those cases, we do not print a diff to make the output shorter and not redundant.
exports.printDiffOrStringify = printDiffOrStringify;
const shouldPrintDiff = (actual, expected) => {
    if (typeof actual === 'number' && typeof expected === 'number') {
        return false;
    }
    if (typeof actual === 'bigint' && typeof expected === 'bigint') {
        return false;
    }
    if (typeof actual === 'boolean' && typeof expected === 'boolean') {
        return false;
    }
    return true;
};
function replaceMatchedToAsymmetricMatcher(replacedExpected, replacedReceived, expectedCycles, receivedCycles) {
    return _replaceMatchedToAsymmetricMatcher((0, _deepCyclicCopyReplaceable.default)(replacedExpected), (0, _deepCyclicCopyReplaceable.default)(replacedReceived), expectedCycles, receivedCycles);
}
function _replaceMatchedToAsymmetricMatcher(replacedExpected, replacedReceived, expectedCycles, receivedCycles) {
    if (!_Replaceable.default.isReplaceable(replacedExpected, replacedReceived)) {
        return {
            replacedExpected,
            replacedReceived
        };
    }
    if (expectedCycles.includes(replacedExpected) ||
        receivedCycles.includes(replacedReceived)) {
        return {
            replacedExpected,
            replacedReceived
        };
    }
    expectedCycles.push(replacedExpected);
    receivedCycles.push(replacedReceived);
    const expectedReplaceable = new _Replaceable.default(replacedExpected);
    const receivedReplaceable = new _Replaceable.default(replacedReceived);
    expectedReplaceable.forEach((expectedValue, key) => {
        const receivedValue = receivedReplaceable.get(key);
        if (isAsymmetricMatcher(expectedValue)) {
            if (expectedValue.asymmetricMatch(receivedValue)) {
                receivedReplaceable.set(key, expectedValue);
            }
        }
        else if (isAsymmetricMatcher(receivedValue)) {
            if (receivedValue.asymmetricMatch(expectedValue)) {
                expectedReplaceable.set(key, receivedValue);
            }
        }
        else if (_Replaceable.default.isReplaceable(expectedValue, receivedValue)) {
            const replaced = _replaceMatchedToAsymmetricMatcher(expectedValue, receivedValue, expectedCycles, receivedCycles);
            expectedReplaceable.set(key, replaced.replacedExpected);
            receivedReplaceable.set(key, replaced.replacedReceived);
        }
    });
    return {
        replacedExpected: expectedReplaceable.object,
        replacedReceived: receivedReplaceable.object
    };
}
function isAsymmetricMatcher(data) {
    const type = (0, _jestGetType.getType)(data);
    return type === 'object' && typeof data.asymmetricMatch === 'function';
}
const diff = (a, b, options) => shouldPrintDiff(a, b) ? (0, _jestDiff.diff)(a, b, options) : null;
exports.diff = diff;
const pluralize = (word, count) => `${NUMBERS[count] || count} ${word}${count === 1 ? '' : 's'}`;
// To display lines of labeled values as two columns with monospace alignment:
// given the strings which will describe the values,
// return function which given each string, returns the label:
// string, colon, space, and enough padding spaces to align the value.
exports.pluralize = pluralize;
const getLabelPrinter = (...strings) => {
    const maxLength = strings.reduce((max, string) => (string.length > max ? string.length : max), 0);
    return string => `${string}: ${' '.repeat(maxLength - string.length)}`;
};
exports.getLabelPrinter = getLabelPrinter;
const matcherErrorMessage = (hint, generic, specific // incorrect value returned from call to printWithType
) => `${hint}\n\n${_chalk.default.bold('Matcher error')}: ${generic}${typeof specific === 'string' ? `\n\n${specific}` : ''}`;
// Display assertion for the report when a test fails.
// New format: rejects/resolves, not, and matcher name have black color
// Old format: matcher name has dim color
exports.matcherErrorMessage = matcherErrorMessage;
const matcherHint = (matcherName, received = 'received', expected = 'expected', options = {}) => {
    const { comment = '', expectedColor = EXPECTED_COLOR, isDirectExpectCall = false, 
    // seems redundant with received === ''
    isNot = false, promise = '', receivedColor = RECEIVED_COLOR, secondArgument = '', secondArgumentColor = EXPECTED_COLOR } = options;
    let hint = '';
    let dimString = 'expect'; // concatenate adjacent dim substrings
    if (!isDirectExpectCall && received !== '') {
        hint += DIM_COLOR(`${dimString}(`) + receivedColor(received);
        dimString = ')';
    }
    if (promise !== '') {
        hint += DIM_COLOR(`${dimString}.`) + promise;
        dimString = '';
    }
    if (isNot) {
        hint += `${DIM_COLOR(`${dimString}.`)}not`;
        dimString = '';
    }
    if (matcherName.includes('.')) {
        // Old format: for backward compatibility,
        // especially without promise or isNot options
        dimString += matcherName;
    }
    else {
        // New format: omit period from matcherName arg
        hint += DIM_COLOR(`${dimString}.`) + matcherName;
        dimString = '';
    }
    if (expected === '') {
        dimString += '()';
    }
    else {
        hint += DIM_COLOR(`${dimString}(`) + expectedColor(expected);
        if (secondArgument) {
            hint += DIM_COLOR(', ') + secondArgumentColor(secondArgument);
        }
        dimString = ')';
    }
    if (comment !== '') {
        dimString += ` // ${comment}`;
    }
    if (dimString !== '') {
        hint += DIM_COLOR(dimString);
    }
    return hint;
};
exports.matcherHint = matcherHint;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiRDpcXFByb2plY3RzXFxDYXJkRXZlcnl0aGluZ1xcY2FyZGFsbC1wcm90b3R5cGVcXG5vZGVfbW9kdWxlc1xcamVzdC1heGVcXG5vZGVfbW9kdWxlc1xcamVzdC1tYXRjaGVyLXV0aWxzXFxidWlsZFxcaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsWUFBWSxDQUFDO0FBRWIsTUFBTSxDQUFDLGNBQWMsQ0FBQyxPQUFPLEVBQUUsWUFBWSxFQUFFO0lBQzNDLEtBQUssRUFBRSxJQUFJO0NBQ1osQ0FBQyxDQUFDO0FBQ0gsT0FBTyxDQUFDLGFBQWE7SUFDbkIsT0FBTyxDQUFDLGFBQWE7UUFDckIsT0FBTyxDQUFDLG9CQUFvQjtZQUM1QixPQUFPLENBQUMsU0FBUztnQkFDakIsT0FBTyxDQUFDLFdBQVc7b0JBQ25CLE9BQU8sQ0FBQyxtQkFBbUI7d0JBQzNCLE9BQU8sQ0FBQywyQkFBMkI7NEJBQ25DLE9BQU8sQ0FBQyxlQUFlO2dDQUN2QixPQUFPLENBQUMsYUFBYTtvQ0FDckIsT0FBTyxDQUFDLGdCQUFnQjt3Q0FDeEIsT0FBTyxDQUFDLHNCQUFzQjs0Q0FDOUIsT0FBTyxDQUFDLGtDQUFrQztnREFDMUMsT0FBTyxDQUFDLG9CQUFvQjtvREFDNUIsT0FBTyxDQUFDLElBQUk7d0RBQ1osT0FBTyxDQUFDLHdCQUF3Qjs0REFDaEMsT0FBTyxDQUFDLGNBQWM7Z0VBQ3RCLE9BQU8sQ0FBQyxjQUFjO29FQUN0QixPQUFPLENBQUMsY0FBYzt3RUFDdEIsT0FBTyxDQUFDLFNBQVM7NEVBQ2pCLE9BQU8sQ0FBQyxXQUFXO2dGQUNqQixLQUFLLENBQUMsQ0FBQztBQUNYLE9BQU8sQ0FBQyxhQUFhLEdBQUcsYUFBYSxDQUFDO0FBQ3RDLE9BQU8sQ0FBQyxpQ0FBaUMsR0FBRyxpQ0FBaUMsQ0FBQztBQUM5RSxPQUFPLENBQUMsU0FBUyxHQUFHLEtBQUssQ0FBQyxDQUFDO0FBQzNCLElBQUksTUFBTSxHQUFHLHNCQUFzQixDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO0FBQ3RELElBQUksU0FBUyxHQUFHLE9BQU8sQ0FBQyxXQUFXLENBQUMsQ0FBQztBQUNyQyxJQUFJLFlBQVksR0FBRyxPQUFPLENBQUMsZUFBZSxDQUFDLENBQUM7QUFDNUMsSUFBSSxhQUFhLEdBQUcsT0FBTyxDQUFDLGVBQWUsQ0FBQyxDQUFDO0FBQzdDLElBQUksWUFBWSxHQUFHLHNCQUFzQixDQUFDLE9BQU8sQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDO0FBQ3BFLElBQUksMEJBQTBCLEdBQUcsc0JBQXNCLENBQ3JELE9BQU8sQ0FBQyw2QkFBNkIsQ0FBQyxDQUN2QyxDQUFDO0FBQ0YsU0FBUyxzQkFBc0IsQ0FBQyxHQUFHO0lBQ2pDLE9BQU8sR0FBRyxJQUFJLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBQyxPQUFPLEVBQUUsR0FBRyxFQUFDLENBQUM7QUFDdEQsQ0FBQztBQUNEOzs7OztHQUtHO0FBRUgsK0NBQStDO0FBRS9DLE1BQU0sRUFDSixpQkFBaUIsRUFDakIsYUFBYSxFQUNiLFVBQVUsRUFDVixTQUFTLEVBQ1QsWUFBWSxFQUNaLGtCQUFrQixFQUNuQixHQUFHLGFBQWEsQ0FBQyxPQUFPLENBQUM7QUFDMUIsTUFBTSxPQUFPLEdBQUc7SUFDZCxrQkFBa0I7SUFDbEIsWUFBWTtJQUNaLFVBQVU7SUFDVixhQUFhO0lBQ2IsU0FBUztJQUNULGlCQUFpQjtDQUNsQixDQUFDO0FBQ0YsTUFBTSxjQUFjLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUM7QUFDNUMsT0FBTyxDQUFDLGNBQWMsR0FBRyxjQUFjLENBQUM7QUFDeEMsTUFBTSxjQUFjLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUM7QUFDMUMsT0FBTyxDQUFDLGNBQWMsR0FBRyxjQUFjLENBQUM7QUFDeEMsTUFBTSxjQUFjLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUM7QUFDOUMsT0FBTyxDQUFDLGNBQWMsR0FBRyxjQUFjLENBQUM7QUFDeEMsTUFBTSxXQUFXLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUM7QUFDeEMsT0FBTyxDQUFDLFdBQVcsR0FBRyxXQUFXLENBQUM7QUFDbEMsTUFBTSxTQUFTLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUM7QUFDckMsT0FBTyxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUM7QUFDOUIsTUFBTSxnQkFBZ0IsR0FBRyxJQUFJLENBQUM7QUFDOUIsTUFBTSxZQUFZLEdBQUcsVUFBVSxDQUFDLENBQUMsYUFBYTtBQUU5QyxNQUFNLE9BQU8sR0FBRztJQUNkLE1BQU07SUFDTixLQUFLO0lBQ0wsS0FBSztJQUNMLE9BQU87SUFDUCxNQUFNO0lBQ04sTUFBTTtJQUNOLEtBQUs7SUFDTCxPQUFPO0lBQ1AsT0FBTztJQUNQLE1BQU07SUFDTixLQUFLO0lBQ0wsUUFBUTtJQUNSLFFBQVE7SUFDUixVQUFVO0NBQ1gsQ0FBQztBQUNGLE1BQU0sd0JBQXdCLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQ2pELG1KQUFtSixDQUNwSixDQUFDO0FBQ0YsT0FBTyxDQUFDLHdCQUF3QixHQUFHLHdCQUF3QixDQUFDO0FBQzVELE1BQU0sU0FBUyxHQUFHLENBQUMsTUFBTSxFQUFFLFFBQVEsR0FBRyxFQUFFLEVBQUUsUUFBUSxHQUFHLEVBQUUsRUFBRSxFQUFFO0lBQ3pELE1BQU0sVUFBVSxHQUFHLEtBQUssQ0FBQztJQUN6QixJQUFJLE1BQU0sQ0FBQztJQUNYLElBQUksQ0FBQztRQUNILE1BQU0sR0FBRyxDQUFDLENBQUMsRUFBRSxhQUFhLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxFQUFFO1lBQ3pDLFFBQVE7WUFDUixRQUFRO1lBQ1IsR0FBRyxFQUFFLElBQUk7WUFDVCxPQUFPLEVBQUUsT0FBTztTQUNqQixDQUFDLENBQUM7SUFDTCxDQUFDO0lBQUMsTUFBTSxDQUFDO1FBQ1AsTUFBTSxHQUFHLENBQUMsQ0FBQyxFQUFFLGFBQWEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxNQUFNLEVBQUU7WUFDekMsVUFBVSxFQUFFLEtBQUs7WUFDakIsUUFBUTtZQUNSLFFBQVE7WUFDUixHQUFHLEVBQUUsSUFBSTtZQUNULE9BQU8sRUFBRSxPQUFPO1NBQ2pCLENBQUMsQ0FBQztJQUNMLENBQUM7SUFDRCxJQUFJLE1BQU0sQ0FBQyxNQUFNLElBQUksVUFBVSxJQUFJLFFBQVEsR0FBRyxDQUFDLEVBQUUsQ0FBQztRQUNoRCxPQUFPLFNBQVMsQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLEdBQUcsQ0FBQyxDQUFDLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDL0QsQ0FBQztTQUFNLElBQUksTUFBTSxDQUFDLE1BQU0sSUFBSSxVQUFVLElBQUksUUFBUSxHQUFHLENBQUMsRUFBRSxDQUFDO1FBQ3ZELE9BQU8sU0FBUyxDQUFDLE1BQU0sRUFBRSxRQUFRLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUMvRCxDQUFDO1NBQU0sQ0FBQztRQUNOLE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7QUFDSCxDQUFDLENBQUM7QUFDRixPQUFPLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQztBQUM5QixNQUFNLDJCQUEyQixHQUFHLElBQUksQ0FBQyxFQUFFLENBQ3pDLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7QUFFdkQsMkRBQTJEO0FBQzNELGdFQUFnRTtBQUNoRSxPQUFPLENBQUMsMkJBQTJCLEdBQUcsMkJBQTJCLENBQUM7QUFDbEUsTUFBTSxxQkFBcUIsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUNuQyxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxNQUFNLENBQUMsRUFBRSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7QUFDdkUsTUFBTSxhQUFhLEdBQUcsTUFBTSxDQUFDLEVBQUUsQ0FDN0IsY0FBYyxDQUFDLHFCQUFxQixDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDM0QsT0FBTyxDQUFDLGFBQWEsR0FBRyxhQUFhLENBQUM7QUFDdEMsTUFBTSxhQUFhLEdBQUcsS0FBSyxDQUFDLEVBQUUsQ0FDNUIsY0FBYyxDQUFDLHFCQUFxQixDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDMUQsT0FBTyxDQUFDLGFBQWEsR0FBRyxhQUFhLENBQUM7QUFDdEMsU0FBUyxhQUFhLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxLQUFLO0lBQ3ZDLE1BQU0sSUFBSSxHQUFHLENBQUMsQ0FBQyxFQUFFLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUM5QyxNQUFNLE9BQU8sR0FDWCxJQUFJLEtBQUssTUFBTSxJQUFJLElBQUksS0FBSyxXQUFXO1FBQ3JDLENBQUMsQ0FBQyxHQUFHLElBQUksZUFBZSxJQUFJLElBQUk7UUFDaEMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztJQUNULE1BQU0sUUFBUSxHQUFHLEdBQUcsSUFBSSxlQUFlLEtBQUssQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDO0lBQ3RELE9BQU8sT0FBTyxHQUFHLFFBQVEsQ0FBQztBQUM1QixDQUFDO0FBQ0QsTUFBTSxnQkFBZ0IsR0FBRyxDQUFDLFFBQVEsRUFBRSxXQUFXLEVBQUUsT0FBTyxFQUFFLEVBQUU7SUFDMUQsSUFBSSxPQUFPLFFBQVEsS0FBSyxXQUFXLEVBQUUsQ0FBQztRQUNwQyxxREFBcUQ7UUFDckQsTUFBTSxhQUFhLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsV0FBVyxDQUFDO1FBQzlELE1BQU0sSUFBSSxLQUFLLENBQ2IsbUJBQW1CLENBQ2pCLFdBQVcsQ0FBQyxhQUFhLEVBQUUsU0FBUyxFQUFFLEVBQUUsRUFBRSxPQUFPLENBQUM7UUFDbEQsNkNBQTZDO1FBQzdDLHVEQUF1RDtRQUN2RCxpREFBaUQsRUFDakQsYUFBYSxDQUFDLFVBQVUsRUFBRSxRQUFRLEVBQUUsYUFBYSxDQUFDLENBQ25ELENBQ0YsQ0FBQztJQUNKLENBQUM7QUFDSCxDQUFDLENBQUM7QUFFRjs7R0FFRztBQUNILE9BQU8sQ0FBQyxnQkFBZ0IsR0FBRyxnQkFBZ0IsQ0FBQztBQUM1QyxNQUFNLG9CQUFvQixHQUFHLENBQUMsTUFBTSxFQUFFLFdBQVcsRUFBRSxPQUFPLEVBQUUsRUFBRTtJQUM1RCxJQUFJLE9BQU8sTUFBTSxLQUFLLFFBQVEsSUFBSSxPQUFPLE1BQU0sS0FBSyxRQUFRLEVBQUUsQ0FBQztRQUM3RCxxREFBcUQ7UUFDckQsTUFBTSxhQUFhLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsV0FBVyxDQUFDO1FBQzlELE1BQU0sSUFBSSxLQUFLLENBQ2IsbUJBQW1CLENBQ2pCLFdBQVcsQ0FBQyxhQUFhLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxPQUFPLENBQUMsRUFDekQsR0FBRyxjQUFjLENBQUMsVUFBVSxDQUFDLG1DQUFtQyxFQUNoRSxhQUFhLENBQUMsVUFBVSxFQUFFLE1BQU0sRUFBRSxhQUFhLENBQUMsQ0FDakQsQ0FDRixDQUFDO0lBQ0osQ0FBQztBQUNILENBQUMsQ0FBQztBQUVGOztHQUVHO0FBQ0gsT0FBTyxDQUFDLG9CQUFvQixHQUFHLG9CQUFvQixDQUFDO0FBQ3BELE1BQU0sc0JBQXNCLEdBQUcsQ0FBQyxRQUFRLEVBQUUsV0FBVyxFQUFFLE9BQU8sRUFBRSxFQUFFO0lBQ2hFLElBQUksT0FBTyxRQUFRLEtBQUssUUFBUSxJQUFJLE9BQU8sUUFBUSxLQUFLLFFBQVEsRUFBRSxDQUFDO1FBQ2pFLHFEQUFxRDtRQUNyRCxNQUFNLGFBQWEsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxXQUFXLENBQUM7UUFDOUQsTUFBTSxJQUFJLEtBQUssQ0FDYixtQkFBbUIsQ0FDakIsV0FBVyxDQUFDLGFBQWEsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLE9BQU8sQ0FBQyxFQUN6RCxHQUFHLGNBQWMsQ0FBQyxVQUFVLENBQUMsbUNBQW1DLEVBQ2hFLGFBQWEsQ0FBQyxVQUFVLEVBQUUsUUFBUSxFQUFFLGFBQWEsQ0FBQyxDQUNuRCxDQUNGLENBQUM7SUFDSixDQUFDO0FBQ0gsQ0FBQyxDQUFDO0FBRUY7O0dBRUc7QUFDSCxPQUFPLENBQUMsc0JBQXNCLEdBQUcsc0JBQXNCLENBQUM7QUFDeEQsTUFBTSxhQUFhLEdBQUcsQ0FBQyxNQUFNLEVBQUUsUUFBUSxFQUFFLFdBQVcsRUFBRSxPQUFPLEVBQUUsRUFBRTtJQUMvRCxvQkFBb0IsQ0FBQyxNQUFNLEVBQUUsV0FBVyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQ25ELHNCQUFzQixDQUFDLFFBQVEsRUFBRSxXQUFXLEVBQUUsT0FBTyxDQUFDLENBQUM7QUFDekQsQ0FBQyxDQUFDO0FBQ0YsT0FBTyxDQUFDLGFBQWEsR0FBRyxhQUFhLENBQUM7QUFDdEMsTUFBTSxrQ0FBa0MsR0FBRyxDQUFDLFFBQVEsRUFBRSxXQUFXLEVBQUUsT0FBTyxFQUFFLEVBQUU7SUFDNUUsSUFDRSxPQUFPLFFBQVEsS0FBSyxRQUFRO1FBQzVCLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUM7UUFDL0IsUUFBUSxHQUFHLENBQUMsRUFDWixDQUFDO1FBQ0QscURBQXFEO1FBQ3JELE1BQU0sYUFBYSxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLFdBQVcsQ0FBQztRQUM5RCxNQUFNLElBQUksS0FBSyxDQUNiLG1CQUFtQixDQUNqQixXQUFXLENBQUMsYUFBYSxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsT0FBTyxDQUFDLEVBQ3pELEdBQUcsY0FBYyxDQUFDLFVBQVUsQ0FBQyx1Q0FBdUMsRUFDcEUsYUFBYSxDQUFDLFVBQVUsRUFBRSxRQUFRLEVBQUUsYUFBYSxDQUFDLENBQ25ELENBQ0YsQ0FBQztJQUNKLENBQUM7QUFDSCxDQUFDLENBQUM7QUFFRixvREFBb0Q7QUFDcEQsOEJBQThCO0FBQzlCLHFEQUFxRDtBQUNyRCxxREFBcUQ7QUFDckQsK0RBQStEO0FBQy9ELE9BQU8sQ0FBQyxrQ0FBa0MsR0FBRyxrQ0FBa0MsQ0FBQztBQUNoRixNQUFNLDZCQUE2QixHQUFHLENBQUMsS0FBSyxFQUFFLEVBQUUsRUFBRSxhQUFhLEVBQUUsRUFBRSxDQUNqRSxLQUFLLENBQUMsTUFBTSxDQUNWLENBQUMsT0FBTyxFQUFFLElBQUksRUFBRSxFQUFFLENBQ2hCLE9BQU87SUFDUCxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxTQUFTLENBQUMsVUFBVTtRQUMvQixDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztRQUNULENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRTtZQUNoQixDQUFDLENBQUMsRUFBRTtZQUNKLENBQUMsQ0FBQyxhQUFhO2dCQUNmLENBQUMsQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUN6QixDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQ2QsRUFBRSxDQUNILENBQUM7QUFDSixNQUFNLGNBQWMsR0FBRyxDQUFDLFFBQVEsRUFBRSxRQUFRLEVBQUUsRUFBRTtJQUM1QyxNQUFNLFlBQVksR0FBRyxDQUFDLENBQUMsRUFBRSxZQUFZLENBQUMsT0FBTyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDekQsTUFBTSxZQUFZLEdBQUcsQ0FBQyxDQUFDLEVBQUUsWUFBWSxDQUFDLE9BQU8sQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3pELElBQUksWUFBWSxLQUFLLFlBQVksRUFBRSxDQUFDO1FBQ2xDLE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUNELElBQUksQ0FBQyxDQUFDLEVBQUUsWUFBWSxDQUFDLFdBQVcsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUM7UUFDNUMsNENBQTRDO1FBQzVDLCtCQUErQjtRQUMvQiw0Q0FBNEM7UUFDNUMsT0FBTyxDQUNMLE9BQU8sUUFBUSxLQUFLLFFBQVE7WUFDNUIsT0FBTyxRQUFRLEtBQUssUUFBUTtZQUM1QixRQUFRLENBQUMsTUFBTSxLQUFLLENBQUM7WUFDckIsUUFBUSxDQUFDLE1BQU0sS0FBSyxDQUFDO1lBQ3JCLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLGdCQUFnQixDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUNyRSxDQUFDO0lBQ0osQ0FBQztJQUNELElBQ0UsWUFBWSxLQUFLLE1BQU07UUFDdkIsWUFBWSxLQUFLLFVBQVU7UUFDM0IsWUFBWSxLQUFLLFFBQVEsRUFDekIsQ0FBQztRQUNELE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUNELElBQUksUUFBUSxZQUFZLEtBQUssSUFBSSxRQUFRLFlBQVksS0FBSyxFQUFFLENBQUM7UUFDM0QsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBQ0QsSUFDRSxZQUFZLEtBQUssUUFBUTtRQUN6QixPQUFPLFFBQVEsQ0FBQyxlQUFlLEtBQUssVUFBVSxFQUM5QyxDQUFDO1FBQ0QsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBQ0QsT0FBTyxJQUFJLENBQUM7QUFDZCxDQUFDLENBQUM7QUFDRixNQUFNLHNCQUFzQixHQUFHLEtBQUssQ0FBQztBQUNyQyxNQUFNLG9CQUFvQixHQUFHLENBQzNCLFFBQVEsRUFDUixRQUFRLEVBQ1IsYUFBYSxFQUNiLGFBQWEsRUFDYixNQUFNLENBQUMsNERBQTREO0VBQ25FLEVBQUU7SUFDRixJQUNFLE9BQU8sUUFBUSxLQUFLLFFBQVE7UUFDNUIsT0FBTyxRQUFRLEtBQUssUUFBUTtRQUM1QixRQUFRLENBQUMsTUFBTSxLQUFLLENBQUM7UUFDckIsUUFBUSxDQUFDLE1BQU0sS0FBSyxDQUFDO1FBQ3JCLFFBQVEsQ0FBQyxNQUFNLElBQUksc0JBQXNCO1FBQ3pDLFFBQVEsQ0FBQyxNQUFNLElBQUksc0JBQXNCO1FBQ3pDLFFBQVEsS0FBSyxRQUFRLEVBQ3JCLENBQUM7UUFDRCxJQUFJLFFBQVEsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksUUFBUSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDO1lBQ3ZELE9BQU8sQ0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDLGtCQUFrQixDQUFDLENBQUMsUUFBUSxFQUFFLFFBQVEsRUFBRTtnQkFDM0QsV0FBVyxFQUFFLGFBQWE7Z0JBQzFCLFdBQVcsRUFBRSxhQUFhO2dCQUMxQiw0QkFBNEIsRUFBRSxNQUFNLENBQUMsT0FBTyxDQUFDLFFBQVE7Z0JBQ3JELDRCQUE0QixFQUFFLE1BQU0sQ0FBQyxPQUFPLENBQUMsUUFBUTtnQkFDckQsK0JBQStCLEVBQUUsR0FBRztnQkFDcEMsU0FBUztnQkFDVCxNQUFNO2dCQUNOLG1CQUFtQixFQUFFLElBQUk7YUFDMUIsQ0FBQyxDQUFDO1FBQ0wsQ0FBQztRQUNELE1BQU0sS0FBSyxHQUFHLENBQUMsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxjQUFjLENBQUMsQ0FBQyxRQUFRLEVBQUUsUUFBUSxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQ3RFLE1BQU0sYUFBYSxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUssU0FBUyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQzNFLE1BQU0sVUFBVSxHQUFHLGVBQWUsQ0FBQyxhQUFhLEVBQUUsYUFBYSxDQUFDLENBQUM7UUFDakUsTUFBTSxZQUFZLEdBQ2hCLFVBQVUsQ0FBQyxhQUFhLENBQUM7WUFDekIsYUFBYSxDQUNYLDZCQUE2QixDQUMzQixLQUFLLEVBQ0wsU0FBUyxDQUFDLFdBQVcsRUFDckIsYUFBYSxDQUNkLENBQ0YsQ0FBQztRQUNKLE1BQU0sWUFBWSxHQUNoQixVQUFVLENBQUMsYUFBYSxDQUFDO1lBQ3pCLGFBQWEsQ0FDWCw2QkFBNkIsQ0FDM0IsS0FBSyxFQUNMLFNBQVMsQ0FBQyxXQUFXLEVBQ3JCLGFBQWEsQ0FDZCxDQUNGLENBQUM7UUFDSixPQUFPLEdBQUcsWUFBWSxLQUFLLFlBQVksRUFBRSxDQUFDO0lBQzVDLENBQUM7SUFDRCxJQUFJLGNBQWMsQ0FBQyxRQUFRLEVBQUUsUUFBUSxDQUFDLEVBQUUsQ0FBQztRQUN2QyxNQUFNLEVBQUMsZ0JBQWdCLEVBQUUsZ0JBQWdCLEVBQUMsR0FDeEMsaUNBQWlDLENBQUMsUUFBUSxFQUFFLFFBQVEsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDaEUsTUFBTSxVQUFVLEdBQUcsQ0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLGdCQUFnQixFQUFFLGdCQUFnQixFQUFFO1lBQ3pFLFdBQVcsRUFBRSxhQUFhO1lBQzFCLFdBQVcsRUFBRSxhQUFhO1lBQzFCLE1BQU07WUFDTixtQkFBbUIsRUFBRSxJQUFJO1NBQzFCLENBQUMsQ0FBQztRQUNILElBQ0UsT0FBTyxVQUFVLEtBQUssUUFBUTtZQUM5QixVQUFVLENBQUMsUUFBUSxDQUFDLEtBQUssYUFBYSxFQUFFLENBQUM7WUFDekMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxLQUFLLGFBQWEsRUFBRSxDQUFDLEVBQ3pDLENBQUM7WUFDRCxPQUFPLFVBQVUsQ0FBQztRQUNwQixDQUFDO0lBQ0gsQ0FBQztJQUNELE1BQU0sVUFBVSxHQUFHLGVBQWUsQ0FBQyxhQUFhLEVBQUUsYUFBYSxDQUFDLENBQUM7SUFDakUsTUFBTSxZQUFZLEdBQUcsVUFBVSxDQUFDLGFBQWEsQ0FBQyxHQUFHLGFBQWEsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUN6RSxNQUFNLFlBQVksR0FDaEIsVUFBVSxDQUFDLGFBQWEsQ0FBQztRQUN6QixDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsS0FBSyxTQUFTLENBQUMsUUFBUSxDQUFDO1lBQzFDLENBQUMsQ0FBQywrQkFBK0I7WUFDakMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO0lBQy9CLE9BQU8sR0FBRyxZQUFZLEtBQUssWUFBWSxFQUFFLENBQUM7QUFDNUMsQ0FBQyxDQUFDO0FBRUYsd0VBQXdFO0FBQ3hFLHNGQUFzRjtBQUN0Rix1RkFBdUY7QUFDdkYsT0FBTyxDQUFDLG9CQUFvQixHQUFHLG9CQUFvQixDQUFDO0FBQ3BELE1BQU0sZUFBZSxHQUFHLENBQUMsTUFBTSxFQUFFLFFBQVEsRUFBRSxFQUFFO0lBQzNDLElBQUksT0FBTyxNQUFNLEtBQUssUUFBUSxJQUFJLE9BQU8sUUFBUSxLQUFLLFFBQVEsRUFBRSxDQUFDO1FBQy9ELE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUNELElBQUksT0FBTyxNQUFNLEtBQUssUUFBUSxJQUFJLE9BQU8sUUFBUSxLQUFLLFFBQVEsRUFBRSxDQUFDO1FBQy9ELE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUNELElBQUksT0FBTyxNQUFNLEtBQUssU0FBUyxJQUFJLE9BQU8sUUFBUSxLQUFLLFNBQVMsRUFBRSxDQUFDO1FBQ2pFLE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUNELE9BQU8sSUFBSSxDQUFDO0FBQ2QsQ0FBQyxDQUFDO0FBQ0YsU0FBUyxpQ0FBaUMsQ0FDeEMsZ0JBQWdCLEVBQ2hCLGdCQUFnQixFQUNoQixjQUFjLEVBQ2QsY0FBYztJQUVkLE9BQU8sa0NBQWtDLENBQ3ZDLENBQUMsQ0FBQyxFQUFFLDBCQUEwQixDQUFDLE9BQU8sQ0FBQyxDQUFDLGdCQUFnQixDQUFDLEVBQ3pELENBQUMsQ0FBQyxFQUFFLDBCQUEwQixDQUFDLE9BQU8sQ0FBQyxDQUFDLGdCQUFnQixDQUFDLEVBQ3pELGNBQWMsRUFDZCxjQUFjLENBQ2YsQ0FBQztBQUNKLENBQUM7QUFDRCxTQUFTLGtDQUFrQyxDQUN6QyxnQkFBZ0IsRUFDaEIsZ0JBQWdCLEVBQ2hCLGNBQWMsRUFDZCxjQUFjO0lBRWQsSUFBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLGdCQUFnQixFQUFFLGdCQUFnQixDQUFDLEVBQUUsQ0FBQztRQUM1RSxPQUFPO1lBQ0wsZ0JBQWdCO1lBQ2hCLGdCQUFnQjtTQUNqQixDQUFDO0lBQ0osQ0FBQztJQUNELElBQ0UsY0FBYyxDQUFDLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQztRQUN6QyxjQUFjLENBQUMsUUFBUSxDQUFDLGdCQUFnQixDQUFDLEVBQ3pDLENBQUM7UUFDRCxPQUFPO1lBQ0wsZ0JBQWdCO1lBQ2hCLGdCQUFnQjtTQUNqQixDQUFDO0lBQ0osQ0FBQztJQUNELGNBQWMsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztJQUN0QyxjQUFjLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUM7SUFDdEMsTUFBTSxtQkFBbUIsR0FBRyxJQUFJLFlBQVksQ0FBQyxPQUFPLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztJQUN2RSxNQUFNLG1CQUFtQixHQUFHLElBQUksWUFBWSxDQUFDLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO0lBQ3ZFLG1CQUFtQixDQUFDLE9BQU8sQ0FBQyxDQUFDLGFBQWEsRUFBRSxHQUFHLEVBQUUsRUFBRTtRQUNqRCxNQUFNLGFBQWEsR0FBRyxtQkFBbUIsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDbkQsSUFBSSxtQkFBbUIsQ0FBQyxhQUFhLENBQUMsRUFBRSxDQUFDO1lBQ3ZDLElBQUksYUFBYSxDQUFDLGVBQWUsQ0FBQyxhQUFhLENBQUMsRUFBRSxDQUFDO2dCQUNqRCxtQkFBbUIsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLGFBQWEsQ0FBQyxDQUFDO1lBQzlDLENBQUM7UUFDSCxDQUFDO2FBQU0sSUFBSSxtQkFBbUIsQ0FBQyxhQUFhLENBQUMsRUFBRSxDQUFDO1lBQzlDLElBQUksYUFBYSxDQUFDLGVBQWUsQ0FBQyxhQUFhLENBQUMsRUFBRSxDQUFDO2dCQUNqRCxtQkFBbUIsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLGFBQWEsQ0FBQyxDQUFDO1lBQzlDLENBQUM7UUFDSCxDQUFDO2FBQU0sSUFDTCxZQUFZLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxhQUFhLEVBQUUsYUFBYSxDQUFDLEVBQ2hFLENBQUM7WUFDRCxNQUFNLFFBQVEsR0FBRyxrQ0FBa0MsQ0FDakQsYUFBYSxFQUNiLGFBQWEsRUFDYixjQUFjLEVBQ2QsY0FBYyxDQUNmLENBQUM7WUFDRixtQkFBbUIsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1lBQ3hELG1CQUFtQixDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsUUFBUSxDQUFDLGdCQUFnQixDQUFDLENBQUM7UUFDMUQsQ0FBQztJQUNILENBQUMsQ0FBQyxDQUFDO0lBQ0gsT0FBTztRQUNMLGdCQUFnQixFQUFFLG1CQUFtQixDQUFDLE1BQU07UUFDNUMsZ0JBQWdCLEVBQUUsbUJBQW1CLENBQUMsTUFBTTtLQUM3QyxDQUFDO0FBQ0osQ0FBQztBQUNELFNBQVMsbUJBQW1CLENBQUMsSUFBSTtJQUMvQixNQUFNLElBQUksR0FBRyxDQUFDLENBQUMsRUFBRSxZQUFZLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDN0MsT0FBTyxJQUFJLEtBQUssUUFBUSxJQUFJLE9BQU8sSUFBSSxDQUFDLGVBQWUsS0FBSyxVQUFVLENBQUM7QUFDekUsQ0FBQztBQUNELE1BQU0sSUFBSSxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxPQUFPLEVBQUUsRUFBRSxDQUM3QixlQUFlLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO0FBQ3BFLE9BQU8sQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO0FBQ3BCLE1BQU0sU0FBUyxHQUFHLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxFQUFFLENBQ2hDLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxJQUFJLEtBQUssSUFBSSxJQUFJLEdBQUcsS0FBSyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztBQUVoRSw4RUFBOEU7QUFDOUUsb0RBQW9EO0FBQ3BELDhEQUE4RDtBQUM5RCxzRUFBc0U7QUFDdEUsT0FBTyxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUM7QUFDOUIsTUFBTSxlQUFlLEdBQUcsQ0FBQyxHQUFHLE9BQU8sRUFBRSxFQUFFO0lBQ3JDLE1BQU0sU0FBUyxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQzlCLENBQUMsR0FBRyxFQUFFLE1BQU0sRUFBRSxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsTUFBTSxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQzVELENBQUMsQ0FDRixDQUFDO0lBQ0YsT0FBTyxNQUFNLENBQUMsRUFBRSxDQUFDLEdBQUcsTUFBTSxLQUFLLEdBQUcsQ0FBQyxNQUFNLENBQUMsU0FBUyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDO0FBQ3pFLENBQUMsQ0FBQztBQUNGLE9BQU8sQ0FBQyxlQUFlLEdBQUcsZUFBZSxDQUFDO0FBQzFDLE1BQU0sbUJBQW1CLEdBQUcsQ0FDMUIsSUFBSSxFQUNKLE9BQU8sRUFDUCxRQUFRLENBQUMsc0RBQXNEO0VBQy9ELEVBQUUsQ0FDRixHQUFHLElBQUksT0FBTyxNQUFNLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsS0FBSyxPQUFPLEdBQzVELE9BQU8sUUFBUSxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUMsT0FBTyxRQUFRLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFDckQsRUFBRSxDQUFDO0FBRUwsc0RBQXNEO0FBQ3RELHVFQUF1RTtBQUN2RSx5Q0FBeUM7QUFDekMsT0FBTyxDQUFDLG1CQUFtQixHQUFHLG1CQUFtQixDQUFDO0FBQ2xELE1BQU0sV0FBVyxHQUFHLENBQ2xCLFdBQVcsRUFDWCxRQUFRLEdBQUcsVUFBVSxFQUNyQixRQUFRLEdBQUcsVUFBVSxFQUNyQixPQUFPLEdBQUcsRUFBRSxFQUNaLEVBQUU7SUFDRixNQUFNLEVBQ0osT0FBTyxHQUFHLEVBQUUsRUFDWixhQUFhLEdBQUcsY0FBYyxFQUM5QixrQkFBa0IsR0FBRyxLQUFLO0lBQzFCLHVDQUF1QztJQUN2QyxLQUFLLEdBQUcsS0FBSyxFQUNiLE9BQU8sR0FBRyxFQUFFLEVBQ1osYUFBYSxHQUFHLGNBQWMsRUFDOUIsY0FBYyxHQUFHLEVBQUUsRUFDbkIsbUJBQW1CLEdBQUcsY0FBYyxFQUNyQyxHQUFHLE9BQU8sQ0FBQztJQUNaLElBQUksSUFBSSxHQUFHLEVBQUUsQ0FBQztJQUNkLElBQUksU0FBUyxHQUFHLFFBQVEsQ0FBQyxDQUFDLHNDQUFzQztJQUVoRSxJQUFJLENBQUMsa0JBQWtCLElBQUksUUFBUSxLQUFLLEVBQUUsRUFBRSxDQUFDO1FBQzNDLElBQUksSUFBSSxTQUFTLENBQUMsR0FBRyxTQUFTLEdBQUcsQ0FBQyxHQUFHLGFBQWEsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUM3RCxTQUFTLEdBQUcsR0FBRyxDQUFDO0lBQ2xCLENBQUM7SUFDRCxJQUFJLE9BQU8sS0FBSyxFQUFFLEVBQUUsQ0FBQztRQUNuQixJQUFJLElBQUksU0FBUyxDQUFDLEdBQUcsU0FBUyxHQUFHLENBQUMsR0FBRyxPQUFPLENBQUM7UUFDN0MsU0FBUyxHQUFHLEVBQUUsQ0FBQztJQUNqQixDQUFDO0lBQ0QsSUFBSSxLQUFLLEVBQUUsQ0FBQztRQUNWLElBQUksSUFBSSxHQUFHLFNBQVMsQ0FBQyxHQUFHLFNBQVMsR0FBRyxDQUFDLEtBQUssQ0FBQztRQUMzQyxTQUFTLEdBQUcsRUFBRSxDQUFDO0lBQ2pCLENBQUM7SUFDRCxJQUFJLFdBQVcsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQztRQUM5QiwwQ0FBMEM7UUFDMUMsOENBQThDO1FBQzlDLFNBQVMsSUFBSSxXQUFXLENBQUM7SUFDM0IsQ0FBQztTQUFNLENBQUM7UUFDTiwrQ0FBK0M7UUFDL0MsSUFBSSxJQUFJLFNBQVMsQ0FBQyxHQUFHLFNBQVMsR0FBRyxDQUFDLEdBQUcsV0FBVyxDQUFDO1FBQ2pELFNBQVMsR0FBRyxFQUFFLENBQUM7SUFDakIsQ0FBQztJQUNELElBQUksUUFBUSxLQUFLLEVBQUUsRUFBRSxDQUFDO1FBQ3BCLFNBQVMsSUFBSSxJQUFJLENBQUM7SUFDcEIsQ0FBQztTQUFNLENBQUM7UUFDTixJQUFJLElBQUksU0FBUyxDQUFDLEdBQUcsU0FBUyxHQUFHLENBQUMsR0FBRyxhQUFhLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDN0QsSUFBSSxjQUFjLEVBQUUsQ0FBQztZQUNuQixJQUFJLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxHQUFHLG1CQUFtQixDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBQ2hFLENBQUM7UUFDRCxTQUFTLEdBQUcsR0FBRyxDQUFDO0lBQ2xCLENBQUM7SUFDRCxJQUFJLE9BQU8sS0FBSyxFQUFFLEVBQUUsQ0FBQztRQUNuQixTQUFTLElBQUksT0FBTyxPQUFPLEVBQUUsQ0FBQztJQUNoQyxDQUFDO0lBQ0QsSUFBSSxTQUFTLEtBQUssRUFBRSxFQUFFLENBQUM7UUFDckIsSUFBSSxJQUFJLFNBQVMsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUMvQixDQUFDO0lBQ0QsT0FBTyxJQUFJLENBQUM7QUFDZCxDQUFDLENBQUM7QUFDRixPQUFPLENBQUMsV0FBVyxHQUFHLFdBQVcsQ0FBQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJEOlxcUHJvamVjdHNcXENhcmRFdmVyeXRoaW5nXFxjYXJkYWxsLXByb3RvdHlwZVxcbm9kZV9tb2R1bGVzXFxqZXN0LWF4ZVxcbm9kZV9tb2R1bGVzXFxqZXN0LW1hdGNoZXItdXRpbHNcXGJ1aWxkXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5wcmludFJlY2VpdmVkID1cbiAgZXhwb3J0cy5wcmludEV4cGVjdGVkID1cbiAgZXhwb3J0cy5wcmludERpZmZPclN0cmluZ2lmeSA9XG4gIGV4cG9ydHMucGx1cmFsaXplID1cbiAgZXhwb3J0cy5tYXRjaGVySGludCA9XG4gIGV4cG9ydHMubWF0Y2hlckVycm9yTWVzc2FnZSA9XG4gIGV4cG9ydHMuaGlnaGxpZ2h0VHJhaWxpbmdXaGl0ZXNwYWNlID1cbiAgZXhwb3J0cy5nZXRMYWJlbFByaW50ZXIgPVxuICBleHBvcnRzLmVuc3VyZU51bWJlcnMgPVxuICBleHBvcnRzLmVuc3VyZU5vRXhwZWN0ZWQgPVxuICBleHBvcnRzLmVuc3VyZUV4cGVjdGVkSXNOdW1iZXIgPVxuICBleHBvcnRzLmVuc3VyZUV4cGVjdGVkSXNOb25OZWdhdGl2ZUludGVnZXIgPVxuICBleHBvcnRzLmVuc3VyZUFjdHVhbElzTnVtYmVyID1cbiAgZXhwb3J0cy5kaWZmID1cbiAgZXhwb3J0cy5TVUdHRVNUX1RPX0NPTlRBSU5fRVFVQUwgPVxuICBleHBvcnRzLlJFQ0VJVkVEX0NPTE9SID1cbiAgZXhwb3J0cy5JTlZFUlRFRF9DT0xPUiA9XG4gIGV4cG9ydHMuRVhQRUNURURfQ09MT1IgPVxuICBleHBvcnRzLkRJTV9DT0xPUiA9XG4gIGV4cG9ydHMuQk9MRF9XRUlHSFQgPVxuICAgIHZvaWQgMDtcbmV4cG9ydHMucHJpbnRXaXRoVHlwZSA9IHByaW50V2l0aFR5cGU7XG5leHBvcnRzLnJlcGxhY2VNYXRjaGVkVG9Bc3ltbWV0cmljTWF0Y2hlciA9IHJlcGxhY2VNYXRjaGVkVG9Bc3ltbWV0cmljTWF0Y2hlcjtcbmV4cG9ydHMuc3RyaW5naWZ5ID0gdm9pZCAwO1xudmFyIF9jaGFsayA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZSgnY2hhbGsnKSk7XG52YXIgX2plc3REaWZmID0gcmVxdWlyZSgnamVzdC1kaWZmJyk7XG52YXIgX2plc3RHZXRUeXBlID0gcmVxdWlyZSgnamVzdC1nZXQtdHlwZScpO1xudmFyIF9wcmV0dHlGb3JtYXQgPSByZXF1aXJlKCdwcmV0dHktZm9ybWF0Jyk7XG52YXIgX1JlcGxhY2VhYmxlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKCcuL1JlcGxhY2VhYmxlJykpO1xudmFyIF9kZWVwQ3ljbGljQ29weVJlcGxhY2VhYmxlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChcbiAgcmVxdWlyZSgnLi9kZWVwQ3ljbGljQ29weVJlcGxhY2VhYmxlJylcbik7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge2RlZmF1bHQ6IG9ian07XG59XG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIGxvY2FsL2Jhbi10eXBlcy1ldmVudHVhbGx5ICovXG5cbmNvbnN0IHtcbiAgQXN5bW1ldHJpY01hdGNoZXIsXG4gIERPTUNvbGxlY3Rpb24sXG4gIERPTUVsZW1lbnQsXG4gIEltbXV0YWJsZSxcbiAgUmVhY3RFbGVtZW50LFxuICBSZWFjdFRlc3RDb21wb25lbnRcbn0gPSBfcHJldHR5Rm9ybWF0LnBsdWdpbnM7XG5jb25zdCBQTFVHSU5TID0gW1xuICBSZWFjdFRlc3RDb21wb25lbnQsXG4gIFJlYWN0RWxlbWVudCxcbiAgRE9NRWxlbWVudCxcbiAgRE9NQ29sbGVjdGlvbixcbiAgSW1tdXRhYmxlLFxuICBBc3ltbWV0cmljTWF0Y2hlclxuXTtcbmNvbnN0IEVYUEVDVEVEX0NPTE9SID0gX2NoYWxrLmRlZmF1bHQuZ3JlZW47XG5leHBvcnRzLkVYUEVDVEVEX0NPTE9SID0gRVhQRUNURURfQ09MT1I7XG5jb25zdCBSRUNFSVZFRF9DT0xPUiA9IF9jaGFsay5kZWZhdWx0LnJlZDtcbmV4cG9ydHMuUkVDRUlWRURfQ09MT1IgPSBSRUNFSVZFRF9DT0xPUjtcbmNvbnN0IElOVkVSVEVEX0NPTE9SID0gX2NoYWxrLmRlZmF1bHQuaW52ZXJzZTtcbmV4cG9ydHMuSU5WRVJURURfQ09MT1IgPSBJTlZFUlRFRF9DT0xPUjtcbmNvbnN0IEJPTERfV0VJR0hUID0gX2NoYWxrLmRlZmF1bHQuYm9sZDtcbmV4cG9ydHMuQk9MRF9XRUlHSFQgPSBCT0xEX1dFSUdIVDtcbmNvbnN0IERJTV9DT0xPUiA9IF9jaGFsay5kZWZhdWx0LmRpbTtcbmV4cG9ydHMuRElNX0NPTE9SID0gRElNX0NPTE9SO1xuY29uc3QgTVVMVElMSU5FX1JFR0VYUCA9IC9cXG4vO1xuY29uc3QgU1BBQ0VfU1lNQk9MID0gJ1xcdXswMEI3fSc7IC8vIG1pZGRsZSBkb3RcblxuY29uc3QgTlVNQkVSUyA9IFtcbiAgJ3plcm8nLFxuICAnb25lJyxcbiAgJ3R3bycsXG4gICd0aHJlZScsXG4gICdmb3VyJyxcbiAgJ2ZpdmUnLFxuICAnc2l4JyxcbiAgJ3NldmVuJyxcbiAgJ2VpZ2h0JyxcbiAgJ25pbmUnLFxuICAndGVuJyxcbiAgJ2VsZXZlbicsXG4gICd0d2VsdmUnLFxuICAndGhpcnRlZW4nXG5dO1xuY29uc3QgU1VHR0VTVF9UT19DT05UQUlOX0VRVUFMID0gX2NoYWxrLmRlZmF1bHQuZGltKFxuICAnTG9va3MgbGlrZSB5b3Ugd2FudGVkIHRvIHRlc3QgZm9yIG9iamVjdC9hcnJheSBlcXVhbGl0eSB3aXRoIHRoZSBzdHJpY3RlciBgdG9Db250YWluYCBtYXRjaGVyLiBZb3UgcHJvYmFibHkgbmVlZCB0byB1c2UgYHRvQ29udGFpbkVxdWFsYCBpbnN0ZWFkLidcbik7XG5leHBvcnRzLlNVR0dFU1RfVE9fQ09OVEFJTl9FUVVBTCA9IFNVR0dFU1RfVE9fQ09OVEFJTl9FUVVBTDtcbmNvbnN0IHN0cmluZ2lmeSA9IChvYmplY3QsIG1heERlcHRoID0gMTAsIG1heFdpZHRoID0gMTApID0+IHtcbiAgY29uc3QgTUFYX0xFTkdUSCA9IDEwMDAwO1xuICBsZXQgcmVzdWx0O1xuICB0cnkge1xuICAgIHJlc3VsdCA9ICgwLCBfcHJldHR5Rm9ybWF0LmZvcm1hdCkob2JqZWN0LCB7XG4gICAgICBtYXhEZXB0aCxcbiAgICAgIG1heFdpZHRoLFxuICAgICAgbWluOiB0cnVlLFxuICAgICAgcGx1Z2luczogUExVR0lOU1xuICAgIH0pO1xuICB9IGNhdGNoIHtcbiAgICByZXN1bHQgPSAoMCwgX3ByZXR0eUZvcm1hdC5mb3JtYXQpKG9iamVjdCwge1xuICAgICAgY2FsbFRvSlNPTjogZmFsc2UsXG4gICAgICBtYXhEZXB0aCxcbiAgICAgIG1heFdpZHRoLFxuICAgICAgbWluOiB0cnVlLFxuICAgICAgcGx1Z2luczogUExVR0lOU1xuICAgIH0pO1xuICB9XG4gIGlmIChyZXN1bHQubGVuZ3RoID49IE1BWF9MRU5HVEggJiYgbWF4RGVwdGggPiAxKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeShvYmplY3QsIE1hdGguZmxvb3IobWF4RGVwdGggLyAyKSwgbWF4V2lkdGgpO1xuICB9IGVsc2UgaWYgKHJlc3VsdC5sZW5ndGggPj0gTUFYX0xFTkdUSCAmJiBtYXhXaWR0aCA+IDEpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5KG9iamVjdCwgbWF4RGVwdGgsIE1hdGguZmxvb3IobWF4V2lkdGggLyAyKSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcbmV4cG9ydHMuc3RyaW5naWZ5ID0gc3RyaW5naWZ5O1xuY29uc3QgaGlnaGxpZ2h0VHJhaWxpbmdXaGl0ZXNwYWNlID0gdGV4dCA9PlxuICB0ZXh0LnJlcGxhY2UoL1xccyskL2dtLCBfY2hhbGsuZGVmYXVsdC5pbnZlcnNlKCckJicpKTtcblxuLy8gSW5zdGVhZCBvZiBpbnZlcnNlIGhpZ2hsaWdodCB3aGljaCBub3cgaW1wbGllcyBhIGNoYW5nZSxcbi8vIHJlcGxhY2UgY29tbW9uIHNwYWNlcyB3aXRoIG1pZGRsZSBkb3QgYXQgdGhlIGVuZCBvZiBhbnkgbGluZS5cbmV4cG9ydHMuaGlnaGxpZ2h0VHJhaWxpbmdXaGl0ZXNwYWNlID0gaGlnaGxpZ2h0VHJhaWxpbmdXaGl0ZXNwYWNlO1xuY29uc3QgcmVwbGFjZVRyYWlsaW5nU3BhY2VzID0gdGV4dCA9PlxuICB0ZXh0LnJlcGxhY2UoL1xccyskL2dtLCBzcGFjZXMgPT4gU1BBQ0VfU1lNQk9MLnJlcGVhdChzcGFjZXMubGVuZ3RoKSk7XG5jb25zdCBwcmludFJlY2VpdmVkID0gb2JqZWN0ID0+XG4gIFJFQ0VJVkVEX0NPTE9SKHJlcGxhY2VUcmFpbGluZ1NwYWNlcyhzdHJpbmdpZnkob2JqZWN0KSkpO1xuZXhwb3J0cy5wcmludFJlY2VpdmVkID0gcHJpbnRSZWNlaXZlZDtcbmNvbnN0IHByaW50RXhwZWN0ZWQgPSB2YWx1ZSA9PlxuICBFWFBFQ1RFRF9DT0xPUihyZXBsYWNlVHJhaWxpbmdTcGFjZXMoc3RyaW5naWZ5KHZhbHVlKSkpO1xuZXhwb3J0cy5wcmludEV4cGVjdGVkID0gcHJpbnRFeHBlY3RlZDtcbmZ1bmN0aW9uIHByaW50V2l0aFR5cGUobmFtZSwgdmFsdWUsIHByaW50KSB7XG4gIGNvbnN0IHR5cGUgPSAoMCwgX2plc3RHZXRUeXBlLmdldFR5cGUpKHZhbHVlKTtcbiAgY29uc3QgaGFzVHlwZSA9XG4gICAgdHlwZSAhPT0gJ251bGwnICYmIHR5cGUgIT09ICd1bmRlZmluZWQnXG4gICAgICA/IGAke25hbWV9IGhhcyB0eXBlOiAgJHt0eXBlfVxcbmBcbiAgICAgIDogJyc7XG4gIGNvbnN0IGhhc1ZhbHVlID0gYCR7bmFtZX0gaGFzIHZhbHVlOiAke3ByaW50KHZhbHVlKX1gO1xuICByZXR1cm4gaGFzVHlwZSArIGhhc1ZhbHVlO1xufVxuY29uc3QgZW5zdXJlTm9FeHBlY3RlZCA9IChleHBlY3RlZCwgbWF0Y2hlck5hbWUsIG9wdGlvbnMpID0+IHtcbiAgaWYgKHR5cGVvZiBleHBlY3RlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBQcmVwZW5kIG1heWJlIG5vdCBvbmx5IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxuICAgIGNvbnN0IG1hdGNoZXJTdHJpbmcgPSAob3B0aW9ucyA/ICcnIDogJ1subm90XScpICsgbWF0Y2hlck5hbWU7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgbWF0Y2hlckVycm9yTWVzc2FnZShcbiAgICAgICAgbWF0Y2hlckhpbnQobWF0Y2hlclN0cmluZywgdW5kZWZpbmVkLCAnJywgb3B0aW9ucyksXG4gICAgICAgIC8vIEJlY2F1c2UgZXhwZWN0ZWQgaXMgb21pdHRlZCBpbiBoaW50IGFib3ZlLFxuICAgICAgICAvLyBleHBlY3RlZCBpcyBibGFjayBpbnN0ZWFkIG9mIGdyZWVuIGluIG1lc3NhZ2UgYmVsb3cuXG4gICAgICAgICd0aGlzIG1hdGNoZXIgbXVzdCBub3QgaGF2ZSBhbiBleHBlY3RlZCBhcmd1bWVudCcsXG4gICAgICAgIHByaW50V2l0aFR5cGUoJ0V4cGVjdGVkJywgZXhwZWN0ZWQsIHByaW50RXhwZWN0ZWQpXG4gICAgICApXG4gICAgKTtcbiAgfVxufTtcblxuLyoqXG4gKiBFbnN1cmVzIHRoYXQgYGFjdHVhbGAgaXMgb2YgdHlwZSBgbnVtYmVyIHwgYmlnaW50YFxuICovXG5leHBvcnRzLmVuc3VyZU5vRXhwZWN0ZWQgPSBlbnN1cmVOb0V4cGVjdGVkO1xuY29uc3QgZW5zdXJlQWN0dWFsSXNOdW1iZXIgPSAoYWN0dWFsLCBtYXRjaGVyTmFtZSwgb3B0aW9ucykgPT4ge1xuICBpZiAodHlwZW9mIGFjdHVhbCAhPT0gJ251bWJlcicgJiYgdHlwZW9mIGFjdHVhbCAhPT0gJ2JpZ2ludCcpIHtcbiAgICAvLyBQcmVwZW5kIG1heWJlIG5vdCBvbmx5IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxuICAgIGNvbnN0IG1hdGNoZXJTdHJpbmcgPSAob3B0aW9ucyA/ICcnIDogJ1subm90XScpICsgbWF0Y2hlck5hbWU7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgbWF0Y2hlckVycm9yTWVzc2FnZShcbiAgICAgICAgbWF0Y2hlckhpbnQobWF0Y2hlclN0cmluZywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG9wdGlvbnMpLFxuICAgICAgICBgJHtSRUNFSVZFRF9DT0xPUigncmVjZWl2ZWQnKX0gdmFsdWUgbXVzdCBiZSBhIG51bWJlciBvciBiaWdpbnRgLFxuICAgICAgICBwcmludFdpdGhUeXBlKCdSZWNlaXZlZCcsIGFjdHVhbCwgcHJpbnRSZWNlaXZlZClcbiAgICAgIClcbiAgICApO1xuICB9XG59O1xuXG4vKipcbiAqIEVuc3VyZXMgdGhhdCBgZXhwZWN0ZWRgIGlzIG9mIHR5cGUgYG51bWJlciB8IGJpZ2ludGBcbiAqL1xuZXhwb3J0cy5lbnN1cmVBY3R1YWxJc051bWJlciA9IGVuc3VyZUFjdHVhbElzTnVtYmVyO1xuY29uc3QgZW5zdXJlRXhwZWN0ZWRJc051bWJlciA9IChleHBlY3RlZCwgbWF0Y2hlck5hbWUsIG9wdGlvbnMpID0+IHtcbiAgaWYgKHR5cGVvZiBleHBlY3RlZCAhPT0gJ251bWJlcicgJiYgdHlwZW9mIGV4cGVjdGVkICE9PSAnYmlnaW50Jykge1xuICAgIC8vIFByZXBlbmQgbWF5YmUgbm90IG9ubHkgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXG4gICAgY29uc3QgbWF0Y2hlclN0cmluZyA9IChvcHRpb25zID8gJycgOiAnWy5ub3RdJykgKyBtYXRjaGVyTmFtZTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBtYXRjaGVyRXJyb3JNZXNzYWdlKFxuICAgICAgICBtYXRjaGVySGludChtYXRjaGVyU3RyaW5nLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgb3B0aW9ucyksXG4gICAgICAgIGAke0VYUEVDVEVEX0NPTE9SKCdleHBlY3RlZCcpfSB2YWx1ZSBtdXN0IGJlIGEgbnVtYmVyIG9yIGJpZ2ludGAsXG4gICAgICAgIHByaW50V2l0aFR5cGUoJ0V4cGVjdGVkJywgZXhwZWN0ZWQsIHByaW50RXhwZWN0ZWQpXG4gICAgICApXG4gICAgKTtcbiAgfVxufTtcblxuLyoqXG4gKiBFbnN1cmVzIHRoYXQgYGFjdHVhbGAgJiBgZXhwZWN0ZWRgIGFyZSBvZiB0eXBlIGBudW1iZXIgfCBiaWdpbnRgXG4gKi9cbmV4cG9ydHMuZW5zdXJlRXhwZWN0ZWRJc051bWJlciA9IGVuc3VyZUV4cGVjdGVkSXNOdW1iZXI7XG5jb25zdCBlbnN1cmVOdW1iZXJzID0gKGFjdHVhbCwgZXhwZWN0ZWQsIG1hdGNoZXJOYW1lLCBvcHRpb25zKSA9PiB7XG4gIGVuc3VyZUFjdHVhbElzTnVtYmVyKGFjdHVhbCwgbWF0Y2hlck5hbWUsIG9wdGlvbnMpO1xuICBlbnN1cmVFeHBlY3RlZElzTnVtYmVyKGV4cGVjdGVkLCBtYXRjaGVyTmFtZSwgb3B0aW9ucyk7XG59O1xuZXhwb3J0cy5lbnN1cmVOdW1iZXJzID0gZW5zdXJlTnVtYmVycztcbmNvbnN0IGVuc3VyZUV4cGVjdGVkSXNOb25OZWdhdGl2ZUludGVnZXIgPSAoZXhwZWN0ZWQsIG1hdGNoZXJOYW1lLCBvcHRpb25zKSA9PiB7XG4gIGlmIChcbiAgICB0eXBlb2YgZXhwZWN0ZWQgIT09ICdudW1iZXInIHx8XG4gICAgIU51bWJlci5pc1NhZmVJbnRlZ2VyKGV4cGVjdGVkKSB8fFxuICAgIGV4cGVjdGVkIDwgMFxuICApIHtcbiAgICAvLyBQcmVwZW5kIG1heWJlIG5vdCBvbmx5IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxuICAgIGNvbnN0IG1hdGNoZXJTdHJpbmcgPSAob3B0aW9ucyA/ICcnIDogJ1subm90XScpICsgbWF0Y2hlck5hbWU7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgbWF0Y2hlckVycm9yTWVzc2FnZShcbiAgICAgICAgbWF0Y2hlckhpbnQobWF0Y2hlclN0cmluZywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG9wdGlvbnMpLFxuICAgICAgICBgJHtFWFBFQ1RFRF9DT0xPUignZXhwZWN0ZWQnKX0gdmFsdWUgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyYCxcbiAgICAgICAgcHJpbnRXaXRoVHlwZSgnRXhwZWN0ZWQnLCBleHBlY3RlZCwgcHJpbnRFeHBlY3RlZClcbiAgICAgIClcbiAgICApO1xuICB9XG59O1xuXG4vLyBHaXZlbiBhcnJheSBvZiBkaWZmcywgcmV0dXJuIGNvbmNhdGVuYXRlZCBzdHJpbmc6XG4vLyAqIGluY2x1ZGUgY29tbW9uIHN1YnN0cmluZ3Ncbi8vICogZXhjbHVkZSBjaGFuZ2Ugc3Vic3RyaW5ncyB3aGljaCBoYXZlIG9wcG9zaXRlIG9wXG4vLyAqIGluY2x1ZGUgY2hhbmdlIHN1YnN0cmluZ3Mgd2hpY2ggaGF2ZSBhcmd1bWVudCBvcFxuLy8gICB3aXRoIGludmVyc2UgaGlnaGxpZ2h0IG9ubHkgaWYgdGhlcmUgaXMgYSBjb21tb24gc3Vic3RyaW5nXG5leHBvcnRzLmVuc3VyZUV4cGVjdGVkSXNOb25OZWdhdGl2ZUludGVnZXIgPSBlbnN1cmVFeHBlY3RlZElzTm9uTmVnYXRpdmVJbnRlZ2VyO1xuY29uc3QgZ2V0Q29tbW9uQW5kQ2hhbmdlZFN1YnN0cmluZ3MgPSAoZGlmZnMsIG9wLCBoYXNDb21tb25EaWZmKSA9PlxuICBkaWZmcy5yZWR1Y2UoXG4gICAgKHJlZHVjZWQsIGRpZmYpID0+XG4gICAgICByZWR1Y2VkICtcbiAgICAgIChkaWZmWzBdID09PSBfamVzdERpZmYuRElGRl9FUVVBTFxuICAgICAgICA/IGRpZmZbMV1cbiAgICAgICAgOiBkaWZmWzBdICE9PSBvcFxuICAgICAgICA/ICcnXG4gICAgICAgIDogaGFzQ29tbW9uRGlmZlxuICAgICAgICA/IElOVkVSVEVEX0NPTE9SKGRpZmZbMV0pXG4gICAgICAgIDogZGlmZlsxXSksXG4gICAgJydcbiAgKTtcbmNvbnN0IGlzTGluZURpZmZhYmxlID0gKGV4cGVjdGVkLCByZWNlaXZlZCkgPT4ge1xuICBjb25zdCBleHBlY3RlZFR5cGUgPSAoMCwgX2plc3RHZXRUeXBlLmdldFR5cGUpKGV4cGVjdGVkKTtcbiAgY29uc3QgcmVjZWl2ZWRUeXBlID0gKDAsIF9qZXN0R2V0VHlwZS5nZXRUeXBlKShyZWNlaXZlZCk7XG4gIGlmIChleHBlY3RlZFR5cGUgIT09IHJlY2VpdmVkVHlwZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoKDAsIF9qZXN0R2V0VHlwZS5pc1ByaW1pdGl2ZSkoZXhwZWN0ZWQpKSB7XG4gICAgLy8gUHJpbnQgZ2VuZXJpYyBsaW5lIGRpZmYgZm9yIHN0cmluZ3Mgb25seTpcbiAgICAvLyAqIGlmIG5laXRoZXIgc3RyaW5nIGlzIGVtcHR5XG4gICAgLy8gKiBpZiBlaXRoZXIgc3RyaW5nIGhhcyBtb3JlIHRoYW4gb25lIGxpbmVcbiAgICByZXR1cm4gKFxuICAgICAgdHlwZW9mIGV4cGVjdGVkID09PSAnc3RyaW5nJyAmJlxuICAgICAgdHlwZW9mIHJlY2VpdmVkID09PSAnc3RyaW5nJyAmJlxuICAgICAgZXhwZWN0ZWQubGVuZ3RoICE9PSAwICYmXG4gICAgICByZWNlaXZlZC5sZW5ndGggIT09IDAgJiZcbiAgICAgIChNVUxUSUxJTkVfUkVHRVhQLnRlc3QoZXhwZWN0ZWQpIHx8IE1VTFRJTElORV9SRUdFWFAudGVzdChyZWNlaXZlZCkpXG4gICAgKTtcbiAgfVxuICBpZiAoXG4gICAgZXhwZWN0ZWRUeXBlID09PSAnZGF0ZScgfHxcbiAgICBleHBlY3RlZFR5cGUgPT09ICdmdW5jdGlvbicgfHxcbiAgICBleHBlY3RlZFR5cGUgPT09ICdyZWdleHAnXG4gICkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZXhwZWN0ZWQgaW5zdGFuY2VvZiBFcnJvciAmJiByZWNlaXZlZCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChcbiAgICByZWNlaXZlZFR5cGUgPT09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIHJlY2VpdmVkLmFzeW1tZXRyaWNNYXRjaCA9PT0gJ2Z1bmN0aW9uJ1xuICApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuY29uc3QgTUFYX0RJRkZfU1RSSU5HX0xFTkdUSCA9IDIwMDAwO1xuY29uc3QgcHJpbnREaWZmT3JTdHJpbmdpZnkgPSAoXG4gIGV4cGVjdGVkLFxuICByZWNlaXZlZCxcbiAgZXhwZWN0ZWRMYWJlbCxcbiAgcmVjZWl2ZWRMYWJlbCxcbiAgZXhwYW5kIC8vIENMSSBvcHRpb25zOiB0cnVlIGlmIGAtLWV4cGFuZGAgb3IgZmFsc2UgaWYgYC0tbm8tZXhwYW5kYFxuKSA9PiB7XG4gIGlmIChcbiAgICB0eXBlb2YgZXhwZWN0ZWQgPT09ICdzdHJpbmcnICYmXG4gICAgdHlwZW9mIHJlY2VpdmVkID09PSAnc3RyaW5nJyAmJlxuICAgIGV4cGVjdGVkLmxlbmd0aCAhPT0gMCAmJlxuICAgIHJlY2VpdmVkLmxlbmd0aCAhPT0gMCAmJlxuICAgIGV4cGVjdGVkLmxlbmd0aCA8PSBNQVhfRElGRl9TVFJJTkdfTEVOR1RIICYmXG4gICAgcmVjZWl2ZWQubGVuZ3RoIDw9IE1BWF9ESUZGX1NUUklOR19MRU5HVEggJiZcbiAgICBleHBlY3RlZCAhPT0gcmVjZWl2ZWRcbiAgKSB7XG4gICAgaWYgKGV4cGVjdGVkLmluY2x1ZGVzKCdcXG4nKSB8fCByZWNlaXZlZC5pbmNsdWRlcygnXFxuJykpIHtcbiAgICAgIHJldHVybiAoMCwgX2plc3REaWZmLmRpZmZTdHJpbmdzVW5pZmllZCkoZXhwZWN0ZWQsIHJlY2VpdmVkLCB7XG4gICAgICAgIGFBbm5vdGF0aW9uOiBleHBlY3RlZExhYmVsLFxuICAgICAgICBiQW5ub3RhdGlvbjogcmVjZWl2ZWRMYWJlbCxcbiAgICAgICAgY2hhbmdlTGluZVRyYWlsaW5nU3BhY2VDb2xvcjogX2NoYWxrLmRlZmF1bHQuYmdZZWxsb3csXG4gICAgICAgIGNvbW1vbkxpbmVUcmFpbGluZ1NwYWNlQ29sb3I6IF9jaGFsay5kZWZhdWx0LmJnWWVsbG93LFxuICAgICAgICBlbXB0eUZpcnN0T3JMYXN0TGluZVBsYWNlaG9sZGVyOiAn4oa1JyxcbiAgICAgICAgLy8gVSsyMUI1XG4gICAgICAgIGV4cGFuZCxcbiAgICAgICAgaW5jbHVkZUNoYW5nZUNvdW50czogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGRpZmZzID0gKDAsIF9qZXN0RGlmZi5kaWZmU3RyaW5nc1JhdykoZXhwZWN0ZWQsIHJlY2VpdmVkLCB0cnVlKTtcbiAgICBjb25zdCBoYXNDb21tb25EaWZmID0gZGlmZnMuc29tZShkaWZmID0+IGRpZmZbMF0gPT09IF9qZXN0RGlmZi5ESUZGX0VRVUFMKTtcbiAgICBjb25zdCBwcmludExhYmVsID0gZ2V0TGFiZWxQcmludGVyKGV4cGVjdGVkTGFiZWwsIHJlY2VpdmVkTGFiZWwpO1xuICAgIGNvbnN0IGV4cGVjdGVkTGluZSA9XG4gICAgICBwcmludExhYmVsKGV4cGVjdGVkTGFiZWwpICtcbiAgICAgIHByaW50RXhwZWN0ZWQoXG4gICAgICAgIGdldENvbW1vbkFuZENoYW5nZWRTdWJzdHJpbmdzKFxuICAgICAgICAgIGRpZmZzLFxuICAgICAgICAgIF9qZXN0RGlmZi5ESUZGX0RFTEVURSxcbiAgICAgICAgICBoYXNDb21tb25EaWZmXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgY29uc3QgcmVjZWl2ZWRMaW5lID1cbiAgICAgIHByaW50TGFiZWwocmVjZWl2ZWRMYWJlbCkgK1xuICAgICAgcHJpbnRSZWNlaXZlZChcbiAgICAgICAgZ2V0Q29tbW9uQW5kQ2hhbmdlZFN1YnN0cmluZ3MoXG4gICAgICAgICAgZGlmZnMsXG4gICAgICAgICAgX2plc3REaWZmLkRJRkZfSU5TRVJULFxuICAgICAgICAgIGhhc0NvbW1vbkRpZmZcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICByZXR1cm4gYCR7ZXhwZWN0ZWRMaW5lfVxcbiR7cmVjZWl2ZWRMaW5lfWA7XG4gIH1cbiAgaWYgKGlzTGluZURpZmZhYmxlKGV4cGVjdGVkLCByZWNlaXZlZCkpIHtcbiAgICBjb25zdCB7cmVwbGFjZWRFeHBlY3RlZCwgcmVwbGFjZWRSZWNlaXZlZH0gPVxuICAgICAgcmVwbGFjZU1hdGNoZWRUb0FzeW1tZXRyaWNNYXRjaGVyKGV4cGVjdGVkLCByZWNlaXZlZCwgW10sIFtdKTtcbiAgICBjb25zdCBkaWZmZXJlbmNlID0gKDAsIF9qZXN0RGlmZi5kaWZmKShyZXBsYWNlZEV4cGVjdGVkLCByZXBsYWNlZFJlY2VpdmVkLCB7XG4gICAgICBhQW5ub3RhdGlvbjogZXhwZWN0ZWRMYWJlbCxcbiAgICAgIGJBbm5vdGF0aW9uOiByZWNlaXZlZExhYmVsLFxuICAgICAgZXhwYW5kLFxuICAgICAgaW5jbHVkZUNoYW5nZUNvdW50czogdHJ1ZVxuICAgIH0pO1xuICAgIGlmIChcbiAgICAgIHR5cGVvZiBkaWZmZXJlbmNlID09PSAnc3RyaW5nJyAmJlxuICAgICAgZGlmZmVyZW5jZS5pbmNsdWRlcyhgLSAke2V4cGVjdGVkTGFiZWx9YCkgJiZcbiAgICAgIGRpZmZlcmVuY2UuaW5jbHVkZXMoYCsgJHtyZWNlaXZlZExhYmVsfWApXG4gICAgKSB7XG4gICAgICByZXR1cm4gZGlmZmVyZW5jZTtcbiAgICB9XG4gIH1cbiAgY29uc3QgcHJpbnRMYWJlbCA9IGdldExhYmVsUHJpbnRlcihleHBlY3RlZExhYmVsLCByZWNlaXZlZExhYmVsKTtcbiAgY29uc3QgZXhwZWN0ZWRMaW5lID0gcHJpbnRMYWJlbChleHBlY3RlZExhYmVsKSArIHByaW50RXhwZWN0ZWQoZXhwZWN0ZWQpO1xuICBjb25zdCByZWNlaXZlZExpbmUgPVxuICAgIHByaW50TGFiZWwocmVjZWl2ZWRMYWJlbCkgK1xuICAgIChzdHJpbmdpZnkoZXhwZWN0ZWQpID09PSBzdHJpbmdpZnkocmVjZWl2ZWQpXG4gICAgICA/ICdzZXJpYWxpemVzIHRvIHRoZSBzYW1lIHN0cmluZydcbiAgICAgIDogcHJpbnRSZWNlaXZlZChyZWNlaXZlZCkpO1xuICByZXR1cm4gYCR7ZXhwZWN0ZWRMaW5lfVxcbiR7cmVjZWl2ZWRMaW5lfWA7XG59O1xuXG4vLyBTb21ldGltZXMsIGUuZy4gd2hlbiBjb21wYXJpbmcgdHdvIG51bWJlcnMsIHRoZSBvdXRwdXQgZnJvbSBqZXN0LWRpZmZcbi8vIGRvZXMgbm90IGNvbnRhaW4gbW9yZSBpbmZvcm1hdGlvbiB0aGFuIHRoZSBgRXhwZWN0ZWQ6YCAvIGBSZWNlaXZlZDpgIGFscmVhZHkgZ2l2ZXMuXG4vLyBJbiB0aG9zZSBjYXNlcywgd2UgZG8gbm90IHByaW50IGEgZGlmZiB0byBtYWtlIHRoZSBvdXRwdXQgc2hvcnRlciBhbmQgbm90IHJlZHVuZGFudC5cbmV4cG9ydHMucHJpbnREaWZmT3JTdHJpbmdpZnkgPSBwcmludERpZmZPclN0cmluZ2lmeTtcbmNvbnN0IHNob3VsZFByaW50RGlmZiA9IChhY3R1YWwsIGV4cGVjdGVkKSA9PiB7XG4gIGlmICh0eXBlb2YgYWN0dWFsID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgZXhwZWN0ZWQgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgYWN0dWFsID09PSAnYmlnaW50JyAmJiB0eXBlb2YgZXhwZWN0ZWQgPT09ICdiaWdpbnQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgYWN0dWFsID09PSAnYm9vbGVhbicgJiYgdHlwZW9mIGV4cGVjdGVkID09PSAnYm9vbGVhbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gcmVwbGFjZU1hdGNoZWRUb0FzeW1tZXRyaWNNYXRjaGVyKFxuICByZXBsYWNlZEV4cGVjdGVkLFxuICByZXBsYWNlZFJlY2VpdmVkLFxuICBleHBlY3RlZEN5Y2xlcyxcbiAgcmVjZWl2ZWRDeWNsZXNcbikge1xuICByZXR1cm4gX3JlcGxhY2VNYXRjaGVkVG9Bc3ltbWV0cmljTWF0Y2hlcihcbiAgICAoMCwgX2RlZXBDeWNsaWNDb3B5UmVwbGFjZWFibGUuZGVmYXVsdCkocmVwbGFjZWRFeHBlY3RlZCksXG4gICAgKDAsIF9kZWVwQ3ljbGljQ29weVJlcGxhY2VhYmxlLmRlZmF1bHQpKHJlcGxhY2VkUmVjZWl2ZWQpLFxuICAgIGV4cGVjdGVkQ3ljbGVzLFxuICAgIHJlY2VpdmVkQ3ljbGVzXG4gICk7XG59XG5mdW5jdGlvbiBfcmVwbGFjZU1hdGNoZWRUb0FzeW1tZXRyaWNNYXRjaGVyKFxuICByZXBsYWNlZEV4cGVjdGVkLFxuICByZXBsYWNlZFJlY2VpdmVkLFxuICBleHBlY3RlZEN5Y2xlcyxcbiAgcmVjZWl2ZWRDeWNsZXNcbikge1xuICBpZiAoIV9SZXBsYWNlYWJsZS5kZWZhdWx0LmlzUmVwbGFjZWFibGUocmVwbGFjZWRFeHBlY3RlZCwgcmVwbGFjZWRSZWNlaXZlZCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVwbGFjZWRFeHBlY3RlZCxcbiAgICAgIHJlcGxhY2VkUmVjZWl2ZWRcbiAgICB9O1xuICB9XG4gIGlmIChcbiAgICBleHBlY3RlZEN5Y2xlcy5pbmNsdWRlcyhyZXBsYWNlZEV4cGVjdGVkKSB8fFxuICAgIHJlY2VpdmVkQ3ljbGVzLmluY2x1ZGVzKHJlcGxhY2VkUmVjZWl2ZWQpXG4gICkge1xuICAgIHJldHVybiB7XG4gICAgICByZXBsYWNlZEV4cGVjdGVkLFxuICAgICAgcmVwbGFjZWRSZWNlaXZlZFxuICAgIH07XG4gIH1cbiAgZXhwZWN0ZWRDeWNsZXMucHVzaChyZXBsYWNlZEV4cGVjdGVkKTtcbiAgcmVjZWl2ZWRDeWNsZXMucHVzaChyZXBsYWNlZFJlY2VpdmVkKTtcbiAgY29uc3QgZXhwZWN0ZWRSZXBsYWNlYWJsZSA9IG5ldyBfUmVwbGFjZWFibGUuZGVmYXVsdChyZXBsYWNlZEV4cGVjdGVkKTtcbiAgY29uc3QgcmVjZWl2ZWRSZXBsYWNlYWJsZSA9IG5ldyBfUmVwbGFjZWFibGUuZGVmYXVsdChyZXBsYWNlZFJlY2VpdmVkKTtcbiAgZXhwZWN0ZWRSZXBsYWNlYWJsZS5mb3JFYWNoKChleHBlY3RlZFZhbHVlLCBrZXkpID0+IHtcbiAgICBjb25zdCByZWNlaXZlZFZhbHVlID0gcmVjZWl2ZWRSZXBsYWNlYWJsZS5nZXQoa2V5KTtcbiAgICBpZiAoaXNBc3ltbWV0cmljTWF0Y2hlcihleHBlY3RlZFZhbHVlKSkge1xuICAgICAgaWYgKGV4cGVjdGVkVmFsdWUuYXN5bW1ldHJpY01hdGNoKHJlY2VpdmVkVmFsdWUpKSB7XG4gICAgICAgIHJlY2VpdmVkUmVwbGFjZWFibGUuc2V0KGtleSwgZXhwZWN0ZWRWYWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0FzeW1tZXRyaWNNYXRjaGVyKHJlY2VpdmVkVmFsdWUpKSB7XG4gICAgICBpZiAocmVjZWl2ZWRWYWx1ZS5hc3ltbWV0cmljTWF0Y2goZXhwZWN0ZWRWYWx1ZSkpIHtcbiAgICAgICAgZXhwZWN0ZWRSZXBsYWNlYWJsZS5zZXQoa2V5LCByZWNlaXZlZFZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgX1JlcGxhY2VhYmxlLmRlZmF1bHQuaXNSZXBsYWNlYWJsZShleHBlY3RlZFZhbHVlLCByZWNlaXZlZFZhbHVlKVxuICAgICkge1xuICAgICAgY29uc3QgcmVwbGFjZWQgPSBfcmVwbGFjZU1hdGNoZWRUb0FzeW1tZXRyaWNNYXRjaGVyKFxuICAgICAgICBleHBlY3RlZFZhbHVlLFxuICAgICAgICByZWNlaXZlZFZhbHVlLFxuICAgICAgICBleHBlY3RlZEN5Y2xlcyxcbiAgICAgICAgcmVjZWl2ZWRDeWNsZXNcbiAgICAgICk7XG4gICAgICBleHBlY3RlZFJlcGxhY2VhYmxlLnNldChrZXksIHJlcGxhY2VkLnJlcGxhY2VkRXhwZWN0ZWQpO1xuICAgICAgcmVjZWl2ZWRSZXBsYWNlYWJsZS5zZXQoa2V5LCByZXBsYWNlZC5yZXBsYWNlZFJlY2VpdmVkKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHJlcGxhY2VkRXhwZWN0ZWQ6IGV4cGVjdGVkUmVwbGFjZWFibGUub2JqZWN0LFxuICAgIHJlcGxhY2VkUmVjZWl2ZWQ6IHJlY2VpdmVkUmVwbGFjZWFibGUub2JqZWN0XG4gIH07XG59XG5mdW5jdGlvbiBpc0FzeW1tZXRyaWNNYXRjaGVyKGRhdGEpIHtcbiAgY29uc3QgdHlwZSA9ICgwLCBfamVzdEdldFR5cGUuZ2V0VHlwZSkoZGF0YSk7XG4gIHJldHVybiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgZGF0YS5hc3ltbWV0cmljTWF0Y2ggPT09ICdmdW5jdGlvbic7XG59XG5jb25zdCBkaWZmID0gKGEsIGIsIG9wdGlvbnMpID0+XG4gIHNob3VsZFByaW50RGlmZihhLCBiKSA/ICgwLCBfamVzdERpZmYuZGlmZikoYSwgYiwgb3B0aW9ucykgOiBudWxsO1xuZXhwb3J0cy5kaWZmID0gZGlmZjtcbmNvbnN0IHBsdXJhbGl6ZSA9ICh3b3JkLCBjb3VudCkgPT5cbiAgYCR7TlVNQkVSU1tjb3VudF0gfHwgY291bnR9ICR7d29yZH0ke2NvdW50ID09PSAxID8gJycgOiAncyd9YDtcblxuLy8gVG8gZGlzcGxheSBsaW5lcyBvZiBsYWJlbGVkIHZhbHVlcyBhcyB0d28gY29sdW1ucyB3aXRoIG1vbm9zcGFjZSBhbGlnbm1lbnQ6XG4vLyBnaXZlbiB0aGUgc3RyaW5ncyB3aGljaCB3aWxsIGRlc2NyaWJlIHRoZSB2YWx1ZXMsXG4vLyByZXR1cm4gZnVuY3Rpb24gd2hpY2ggZ2l2ZW4gZWFjaCBzdHJpbmcsIHJldHVybnMgdGhlIGxhYmVsOlxuLy8gc3RyaW5nLCBjb2xvbiwgc3BhY2UsIGFuZCBlbm91Z2ggcGFkZGluZyBzcGFjZXMgdG8gYWxpZ24gdGhlIHZhbHVlLlxuZXhwb3J0cy5wbHVyYWxpemUgPSBwbHVyYWxpemU7XG5jb25zdCBnZXRMYWJlbFByaW50ZXIgPSAoLi4uc3RyaW5ncykgPT4ge1xuICBjb25zdCBtYXhMZW5ndGggPSBzdHJpbmdzLnJlZHVjZShcbiAgICAobWF4LCBzdHJpbmcpID0+IChzdHJpbmcubGVuZ3RoID4gbWF4ID8gc3RyaW5nLmxlbmd0aCA6IG1heCksXG4gICAgMFxuICApO1xuICByZXR1cm4gc3RyaW5nID0+IGAke3N0cmluZ306ICR7JyAnLnJlcGVhdChtYXhMZW5ndGggLSBzdHJpbmcubGVuZ3RoKX1gO1xufTtcbmV4cG9ydHMuZ2V0TGFiZWxQcmludGVyID0gZ2V0TGFiZWxQcmludGVyO1xuY29uc3QgbWF0Y2hlckVycm9yTWVzc2FnZSA9IChcbiAgaGludCxcbiAgZ2VuZXJpYyxcbiAgc3BlY2lmaWMgLy8gaW5jb3JyZWN0IHZhbHVlIHJldHVybmVkIGZyb20gY2FsbCB0byBwcmludFdpdGhUeXBlXG4pID0+XG4gIGAke2hpbnR9XFxuXFxuJHtfY2hhbGsuZGVmYXVsdC5ib2xkKCdNYXRjaGVyIGVycm9yJyl9OiAke2dlbmVyaWN9JHtcbiAgICB0eXBlb2Ygc3BlY2lmaWMgPT09ICdzdHJpbmcnID8gYFxcblxcbiR7c3BlY2lmaWN9YCA6ICcnXG4gIH1gO1xuXG4vLyBEaXNwbGF5IGFzc2VydGlvbiBmb3IgdGhlIHJlcG9ydCB3aGVuIGEgdGVzdCBmYWlscy5cbi8vIE5ldyBmb3JtYXQ6IHJlamVjdHMvcmVzb2x2ZXMsIG5vdCwgYW5kIG1hdGNoZXIgbmFtZSBoYXZlIGJsYWNrIGNvbG9yXG4vLyBPbGQgZm9ybWF0OiBtYXRjaGVyIG5hbWUgaGFzIGRpbSBjb2xvclxuZXhwb3J0cy5tYXRjaGVyRXJyb3JNZXNzYWdlID0gbWF0Y2hlckVycm9yTWVzc2FnZTtcbmNvbnN0IG1hdGNoZXJIaW50ID0gKFxuICBtYXRjaGVyTmFtZSxcbiAgcmVjZWl2ZWQgPSAncmVjZWl2ZWQnLFxuICBleHBlY3RlZCA9ICdleHBlY3RlZCcsXG4gIG9wdGlvbnMgPSB7fVxuKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBjb21tZW50ID0gJycsXG4gICAgZXhwZWN0ZWRDb2xvciA9IEVYUEVDVEVEX0NPTE9SLFxuICAgIGlzRGlyZWN0RXhwZWN0Q2FsbCA9IGZhbHNlLFxuICAgIC8vIHNlZW1zIHJlZHVuZGFudCB3aXRoIHJlY2VpdmVkID09PSAnJ1xuICAgIGlzTm90ID0gZmFsc2UsXG4gICAgcHJvbWlzZSA9ICcnLFxuICAgIHJlY2VpdmVkQ29sb3IgPSBSRUNFSVZFRF9DT0xPUixcbiAgICBzZWNvbmRBcmd1bWVudCA9ICcnLFxuICAgIHNlY29uZEFyZ3VtZW50Q29sb3IgPSBFWFBFQ1RFRF9DT0xPUlxuICB9ID0gb3B0aW9ucztcbiAgbGV0IGhpbnQgPSAnJztcbiAgbGV0IGRpbVN0cmluZyA9ICdleHBlY3QnOyAvLyBjb25jYXRlbmF0ZSBhZGphY2VudCBkaW0gc3Vic3RyaW5nc1xuXG4gIGlmICghaXNEaXJlY3RFeHBlY3RDYWxsICYmIHJlY2VpdmVkICE9PSAnJykge1xuICAgIGhpbnQgKz0gRElNX0NPTE9SKGAke2RpbVN0cmluZ30oYCkgKyByZWNlaXZlZENvbG9yKHJlY2VpdmVkKTtcbiAgICBkaW1TdHJpbmcgPSAnKSc7XG4gIH1cbiAgaWYgKHByb21pc2UgIT09ICcnKSB7XG4gICAgaGludCArPSBESU1fQ09MT1IoYCR7ZGltU3RyaW5nfS5gKSArIHByb21pc2U7XG4gICAgZGltU3RyaW5nID0gJyc7XG4gIH1cbiAgaWYgKGlzTm90KSB7XG4gICAgaGludCArPSBgJHtESU1fQ09MT1IoYCR7ZGltU3RyaW5nfS5gKX1ub3RgO1xuICAgIGRpbVN0cmluZyA9ICcnO1xuICB9XG4gIGlmIChtYXRjaGVyTmFtZS5pbmNsdWRlcygnLicpKSB7XG4gICAgLy8gT2xkIGZvcm1hdDogZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksXG4gICAgLy8gZXNwZWNpYWxseSB3aXRob3V0IHByb21pc2Ugb3IgaXNOb3Qgb3B0aW9uc1xuICAgIGRpbVN0cmluZyArPSBtYXRjaGVyTmFtZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBOZXcgZm9ybWF0OiBvbWl0IHBlcmlvZCBmcm9tIG1hdGNoZXJOYW1lIGFyZ1xuICAgIGhpbnQgKz0gRElNX0NPTE9SKGAke2RpbVN0cmluZ30uYCkgKyBtYXRjaGVyTmFtZTtcbiAgICBkaW1TdHJpbmcgPSAnJztcbiAgfVxuICBpZiAoZXhwZWN0ZWQgPT09ICcnKSB7XG4gICAgZGltU3RyaW5nICs9ICcoKSc7XG4gIH0gZWxzZSB7XG4gICAgaGludCArPSBESU1fQ09MT1IoYCR7ZGltU3RyaW5nfShgKSArIGV4cGVjdGVkQ29sb3IoZXhwZWN0ZWQpO1xuICAgIGlmIChzZWNvbmRBcmd1bWVudCkge1xuICAgICAgaGludCArPSBESU1fQ09MT1IoJywgJykgKyBzZWNvbmRBcmd1bWVudENvbG9yKHNlY29uZEFyZ3VtZW50KTtcbiAgICB9XG4gICAgZGltU3RyaW5nID0gJyknO1xuICB9XG4gIGlmIChjb21tZW50ICE9PSAnJykge1xuICAgIGRpbVN0cmluZyArPSBgIC8vICR7Y29tbWVudH1gO1xuICB9XG4gIGlmIChkaW1TdHJpbmcgIT09ICcnKSB7XG4gICAgaGludCArPSBESU1fQ09MT1IoZGltU3RyaW5nKTtcbiAgfVxuICByZXR1cm4gaGludDtcbn07XG5leHBvcnRzLm1hdGNoZXJIaW50ID0gbWF0Y2hlckhpbnQ7XG4iXSwidmVyc2lvbiI6M30=