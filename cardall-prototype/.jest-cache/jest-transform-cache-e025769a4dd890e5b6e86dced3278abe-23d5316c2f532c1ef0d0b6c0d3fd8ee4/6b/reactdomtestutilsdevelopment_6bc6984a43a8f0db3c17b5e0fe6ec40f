0e99d79e27ca0ce3c0401c1e1dfca56f
/**
 * @license React
 * react-dom-test-utils.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';
if (process.env.NODE_ENV !== "production") {
    (function () {
        'use strict';
        var React = require('react');
        var ReactDOM = require('react-dom');
        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        // by calls to these methods by a Babel plugin.
        //
        // In PROD (or in packages without access to React internals),
        // they are left as they are instead.
        function warn(format) {
            {
                {
                    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                        args[_key - 1] = arguments[_key];
                    }
                    printWarning('warn', format, args);
                }
            }
        }
        function error(format) {
            {
                {
                    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                        args[_key2 - 1] = arguments[_key2];
                    }
                    printWarning('error', format, args);
                }
            }
        }
        function printWarning(level, format, args) {
            // When changing this logic, you might want to also
            // update consoleWithStackDev.www.js as well.
            {
                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
                var stack = ReactDebugCurrentFrame.getStackAddendum();
                if (stack !== '') {
                    format += '%s';
                    args = args.concat([stack]);
                } // eslint-disable-next-line react-internal/safe-string-coercion
                var argsWithFormat = args.map(function (item) {
                    return String(item);
                }); // Careful: RN currently depends on this prefix
                argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
                // breaks IE9: https://github.com/facebook/react/issues/13610
                // eslint-disable-next-line react-internal/no-production-logging
                Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
        }
        /**
         * `ReactInstanceMap` maintains a mapping from a public facing stateful
         * instance (key) and the internal representation (value). This allows public
         * methods to accept the user facing instance as an argument and map them back
         * to internal methods.
         *
         * Note that this module is currently shared and assumed to be stateless.
         * If this becomes an actual Map, that will break.
         */
        function get(key) {
            return key._reactInternals;
        }
        var FunctionComponent = 0;
        var ClassComponent = 1;
        var HostRoot = 3; // Root of a host tree. Could be nested inside another node.
        var HostComponent = 5;
        var HostText = 6;
        // Don't change these two values. They're used by React Dev Tools.
        var NoFlags = 
        /*                      */
        0;
        var Placement = 
        /*                    */
        2;
        var Hydrating = 
        /*                    */
        4096;
        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
        function getNearestMountedFiber(fiber) {
            var node = fiber;
            var nearestMounted = fiber;
            if (!fiber.alternate) {
                // If there is no alternate, this might be a new tree that isn't inserted
                // yet. If it is, then it will have a pending insertion effect on it.
                var nextNode = node;
                do {
                    node = nextNode;
                    if ((node.flags & (Placement | Hydrating)) !== NoFlags) {
                        // This is an insertion or in-progress hydration. The nearest possible
                        // mounted fiber is the parent but we need to continue to figure out
                        // if that one is still mounted.
                        nearestMounted = node.return;
                    }
                    nextNode = node.return;
                } while (nextNode);
            }
            else {
                while (node.return) {
                    node = node.return;
                }
            }
            if (node.tag === HostRoot) {
                // TODO: Check if this was a nested HostRoot when used with
                // renderContainerIntoSubtree.
                return nearestMounted;
            } // If we didn't hit the root, that means that we're in an disconnected tree
            // that has been unmounted.
            return null;
        }
        function assertIsMounted(fiber) {
            if (getNearestMountedFiber(fiber) !== fiber) {
                throw new Error('Unable to find node on an unmounted component.');
            }
        }
        function findCurrentFiberUsingSlowPath(fiber) {
            var alternate = fiber.alternate;
            if (!alternate) {
                // If there is no alternate, then we only need to check if it is mounted.
                var nearestMounted = getNearestMountedFiber(fiber);
                if (nearestMounted === null) {
                    throw new Error('Unable to find node on an unmounted component.');
                }
                if (nearestMounted !== fiber) {
                    return null;
                }
                return fiber;
            } // If we have two possible branches, we'll walk backwards up to the root
            // to see what path the root points to. On the way we may hit one of the
            // special cases and we'll deal with them.
            var a = fiber;
            var b = alternate;
            while (true) {
                var parentA = a.return;
                if (parentA === null) {
                    // We're at the root.
                    break;
                }
                var parentB = parentA.alternate;
                if (parentB === null) {
                    // There is no alternate. This is an unusual case. Currently, it only
                    // happens when a Suspense component is hidden. An extra fragment fiber
                    // is inserted in between the Suspense fiber and its children. Skip
                    // over this extra fragment fiber and proceed to the next parent.
                    var nextParent = parentA.return;
                    if (nextParent !== null) {
                        a = b = nextParent;
                        continue;
                    } // If there's no parent, we're at the root.
                    break;
                } // If both copies of the parent fiber point to the same child, we can
                // assume that the child is current. This happens when we bailout on low
                // priority: the bailed out fiber's child reuses the current child.
                if (parentA.child === parentB.child) {
                    var child = parentA.child;
                    while (child) {
                        if (child === a) {
                            // We've determined that A is the current branch.
                            assertIsMounted(parentA);
                            return fiber;
                        }
                        if (child === b) {
                            // We've determined that B is the current branch.
                            assertIsMounted(parentA);
                            return alternate;
                        }
                        child = child.sibling;
                    } // We should never have an alternate for any mounting node. So the only
                    // way this could possibly happen is if this was unmounted, if at all.
                    throw new Error('Unable to find node on an unmounted component.');
                }
                if (a.return !== b.return) {
                    // The return pointer of A and the return pointer of B point to different
                    // fibers. We assume that return pointers never criss-cross, so A must
                    // belong to the child set of A.return, and B must belong to the child
                    // set of B.return.
                    a = parentA;
                    b = parentB;
                }
                else {
                    // The return pointers point to the same fiber. We'll have to use the
                    // default, slow path: scan the child sets of each parent alternate to see
                    // which child belongs to which set.
                    //
                    // Search parent A's child set
                    var didFindChild = false;
                    var _child = parentA.child;
                    while (_child) {
                        if (_child === a) {
                            didFindChild = true;
                            a = parentA;
                            b = parentB;
                            break;
                        }
                        if (_child === b) {
                            didFindChild = true;
                            b = parentA;
                            a = parentB;
                            break;
                        }
                        _child = _child.sibling;
                    }
                    if (!didFindChild) {
                        // Search parent B's child set
                        _child = parentB.child;
                        while (_child) {
                            if (_child === a) {
                                didFindChild = true;
                                a = parentB;
                                b = parentA;
                                break;
                            }
                            if (_child === b) {
                                didFindChild = true;
                                b = parentB;
                                a = parentA;
                                break;
                            }
                            _child = _child.sibling;
                        }
                        if (!didFindChild) {
                            throw new Error('Child was not found in either parent set. This indicates a bug ' + 'in React related to the return pointer. Please file an issue.');
                        }
                    }
                }
                if (a.alternate !== b) {
                    throw new Error("Return fibers should always be each others' alternates. " + 'This error is likely caused by a bug in React. Please file an issue.');
                }
            } // If the root is not a host container, we're in a disconnected tree. I.e.
            // unmounted.
            if (a.tag !== HostRoot) {
                throw new Error('Unable to find node on an unmounted component.');
            }
            if (a.stateNode.current === a) {
                // We've determined that A is the current branch.
                return fiber;
            } // Otherwise B has to be current branch.
            return alternate;
        }
        var assign = Object.assign;
        /**
         * `charCode` represents the actual "character code" and is safe to use with
         * `String.fromCharCode`. As such, only keys that correspond to printable
         * characters produce a valid `charCode`, the only exception to this is Enter.
         * The Tab-key is considered non-printable and does not have a `charCode`,
         * presumably because it does not produce a tab-character in browsers.
         *
         * @param {object} nativeEvent Native browser event.
         * @return {number} Normalized `charCode` property.
         */
        function getEventCharCode(nativeEvent) {
            var charCode;
            var keyCode = nativeEvent.keyCode;
            if ('charCode' in nativeEvent) {
                charCode = nativeEvent.charCode; // FF does not set `charCode` for the Enter-key, check against `keyCode`.
                if (charCode === 0 && keyCode === 13) {
                    charCode = 13;
                }
            }
            else {
                // IE8 does not implement `charCode`, but `keyCode` has the correct value.
                charCode = keyCode;
            } // IE and Edge (on Windows) and Chrome / Safari (on Windows and Linux)
            // report Enter as charCode 10 when ctrl is pressed.
            if (charCode === 10) {
                charCode = 13;
            } // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
            // Must not discard the (non-)printable Enter-key.
            if (charCode >= 32 || charCode === 13) {
                return charCode;
            }
            return 0;
        }
        function functionThatReturnsTrue() {
            return true;
        }
        function functionThatReturnsFalse() {
            return false;
        } // This is intentionally a factory so that we have different returned constructors.
        // If we had a single constructor, it would be megamorphic and engines would deopt.
        function createSyntheticEvent(Interface) {
            /**
             * Synthetic events are dispatched by event plugins, typically in response to a
             * top-level event delegation handler.
             *
             * These systems should generally use pooling to reduce the frequency of garbage
             * collection. The system should check `isPersistent` to determine whether the
             * event should be released into the pool after being dispatched. Users that
             * need a persisted event should invoke `persist`.
             *
             * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
             * normalizing browser quirks. Subclasses do not necessarily have to implement a
             * DOM interface; custom application-specific events can also subclass this.
             */
            function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
                this._reactName = reactName;
                this._targetInst = targetInst;
                this.type = reactEventType;
                this.nativeEvent = nativeEvent;
                this.target = nativeEventTarget;
                this.currentTarget = null;
                for (var _propName in Interface) {
                    if (!Interface.hasOwnProperty(_propName)) {
                        continue;
                    }
                    var normalize = Interface[_propName];
                    if (normalize) {
                        this[_propName] = normalize(nativeEvent);
                    }
                    else {
                        this[_propName] = nativeEvent[_propName];
                    }
                }
                var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
                if (defaultPrevented) {
                    this.isDefaultPrevented = functionThatReturnsTrue;
                }
                else {
                    this.isDefaultPrevented = functionThatReturnsFalse;
                }
                this.isPropagationStopped = functionThatReturnsFalse;
                return this;
            }
            assign(SyntheticBaseEvent.prototype, {
                preventDefault: function () {
                    this.defaultPrevented = true;
                    var event = this.nativeEvent;
                    if (!event) {
                        return;
                    }
                    if (event.preventDefault) {
                        event.preventDefault(); // $FlowFixMe - flow is not aware of `unknown` in IE
                    }
                    else if (typeof event.returnValue !== 'unknown') {
                        event.returnValue = false;
                    }
                    this.isDefaultPrevented = functionThatReturnsTrue;
                },
                stopPropagation: function () {
                    var event = this.nativeEvent;
                    if (!event) {
                        return;
                    }
                    if (event.stopPropagation) {
                        event.stopPropagation(); // $FlowFixMe - flow is not aware of `unknown` in IE
                    }
                    else if (typeof event.cancelBubble !== 'unknown') {
                        // The ChangeEventPlugin registers a "propertychange" event for
                        // IE. This event does not support bubbling or cancelling, and
                        // any references to cancelBubble throw "Member not found".  A
                        // typeof check of "unknown" circumvents this issue (and is also
                        // IE specific).
                        event.cancelBubble = true;
                    }
                    this.isPropagationStopped = functionThatReturnsTrue;
                },
                /**
                 * We release all dispatched `SyntheticEvent`s after each event loop, adding
                 * them back into the pool. This allows a way to hold onto a reference that
                 * won't be added back into the pool.
                 */
                persist: function () {
                },
                /**
                 * Checks if this event should be released back into the pool.
                 *
                 * @return {boolean} True if this should not be released, false otherwise.
                 */
                isPersistent: functionThatReturnsTrue
            });
            return SyntheticBaseEvent;
        }
        /**
         * @interface Event
         * @see http://www.w3.org/TR/DOM-Level-3-Events/
         */
        var EventInterface = {
            eventPhase: 0,
            bubbles: 0,
            cancelable: 0,
            timeStamp: function (event) {
                return event.timeStamp || Date.now();
            },
            defaultPrevented: 0,
            isTrusted: 0
        };
        var SyntheticEvent = createSyntheticEvent(EventInterface);
        var UIEventInterface = assign({}, EventInterface, {
            view: 0,
            detail: 0
        });
        var SyntheticUIEvent = createSyntheticEvent(UIEventInterface);
        var lastMovementX;
        var lastMovementY;
        var lastMouseEvent;
        function updateMouseMovementPolyfillState(event) {
            if (event !== lastMouseEvent) {
                if (lastMouseEvent && event.type === 'mousemove') {
                    lastMovementX = event.screenX - lastMouseEvent.screenX;
                    lastMovementY = event.screenY - lastMouseEvent.screenY;
                }
                else {
                    lastMovementX = 0;
                    lastMovementY = 0;
                }
                lastMouseEvent = event;
            }
        }
        /**
         * @interface MouseEvent
         * @see http://www.w3.org/TR/DOM-Level-3-Events/
         */
        var MouseEventInterface = assign({}, UIEventInterface, {
            screenX: 0,
            screenY: 0,
            clientX: 0,
            clientY: 0,
            pageX: 0,
            pageY: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            getModifierState: getEventModifierState,
            button: 0,
            buttons: 0,
            relatedTarget: function (event) {
                if (event.relatedTarget === undefined)
                    return event.fromElement === event.srcElement ? event.toElement : event.fromElement;
                return event.relatedTarget;
            },
            movementX: function (event) {
                if ('movementX' in event) {
                    return event.movementX;
                }
                updateMouseMovementPolyfillState(event);
                return lastMovementX;
            },
            movementY: function (event) {
                if ('movementY' in event) {
                    return event.movementY;
                } // Don't need to call updateMouseMovementPolyfillState() here
                // because it's guaranteed to have already run when movementX
                // was copied.
                return lastMovementY;
            }
        });
        var SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface);
        /**
         * @interface DragEvent
         * @see http://www.w3.org/TR/DOM-Level-3-Events/
         */
        var DragEventInterface = assign({}, MouseEventInterface, {
            dataTransfer: 0
        });
        var SyntheticDragEvent = createSyntheticEvent(DragEventInterface);
        /**
         * @interface FocusEvent
         * @see http://www.w3.org/TR/DOM-Level-3-Events/
         */
        var FocusEventInterface = assign({}, UIEventInterface, {
            relatedTarget: 0
        });
        var SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface);
        /**
         * @interface Event
         * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
         * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
         */
        var AnimationEventInterface = assign({}, EventInterface, {
            animationName: 0,
            elapsedTime: 0,
            pseudoElement: 0
        });
        var SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface);
        /**
         * @interface Event
         * @see http://www.w3.org/TR/clipboard-apis/
         */
        var ClipboardEventInterface = assign({}, EventInterface, {
            clipboardData: function (event) {
                return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
            }
        });
        var SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface);
        /**
         * @interface Event
         * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
         */
        var CompositionEventInterface = assign({}, EventInterface, {
            data: 0
        });
        var SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface);
        /**
         * Normalization of deprecated HTML5 `key` values
         * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
         */
        var normalizeKey = {
            Esc: 'Escape',
            Spacebar: ' ',
            Left: 'ArrowLeft',
            Up: 'ArrowUp',
            Right: 'ArrowRight',
            Down: 'ArrowDown',
            Del: 'Delete',
            Win: 'OS',
            Menu: 'ContextMenu',
            Apps: 'ContextMenu',
            Scroll: 'ScrollLock',
            MozPrintableKey: 'Unidentified'
        };
        /**
         * Translation from legacy `keyCode` to HTML5 `key`
         * Only special keys supported, all others depend on keyboard layout or browser
         * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
         */
        var translateToKey = {
            '8': 'Backspace',
            '9': 'Tab',
            '12': 'Clear',
            '13': 'Enter',
            '16': 'Shift',
            '17': 'Control',
            '18': 'Alt',
            '19': 'Pause',
            '20': 'CapsLock',
            '27': 'Escape',
            '32': ' ',
            '33': 'PageUp',
            '34': 'PageDown',
            '35': 'End',
            '36': 'Home',
            '37': 'ArrowLeft',
            '38': 'ArrowUp',
            '39': 'ArrowRight',
            '40': 'ArrowDown',
            '45': 'Insert',
            '46': 'Delete',
            '112': 'F1',
            '113': 'F2',
            '114': 'F3',
            '115': 'F4',
            '116': 'F5',
            '117': 'F6',
            '118': 'F7',
            '119': 'F8',
            '120': 'F9',
            '121': 'F10',
            '122': 'F11',
            '123': 'F12',
            '144': 'NumLock',
            '145': 'ScrollLock',
            '224': 'Meta'
        };
        /**
         * @param {object} nativeEvent Native browser event.
         * @return {string} Normalized `key` property.
         */
        function getEventKey(nativeEvent) {
            if (nativeEvent.key) {
                // Normalize inconsistent values reported by browsers due to
                // implementations of a working draft specification.
                // FireFox implements `key` but returns `MozPrintableKey` for all
                // printable characters (normalized to `Unidentified`), ignore it.
                var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
                if (key !== 'Unidentified') {
                    return key;
                }
            } // Browser does not implement `key`, polyfill as much of it as we can.
            if (nativeEvent.type === 'keypress') {
                var charCode = getEventCharCode(nativeEvent); // The enter-key is technically both printable and non-printable and can
                // thus be captured by `keypress`, no other non-printable key should.
                return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
            }
            if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
                // While user keyboard layout determines the actual meaning of each
                // `keyCode` value, almost all function keys have a universal value.
                return translateToKey[nativeEvent.keyCode] || 'Unidentified';
            }
            return '';
        }
        /**
         * Translation from modifier key to the associated property in the event.
         * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
         */
        var modifierKeyToProp = {
            Alt: 'altKey',
            Control: 'ctrlKey',
            Meta: 'metaKey',
            Shift: 'shiftKey'
        }; // Older browsers (Safari <= 10, iOS Safari <= 10.2) do not support
        // getModifierState. If getModifierState is not supported, we map it to a set of
        // modifier keys exposed by the event. In this case, Lock-keys are not supported.
        function modifierStateGetter(keyArg) {
            var syntheticEvent = this;
            var nativeEvent = syntheticEvent.nativeEvent;
            if (nativeEvent.getModifierState) {
                return nativeEvent.getModifierState(keyArg);
            }
            var keyProp = modifierKeyToProp[keyArg];
            return keyProp ? !!nativeEvent[keyProp] : false;
        }
        function getEventModifierState(nativeEvent) {
            return modifierStateGetter;
        }
        /**
         * @interface KeyboardEvent
         * @see http://www.w3.org/TR/DOM-Level-3-Events/
         */
        var KeyboardEventInterface = assign({}, UIEventInterface, {
            key: getEventKey,
            code: 0,
            location: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            repeat: 0,
            locale: 0,
            getModifierState: getEventModifierState,
            // Legacy Interface
            charCode: function (event) {
                // `charCode` is the result of a KeyPress event and represents the value of
                // the actual printable character.
                // KeyPress is deprecated, but its replacement is not yet final and not
                // implemented in any major browser. Only KeyPress has charCode.
                if (event.type === 'keypress') {
                    return getEventCharCode(event);
                }
                return 0;
            },
            keyCode: function (event) {
                // `keyCode` is the result of a KeyDown/Up event and represents the value of
                // physical keyboard key.
                // The actual meaning of the value depends on the users' keyboard layout
                // which cannot be detected. Assuming that it is a US keyboard layout
                // provides a surprisingly accurate mapping for US and European users.
                // Due to this, it is left to the user to implement at this time.
                if (event.type === 'keydown' || event.type === 'keyup') {
                    return event.keyCode;
                }
                return 0;
            },
            which: function (event) {
                // `which` is an alias for either `keyCode` or `charCode` depending on the
                // type of the event.
                if (event.type === 'keypress') {
                    return getEventCharCode(event);
                }
                if (event.type === 'keydown' || event.type === 'keyup') {
                    return event.keyCode;
                }
                return 0;
            }
        });
        var SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface);
        /**
         * @interface PointerEvent
         * @see http://www.w3.org/TR/pointerevents/
         */
        var PointerEventInterface = assign({}, MouseEventInterface, {
            pointerId: 0,
            width: 0,
            height: 0,
            pressure: 0,
            tangentialPressure: 0,
            tiltX: 0,
            tiltY: 0,
            twist: 0,
            pointerType: 0,
            isPrimary: 0
        });
        var SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface);
        /**
         * @interface TouchEvent
         * @see http://www.w3.org/TR/touch-events/
         */
        var TouchEventInterface = assign({}, UIEventInterface, {
            touches: 0,
            targetTouches: 0,
            changedTouches: 0,
            altKey: 0,
            metaKey: 0,
            ctrlKey: 0,
            shiftKey: 0,
            getModifierState: getEventModifierState
        });
        var SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface);
        /**
         * @interface Event
         * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
         * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
         */
        var TransitionEventInterface = assign({}, EventInterface, {
            propertyName: 0,
            elapsedTime: 0,
            pseudoElement: 0
        });
        var SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface);
        /**
         * @interface WheelEvent
         * @see http://www.w3.org/TR/DOM-Level-3-Events/
         */
        var WheelEventInterface = assign({}, MouseEventInterface, {
            deltaX: function (event) {
                return 'deltaX' in event ? event.deltaX : // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
                    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
            },
            deltaY: function (event) {
                return 'deltaY' in event ? event.deltaY : // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
                    'wheelDeltaY' in event ? -event.wheelDeltaY : // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
                        'wheelDelta' in event ? -event.wheelDelta : 0;
            },
            deltaZ: 0,
            // Browsers without "deltaMode" is reporting in raw wheel delta where one
            // notch on the scroll is always +/- 120, roughly equivalent to pixels.
            // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
            // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
            deltaMode: 0
        });
        var SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface);
        /**
         * HTML nodeType values that represent the type of the node
         */
        var ELEMENT_NODE = 1;
        function invokeGuardedCallbackProd(name, func, context, a, b, c, d, e, f) {
            var funcArgs = Array.prototype.slice.call(arguments, 3);
            try {
                func.apply(context, funcArgs);
            }
            catch (error) {
                this.onError(error);
            }
        }
        var invokeGuardedCallbackImpl = invokeGuardedCallbackProd;
        {
            // In DEV mode, we swap out invokeGuardedCallback for a special version
            // that plays more nicely with the browser's DevTools. The idea is to preserve
            // "Pause on exceptions" behavior. Because React wraps all user-provided
            // functions in invokeGuardedCallback, and the production version of
            // invokeGuardedCallback uses a try-catch, all user exceptions are treated
            // like caught exceptions, and the DevTools won't pause unless the developer
            // takes the extra step of enabling pause on caught exceptions. This is
            // unintuitive, though, because even though React has caught the error, from
            // the developer's perspective, the error is uncaught.
            //
            // To preserve the expected "Pause on exceptions" behavior, we don't use a
            // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake
            // DOM node, and call the user-provided callback from inside an event handler
            // for that fake event. If the callback throws, the error is "captured" using
            // a global event handler. But because the error happens in a different
            // event loop context, it does not interrupt the normal program flow.
            // Effectively, this gives us try-catch behavior without actually using
            // try-catch. Neat!
            // Check that the browser supports the APIs we need to implement our special
            // DEV version of invokeGuardedCallback
            if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
                var fakeNode = document.createElement('react');
                invokeGuardedCallbackImpl = function invokeGuardedCallbackDev(name, func, context, a, b, c, d, e, f) {
                    // If document doesn't exist we know for sure we will crash in this method
                    // when we call document.createEvent(). However this can cause confusing
                    // errors: https://github.com/facebook/create-react-app/issues/3482
                    // So we preemptively throw with a better message instead.
                    if (typeof document === 'undefined' || document === null) {
                        throw new Error('The `document` global was defined when React was initialized, but is not ' + 'defined anymore. This can happen in a test environment if a component ' + 'schedules an update from an asynchronous callback, but the test has already ' + 'finished running. To solve this, you can either unmount the component at ' + 'the end of your test (and ensure that any asynchronous operations get ' + 'canceled in `componentWillUnmount`), or you can change the test itself ' + 'to be asynchronous.');
                    }
                    var evt = document.createEvent('Event');
                    var didCall = false; // Keeps track of whether the user-provided callback threw an error. We
                    // set this to true at the beginning, then set it to false right after
                    // calling the function. If the function errors, `didError` will never be
                    // set to false. This strategy works even if the browser is flaky and
                    // fails to call our global error handler, because it doesn't rely on
                    // the error event at all.
                    var didError = true; // Keeps track of the value of window.event so that we can reset it
                    // during the callback to let user code access window.event in the
                    // browsers that support it.
                    var windowEvent = window.event; // Keeps track of the descriptor of window.event to restore it after event
                    // dispatching: https://github.com/facebook/react/issues/13688
                    var windowEventDescriptor = Object.getOwnPropertyDescriptor(window, 'event');
                    function restoreAfterDispatch() {
                        // We immediately remove the callback from event listeners so that
                        // nested `invokeGuardedCallback` calls do not clash. Otherwise, a
                        // nested call would trigger the fake event handlers of any call higher
                        // in the stack.
                        fakeNode.removeEventListener(evtType, callCallback, false); // We check for window.hasOwnProperty('event') to prevent the
                        // window.event assignment in both IE <= 10 as they throw an error
                        // "Member not found" in strict mode, and in Firefox which does not
                        // support window.event.
                        if (typeof window.event !== 'undefined' && window.hasOwnProperty('event')) {
                            window.event = windowEvent;
                        }
                    } // Create an event handler for our fake event. We will synchronously
                    // dispatch our fake event using `dispatchEvent`. Inside the handler, we
                    // call the user-provided callback.
                    var funcArgs = Array.prototype.slice.call(arguments, 3);
                    function callCallback() {
                        didCall = true;
                        restoreAfterDispatch();
                        func.apply(context, funcArgs);
                        didError = false;
                    } // Create a global error event handler. We use this to capture the value
                    // that was thrown. It's possible that this error handler will fire more
                    // than once; for example, if non-React code also calls `dispatchEvent`
                    // and a handler for that event throws. We should be resilient to most of
                    // those cases. Even if our error event handler fires more than once, the
                    // last error event is always used. If the callback actually does error,
                    // we know that the last error event is the correct one, because it's not
                    // possible for anything else to have happened in between our callback
                    // erroring and the code that follows the `dispatchEvent` call below. If
                    // the callback doesn't error, but the error event was fired, we know to
                    // ignore it because `didError` will be false, as described above.
                    var error; // Use this to track whether the error event is ever called.
                    var didSetError = false;
                    var isCrossOriginError = false;
                    function handleWindowError(event) {
                        error = event.error;
                        didSetError = true;
                        if (error === null && event.colno === 0 && event.lineno === 0) {
                            isCrossOriginError = true;
                        }
                        if (event.defaultPrevented) {
                            // Some other error handler has prevented default.
                            // Browsers silence the error report if this happens.
                            // We'll remember this to later decide whether to log it or not.
                            if (error != null && typeof error === 'object') {
                                try {
                                    error._suppressLogging = true;
                                }
                                catch (inner) { // Ignore.
                                }
                            }
                        }
                    } // Create a fake event type.
                    var evtType = "react-" + (name ? name : 'invokeguardedcallback'); // Attach our event handlers
                    window.addEventListener('error', handleWindowError);
                    fakeNode.addEventListener(evtType, callCallback, false); // Synchronously dispatch our fake event. If the user-provided function
                    // errors, it will trigger our global error handler.
                    evt.initEvent(evtType, false, false);
                    fakeNode.dispatchEvent(evt);
                    if (windowEventDescriptor) {
                        Object.defineProperty(window, 'event', windowEventDescriptor);
                    }
                    if (didCall && didError) {
                        if (!didSetError) {
                            // The callback errored, but the error event never fired.
                            // eslint-disable-next-line react-internal/prod-error-codes
                            error = new Error('An error was thrown inside one of your components, but React ' + "doesn't know what it was. This is likely due to browser " + 'flakiness. React does its best to preserve the "Pause on ' + 'exceptions" behavior of the DevTools, which requires some ' + "DEV-mode only tricks. It's possible that these don't work in " + 'your browser. Try triggering the error in production mode, ' + 'or switching to a modern browser. If you suspect that this is ' + 'actually an issue with React, please file an issue.');
                        }
                        else if (isCrossOriginError) {
                            // eslint-disable-next-line react-internal/prod-error-codes
                            error = new Error("A cross-origin error was thrown. React doesn't have access to " + 'the actual error object in development. ' + 'See https://reactjs.org/link/crossorigin-error for more information.');
                        }
                        this.onError(error);
                    } // Remove our event listeners
                    window.removeEventListener('error', handleWindowError);
                    if (!didCall) {
                        // Something went really wrong, and our event was not dispatched.
                        // https://github.com/facebook/react/issues/16734
                        // https://github.com/facebook/react/issues/16585
                        // Fall back to the production implementation.
                        restoreAfterDispatch();
                        return invokeGuardedCallbackProd.apply(this, arguments);
                    }
                };
            }
        }
        var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;
        var hasError = false;
        var caughtError = null; // Used by event system to capture/rethrow the first error.
        var hasRethrowError = false;
        var rethrowError = null;
        var reporter = {
            onError: function (error) {
                hasError = true;
                caughtError = error;
            }
        };
        /**
         * Call a function while guarding against errors that happens within it.
         * Returns an error if it throws, otherwise null.
         *
         * In production, this is implemented using a try-catch. The reason we don't
         * use a try-catch directly is so that we can swap out a different
         * implementation in DEV mode.
         *
         * @param {String} name of the guard to use for logging or debugging
         * @param {Function} func The function to invoke
         * @param {*} context The context to use when calling the function
         * @param {...*} args Arguments for function
         */
        function invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {
            hasError = false;
            caughtError = null;
            invokeGuardedCallbackImpl$1.apply(reporter, arguments);
        }
        /**
         * Same as invokeGuardedCallback, but instead of returning an error, it stores
         * it in a global so it can be rethrown by `rethrowCaughtError` later.
         * TODO: See if caughtError and rethrowError can be unified.
         *
         * @param {String} name of the guard to use for logging or debugging
         * @param {Function} func The function to invoke
         * @param {*} context The context to use when calling the function
         * @param {...*} args Arguments for function
         */
        function invokeGuardedCallbackAndCatchFirstError(name, func, context, a, b, c, d, e, f) {
            invokeGuardedCallback.apply(this, arguments);
            if (hasError) {
                var error = clearCaughtError();
                if (!hasRethrowError) {
                    hasRethrowError = true;
                    rethrowError = error;
                }
            }
        }
        /**
         * During execution of guarded functions we will capture the first error which
         * we will rethrow to be handled by the top level error handler.
         */
        function rethrowCaughtError() {
            if (hasRethrowError) {
                var error = rethrowError;
                hasRethrowError = false;
                rethrowError = null;
                throw error;
            }
        }
        function clearCaughtError() {
            if (hasError) {
                var error = caughtError;
                hasError = false;
                caughtError = null;
                return error;
            }
            else {
                throw new Error('clearCaughtError was called but no error was captured. This error ' + 'is likely caused by a bug in React. Please file an issue.');
            }
        }
        var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare
        function isArray(a) {
            return isArrayImpl(a);
        }
        var SecretInternals = ReactDOM.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        var EventInternals = SecretInternals.Events;
        var getInstanceFromNode = EventInternals[0];
        var getNodeFromInstance = EventInternals[1];
        var getFiberCurrentPropsFromNode = EventInternals[2];
        var enqueueStateRestore = EventInternals[3];
        var restoreStateIfNeeded = EventInternals[4];
        var reactAct = React.unstable_act;
        function Event(suffix) { }
        var hasWarnedAboutDeprecatedMockComponent = false;
        /**
         * @class ReactTestUtils
         */
        function findAllInRenderedFiberTreeInternal(fiber, test) {
            if (!fiber) {
                return [];
            }
            var currentParent = findCurrentFiberUsingSlowPath(fiber);
            if (!currentParent) {
                return [];
            }
            var node = currentParent;
            var ret = [];
            while (true) {
                if (node.tag === HostComponent || node.tag === HostText || node.tag === ClassComponent || node.tag === FunctionComponent) {
                    var publicInst = node.stateNode;
                    if (test(publicInst)) {
                        ret.push(publicInst);
                    }
                }
                if (node.child) {
                    node.child.return = node;
                    node = node.child;
                    continue;
                }
                if (node === currentParent) {
                    return ret;
                }
                while (!node.sibling) {
                    if (!node.return || node.return === currentParent) {
                        return ret;
                    }
                    node = node.return;
                }
                node.sibling.return = node.return;
                node = node.sibling;
            }
        }
        function validateClassInstance(inst, methodName) {
            if (!inst) {
                // This is probably too relaxed but it's existing behavior.
                return;
            }
            if (get(inst)) {
                // This is a public instance indeed.
                return;
            }
            var received;
            var stringified = String(inst);
            if (isArray(inst)) {
                received = 'an array';
            }
            else if (inst && inst.nodeType === ELEMENT_NODE && inst.tagName) {
                received = 'a DOM node';
            }
            else if (stringified === '[object Object]') {
                received = 'object with keys {' + Object.keys(inst).join(', ') + '}';
            }
            else {
                received = stringified;
            }
            throw new Error(methodName + "(...): the first argument must be a React class instance. " + ("Instead received: " + received + "."));
        }
        /**
         * Utilities for making it easy to test React components.
         *
         * See https://reactjs.org/docs/test-utils.html
         *
         * Todo: Support the entire DOM.scry query syntax. For now, these simple
         * utilities will suffice for testing purposes.
         * @lends ReactTestUtils
         */
        var didWarnAboutReactTestUtilsDeprecation = false;
        function renderIntoDocument(element) {
            {
                if (!didWarnAboutReactTestUtilsDeprecation) {
                    didWarnAboutReactTestUtilsDeprecation = true;
                    error('ReactDOMTestUtils is deprecated and will be removed in a future ' + 'major release, because it exposes internal implementation details ' + 'that are highly likely to change between releases. Upgrade to a ' + 'modern testing library, such as @testing-library/react. See ' + 'https://react.dev/warnings/react-dom-test-utils for more info.');
                }
            }
            var div = document.createElement('div'); // None of our tests actually require attaching the container to the
            // DOM, and doing so creates a mess that we rely on test isolation to
            // clean up, so we're going to stop honoring the name of this method
            // (and probably rename it eventually) if no problems arise.
            // document.documentElement.appendChild(div);
            return ReactDOM.render(element, div);
        }
        function isElement(element) {
            return React.isValidElement(element);
        }
        function isElementOfType(inst, convenienceConstructor) {
            return React.isValidElement(inst) && inst.type === convenienceConstructor;
        }
        function isDOMComponent(inst) {
            return !!(inst && inst.nodeType === ELEMENT_NODE && inst.tagName);
        }
        function isDOMComponentElement(inst) {
            return !!(inst && React.isValidElement(inst) && !!inst.tagName);
        }
        function isCompositeComponent(inst) {
            if (isDOMComponent(inst)) {
                // Accessing inst.setState warns; just return false as that'll be what
                // this returns when we have DOM nodes as refs directly
                return false;
            }
            return inst != null && typeof inst.render === 'function' && typeof inst.setState === 'function';
        }
        function isCompositeComponentWithType(inst, type) {
            if (!isCompositeComponent(inst)) {
                return false;
            }
            var internalInstance = get(inst);
            var constructor = internalInstance.type;
            return constructor === type;
        }
        function findAllInRenderedTree(inst, test) {
            validateClassInstance(inst, 'findAllInRenderedTree');
            if (!inst) {
                return [];
            }
            var internalInstance = get(inst);
            return findAllInRenderedFiberTreeInternal(internalInstance, test);
        }
        /**
         * Finds all instances of components in the rendered tree that are DOM
         * components with the class name matching `className`.
         * @return {array} an array of all the matches.
         */
        function scryRenderedDOMComponentsWithClass(root, classNames) {
            validateClassInstance(root, 'scryRenderedDOMComponentsWithClass');
            return findAllInRenderedTree(root, function (inst) {
                if (isDOMComponent(inst)) {
                    var className = inst.className;
                    if (typeof className !== 'string') {
                        // SVG, probably.
                        className = inst.getAttribute('class') || '';
                    }
                    var classList = className.split(/\s+/);
                    if (!isArray(classNames)) {
                        if (classNames === undefined) {
                            throw new Error('TestUtils.scryRenderedDOMComponentsWithClass expects a ' + 'className as a second argument.');
                        }
                        classNames = classNames.split(/\s+/);
                    }
                    return classNames.every(function (name) {
                        return classList.indexOf(name) !== -1;
                    });
                }
                return false;
            });
        }
        /**
         * Like scryRenderedDOMComponentsWithClass but expects there to be one result,
         * and returns that one result, or throws exception if there is any other
         * number of matches besides one.
         * @return {!ReactDOMComponent} The one match.
         */
        function findRenderedDOMComponentWithClass(root, className) {
            validateClassInstance(root, 'findRenderedDOMComponentWithClass');
            var all = scryRenderedDOMComponentsWithClass(root, className);
            if (all.length !== 1) {
                throw new Error('Did not find exactly one match (found: ' + all.length + ') ' + 'for class:' + className);
            }
            return all[0];
        }
        /**
         * Finds all instances of components in the rendered tree that are DOM
         * components with the tag name matching `tagName`.
         * @return {array} an array of all the matches.
         */
        function scryRenderedDOMComponentsWithTag(root, tagName) {
            validateClassInstance(root, 'scryRenderedDOMComponentsWithTag');
            return findAllInRenderedTree(root, function (inst) {
                return isDOMComponent(inst) && inst.tagName.toUpperCase() === tagName.toUpperCase();
            });
        }
        /**
         * Like scryRenderedDOMComponentsWithTag but expects there to be one result,
         * and returns that one result, or throws exception if there is any other
         * number of matches besides one.
         * @return {!ReactDOMComponent} The one match.
         */
        function findRenderedDOMComponentWithTag(root, tagName) {
            validateClassInstance(root, 'findRenderedDOMComponentWithTag');
            var all = scryRenderedDOMComponentsWithTag(root, tagName);
            if (all.length !== 1) {
                throw new Error('Did not find exactly one match (found: ' + all.length + ') ' + 'for tag:' + tagName);
            }
            return all[0];
        }
        /**
         * Finds all instances of components with type equal to `componentType`.
         * @return {array} an array of all the matches.
         */
        function scryRenderedComponentsWithType(root, componentType) {
            validateClassInstance(root, 'scryRenderedComponentsWithType');
            return findAllInRenderedTree(root, function (inst) {
                return isCompositeComponentWithType(inst, componentType);
            });
        }
        /**
         * Same as `scryRenderedComponentsWithType` but expects there to be one result
         * and returns that one result, or throws exception if there is any other
         * number of matches besides one.
         * @return {!ReactComponent} The one match.
         */
        function findRenderedComponentWithType(root, componentType) {
            validateClassInstance(root, 'findRenderedComponentWithType');
            var all = scryRenderedComponentsWithType(root, componentType);
            if (all.length !== 1) {
                throw new Error('Did not find exactly one match (found: ' + all.length + ') ' + 'for componentType:' + componentType);
            }
            return all[0];
        }
        /**
         * Pass a mocked component module to this method to augment it with
         * useful methods that allow it to be used as a dummy React component.
         * Instead of rendering as usual, the component will become a simple
         * <div> containing any provided children.
         *
         * @param {object} module the mock function object exported from a
         *                        module that defines the component to be mocked
         * @param {?string} mockTagName optional dummy root tag name to return
         *                              from render method (overrides
         *                              module.mockTagName if provided)
         * @return {object} the ReactTestUtils object (for chaining)
         */
        function mockComponent(module, mockTagName) {
            {
                if (!hasWarnedAboutDeprecatedMockComponent) {
                    hasWarnedAboutDeprecatedMockComponent = true;
                    warn('ReactTestUtils.mockComponent() is deprecated. ' + 'Use shallow rendering or jest.mock() instead.\n\n' + 'See https://reactjs.org/link/test-utils-mock-component for more information.');
                }
            }
            mockTagName = mockTagName || module.mockTagName || 'div';
            module.prototype.render.mockImplementation(function () {
                return React.createElement(mockTagName, null, this.props.children);
            });
            return this;
        }
        function nativeTouchData(x, y) {
            return {
                touches: [{
                        pageX: x,
                        pageY: y
                    }]
            };
        } // Start of inline: the below functions were inlined from
        // EventPropagator.js, as they deviated from ReactDOM's newer
        // implementations.
        /**
         * Dispatch the event to the listener.
         * @param {SyntheticEvent} event SyntheticEvent to handle
         * @param {function} listener Application-level callback
         * @param {*} inst Internal component instance
         */
        function executeDispatch(event, listener, inst) {
            var type = event.type || 'unknown-event';
            event.currentTarget = getNodeFromInstance(inst);
            invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);
            event.currentTarget = null;
        }
        /**
         * Standard/simple iteration through an event's collected dispatches.
         */
        function executeDispatchesInOrder(event) {
            var dispatchListeners = event._dispatchListeners;
            var dispatchInstances = event._dispatchInstances;
            if (isArray(dispatchListeners)) {
                for (var i = 0; i < dispatchListeners.length; i++) {
                    if (event.isPropagationStopped()) {
                        break;
                    } // Listeners and Instances are two parallel arrays that are always in sync.
                    executeDispatch(event, dispatchListeners[i], dispatchInstances[i]);
                }
            }
            else if (dispatchListeners) {
                executeDispatch(event, dispatchListeners, dispatchInstances);
            }
            event._dispatchListeners = null;
            event._dispatchInstances = null;
        }
        /**
         * Dispatches an event and releases it back into the pool, unless persistent.
         *
         * @param {?object} event Synthetic event to be dispatched.
         * @private
         */
        var executeDispatchesAndRelease = function (event) {
            if (event) {
                executeDispatchesInOrder(event);
                if (!event.isPersistent()) {
                    event.constructor.release(event);
                }
            }
        };
        function isInteractive(tag) {
            return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
        }
        function getParent(inst) {
            do {
                inst = inst.return; // TODO: If this is a HostRoot we might want to bail out.
                // That is depending on if we want nested subtrees (layers) to bubble
                // events to their parent. We could also go through parentNode on the
                // host node but that wouldn't work for React Native and doesn't let us
                // do the portal feature.
            } while (inst && inst.tag !== HostComponent);
            if (inst) {
                return inst;
            }
            return null;
        }
        /**
         * Simulates the traversal of a two-phase, capture/bubble event dispatch.
         */
        function traverseTwoPhase(inst, fn, arg) {
            var path = [];
            while (inst) {
                path.push(inst);
                inst = getParent(inst);
            }
            var i;
            for (i = path.length; i-- > 0;) {
                fn(path[i], 'captured', arg);
            }
            for (i = 0; i < path.length; i++) {
                fn(path[i], 'bubbled', arg);
            }
        }
        function shouldPreventMouseEvent(name, type, props) {
            switch (name) {
                case 'onClick':
                case 'onClickCapture':
                case 'onDoubleClick':
                case 'onDoubleClickCapture':
                case 'onMouseDown':
                case 'onMouseDownCapture':
                case 'onMouseMove':
                case 'onMouseMoveCapture':
                case 'onMouseUp':
                case 'onMouseUpCapture':
                case 'onMouseEnter':
                    return !!(props.disabled && isInteractive(type));
                default:
                    return false;
            }
        }
        /**
         * @param {object} inst The instance, which is the source of events.
         * @param {string} registrationName Name of listener (e.g. `onClick`).
         * @return {?function} The stored callback.
         */
        function getListener(inst, registrationName) {
            // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not
            // live here; needs to be moved to a better place soon
            var stateNode = inst.stateNode;
            if (!stateNode) {
                // Work in progress (ex: onload events in incremental mode).
                return null;
            }
            var props = getFiberCurrentPropsFromNode(stateNode);
            if (!props) {
                // Work in progress.
                return null;
            }
            var listener = props[registrationName];
            if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
                return null;
            }
            if (listener && typeof listener !== 'function') {
                throw new Error("Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof listener + "` type.");
            }
            return listener;
        }
        function listenerAtPhase(inst, event, propagationPhase) {
            var registrationName = event._reactName;
            if (propagationPhase === 'captured') {
                registrationName += 'Capture';
            }
            return getListener(inst, registrationName);
        }
        function accumulateDispatches(inst, ignoredDirection, event) {
            if (inst && event && event._reactName) {
                var registrationName = event._reactName;
                var listener = getListener(inst, registrationName);
                if (listener) {
                    if (event._dispatchListeners == null) {
                        event._dispatchListeners = [];
                    }
                    if (event._dispatchInstances == null) {
                        event._dispatchInstances = [];
                    }
                    event._dispatchListeners.push(listener);
                    event._dispatchInstances.push(inst);
                }
            }
        }
        function accumulateDirectionalDispatches(inst, phase, event) {
            {
                if (!inst) {
                    error('Dispatching inst must not be null');
                }
            }
            var listener = listenerAtPhase(inst, event, phase);
            if (listener) {
                if (event._dispatchListeners == null) {
                    event._dispatchListeners = [];
                }
                if (event._dispatchInstances == null) {
                    event._dispatchInstances = [];
                }
                event._dispatchListeners.push(listener);
                event._dispatchInstances.push(inst);
            }
        }
        function accumulateDirectDispatchesSingle(event) {
            if (event && event._reactName) {
                accumulateDispatches(event._targetInst, null, event);
            }
        }
        function accumulateTwoPhaseDispatchesSingle(event) {
            if (event && event._reactName) {
                traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
            }
        } // End of inline
        var Simulate = {};
        var directDispatchEventTypes = new Set(['mouseEnter', 'mouseLeave', 'pointerEnter', 'pointerLeave']);
        /**
         * Exports:
         *
         * - `Simulate.click(Element)`
         * - `Simulate.mouseMove(Element)`
         * - `Simulate.change(Element)`
         * - ... (All keys from event plugin `eventTypes` objects)
         */
        function makeSimulator(eventType) {
            return function (domNode, eventData) {
                if (React.isValidElement(domNode)) {
                    throw new Error('TestUtils.Simulate expected a DOM node as the first argument but received ' + 'a React element. Pass the DOM node you wish to simulate the event on instead. ' + 'Note that TestUtils.Simulate will not work if you are using shallow rendering.');
                }
                if (isCompositeComponent(domNode)) {
                    throw new Error('TestUtils.Simulate expected a DOM node as the first argument but received ' + 'a component instance. Pass the DOM node you wish to simulate the event on instead.');
                }
                var reactName = 'on' + eventType[0].toUpperCase() + eventType.slice(1);
                var fakeNativeEvent = new Event();
                fakeNativeEvent.target = domNode;
                fakeNativeEvent.type = eventType.toLowerCase();
                var targetInst = getInstanceFromNode(domNode);
                var event = new SyntheticEvent(reactName, fakeNativeEvent.type, targetInst, fakeNativeEvent, domNode); // Since we aren't using pooling, always persist the event. This will make
                // sure it's marked and won't warn when setting additional properties.
                event.persist();
                assign(event, eventData);
                if (directDispatchEventTypes.has(eventType)) {
                    accumulateDirectDispatchesSingle(event);
                }
                else {
                    accumulateTwoPhaseDispatchesSingle(event);
                }
                ReactDOM.unstable_batchedUpdates(function () {
                    // Normally extractEvent enqueues a state restore, but we'll just always
                    // do that since we're by-passing it here.
                    enqueueStateRestore(domNode);
                    executeDispatchesAndRelease(event);
                    rethrowCaughtError();
                });
                restoreStateIfNeeded();
            };
        } // A one-time snapshot with no plans to update. We'll probably want to deprecate Simulate API.
        var simulatedEventTypes = ['blur', 'cancel', 'click', 'close', 'contextMenu', 'copy', 'cut', 'auxClick', 'doubleClick', 'dragEnd', 'dragStart', 'drop', 'focus', 'input', 'invalid', 'keyDown', 'keyPress', 'keyUp', 'mouseDown', 'mouseUp', 'paste', 'pause', 'play', 'pointerCancel', 'pointerDown', 'pointerUp', 'rateChange', 'reset', 'resize', 'seeked', 'submit', 'touchCancel', 'touchEnd', 'touchStart', 'volumeChange', 'drag', 'dragEnter', 'dragExit', 'dragLeave', 'dragOver', 'mouseMove', 'mouseOut', 'mouseOver', 'pointerMove', 'pointerOut', 'pointerOver', 'scroll', 'toggle', 'touchMove', 'wheel', 'abort', 'animationEnd', 'animationIteration', 'animationStart', 'canPlay', 'canPlayThrough', 'durationChange', 'emptied', 'encrypted', 'ended', 'error', 'gotPointerCapture', 'load', 'loadedData', 'loadedMetadata', 'loadStart', 'lostPointerCapture', 'playing', 'progress', 'seeking', 'stalled', 'suspend', 'timeUpdate', 'transitionEnd', 'waiting', 'mouseEnter', 'mouseLeave', 'pointerEnter', 'pointerLeave', 'change', 'select', 'beforeInput', 'compositionEnd', 'compositionStart', 'compositionUpdate'];
        function buildSimulators() {
            simulatedEventTypes.forEach(function (eventType) {
                Simulate[eventType] = makeSimulator(eventType);
            });
        }
        buildSimulators();
        var didWarnAboutUsingAct = false;
        var act = function actWithWarning(callback) {
            {
                if (!didWarnAboutUsingAct) {
                    didWarnAboutUsingAct = true;
                    error('`ReactDOMTestUtils.act` is deprecated in favor of `React.act`. ' + 'Import `act` from `react` instead of `react-dom/test-utils`. ' + 'See https://react.dev/warnings/react-dom-test-utils for more info.');
                }
            }
            return reactAct(callback);
        };
        exports.Simulate = Simulate;
        exports.act = act;
        exports.findAllInRenderedTree = findAllInRenderedTree;
        exports.findRenderedComponentWithType = findRenderedComponentWithType;
        exports.findRenderedDOMComponentWithClass = findRenderedDOMComponentWithClass;
        exports.findRenderedDOMComponentWithTag = findRenderedDOMComponentWithTag;
        exports.isCompositeComponent = isCompositeComponent;
        exports.isCompositeComponentWithType = isCompositeComponentWithType;
        exports.isDOMComponent = isDOMComponent;
        exports.isDOMComponentElement = isDOMComponentElement;
        exports.isElement = isElement;
        exports.isElementOfType = isElementOfType;
        exports.mockComponent = mockComponent;
        exports.nativeTouchData = nativeTouchData;
        exports.renderIntoDocument = renderIntoDocument;
        exports.scryRenderedComponentsWithType = scryRenderedComponentsWithType;
        exports.scryRenderedDOMComponentsWithClass = scryRenderedDOMComponentsWithClass;
        exports.scryRenderedDOMComponentsWithTag = scryRenderedDOMComponentsWithTag;
        exports.traverseTwoPhase = traverseTwoPhase;
    })();
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiRDpcXFByb2plY3RzXFxDYXJkRXZlcnl0aGluZ1xcY2FyZGFsbC1wcm90b3R5cGVcXG5vZGVfbW9kdWxlc1xccmVhY3QtZG9tXFxjanNcXHJlYWN0LWRvbS10ZXN0LXV0aWxzLmRldmVsb3BtZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztHQVFHO0FBRUgsWUFBWSxDQUFDO0FBRWIsSUFBSSxPQUFPLENBQUMsR0FBRyxDQUFDLFFBQVEsS0FBSyxZQUFZLEVBQUUsQ0FBQztJQUMxQyxDQUFDO1FBQ0gsWUFBWSxDQUFDO1FBRWIsSUFBSSxLQUFLLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQzdCLElBQUksUUFBUSxHQUFHLE9BQU8sQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUVwQyxJQUFJLG9CQUFvQixHQUFHLEtBQUssQ0FBQyxrREFBa0QsQ0FBQztRQUVwRiwrQ0FBK0M7UUFDL0MsRUFBRTtRQUNGLDhEQUE4RDtRQUM5RCxxQ0FBcUM7UUFFckMsU0FBUyxJQUFJLENBQUMsTUFBTTtZQUNsQixDQUFDO2dCQUNDLENBQUM7b0JBQ0MsS0FBSyxJQUFJLElBQUksR0FBRyxTQUFTLENBQUMsTUFBTSxFQUFFLElBQUksR0FBRyxJQUFJLEtBQUssQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLEdBQUcsQ0FBQyxFQUFFLElBQUksR0FBRyxJQUFJLEVBQUUsSUFBSSxFQUFFLEVBQUUsQ0FBQzt3QkFDM0csSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsR0FBRyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUM7b0JBQ25DLENBQUM7b0JBRUQsWUFBWSxDQUFDLE1BQU0sRUFBRSxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUM7Z0JBQ3JDLENBQUM7WUFDSCxDQUFDO1FBQ0gsQ0FBQztRQUNELFNBQVMsS0FBSyxDQUFDLE1BQU07WUFDbkIsQ0FBQztnQkFDQyxDQUFDO29C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dXJjZXMiOlsiRDpcXFByb2plY3RzXFxDYXJkRXZlcnl0aGluZ1xcY2FyZGFsbC1wcm90b3R5cGVcXG5vZGVfbW9kdWxlc1xccmVhY3QtZG9tXFxjanNcXHJlYWN0LWRvbS10ZXN0LXV0aWxzLmRldmVsb3BtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWRvbS10ZXN0LXV0aWxzLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBSZWFjdERPTSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuLy8gYnkgY2FsbHMgdG8gdGhlc2UgbWV0aG9kcyBieSBhIEJhYmVsIHBsdWdpbi5cbi8vXG4vLyBJbiBQUk9EIChvciBpbiBwYWNrYWdlcyB3aXRob3V0IGFjY2VzcyB0byBSZWFjdCBpbnRlcm5hbHMpLFxuLy8gdGhleSBhcmUgbGVmdCBhcyB0aGV5IGFyZSBpbnN0ZWFkLlxuXG5mdW5jdGlvbiB3YXJuKGZvcm1hdCkge1xuICB7XG4gICAge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nKCd3YXJuJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xuICB7XG4gICAge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XG4gIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cbiAge1xuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcblxuICAgIGlmIChzdGFjayAhPT0gJycpIHtcbiAgICAgIGZvcm1hdCArPSAnJXMnO1xuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG5cblxuICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKGl0ZW0pO1xuICAgIH0pOyAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxuXG4gICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gIH1cbn1cblxuLyoqXG4gKiBgUmVhY3RJbnN0YW5jZU1hcGAgbWFpbnRhaW5zIGEgbWFwcGluZyBmcm9tIGEgcHVibGljIGZhY2luZyBzdGF0ZWZ1bFxuICogaW5zdGFuY2UgKGtleSkgYW5kIHRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiAodmFsdWUpLiBUaGlzIGFsbG93cyBwdWJsaWNcbiAqIG1ldGhvZHMgdG8gYWNjZXB0IHRoZSB1c2VyIGZhY2luZyBpbnN0YW5jZSBhcyBhbiBhcmd1bWVudCBhbmQgbWFwIHRoZW0gYmFja1xuICogdG8gaW50ZXJuYWwgbWV0aG9kcy5cbiAqXG4gKiBOb3RlIHRoYXQgdGhpcyBtb2R1bGUgaXMgY3VycmVudGx5IHNoYXJlZCBhbmQgYXNzdW1lZCB0byBiZSBzdGF0ZWxlc3MuXG4gKiBJZiB0aGlzIGJlY29tZXMgYW4gYWN0dWFsIE1hcCwgdGhhdCB3aWxsIGJyZWFrLlxuICovXG5mdW5jdGlvbiBnZXQoa2V5KSB7XG4gIHJldHVybiBrZXkuX3JlYWN0SW50ZXJuYWxzO1xufVxuXG52YXIgRnVuY3Rpb25Db21wb25lbnQgPSAwO1xudmFyIENsYXNzQ29tcG9uZW50ID0gMTtcblxudmFyIEhvc3RSb290ID0gMzsgLy8gUm9vdCBvZiBhIGhvc3QgdHJlZS4gQ291bGQgYmUgbmVzdGVkIGluc2lkZSBhbm90aGVyIG5vZGUuXG5cbnZhciBIb3N0Q29tcG9uZW50ID0gNTtcbnZhciBIb3N0VGV4dCA9IDY7XG5cbi8vIERvbid0IGNoYW5nZSB0aGVzZSB0d28gdmFsdWVzLiBUaGV5J3JlIHVzZWQgYnkgUmVhY3QgRGV2IFRvb2xzLlxudmFyIE5vRmxhZ3MgPVxuLyogICAgICAgICAgICAgICAgICAgICAgKi9cbjA7XG5cbnZhciBQbGFjZW1lbnQgPVxuLyogICAgICAgICAgICAgICAgICAgICovXG4yO1xudmFyIEh5ZHJhdGluZyA9XG4vKiAgICAgICAgICAgICAgICAgICAgKi9cbjQwOTY7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xuZnVuY3Rpb24gZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcihmaWJlcikge1xuICB2YXIgbm9kZSA9IGZpYmVyO1xuICB2YXIgbmVhcmVzdE1vdW50ZWQgPSBmaWJlcjtcblxuICBpZiAoIWZpYmVyLmFsdGVybmF0ZSkge1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIGFsdGVybmF0ZSwgdGhpcyBtaWdodCBiZSBhIG5ldyB0cmVlIHRoYXQgaXNuJ3QgaW5zZXJ0ZWRcbiAgICAvLyB5ZXQuIElmIGl0IGlzLCB0aGVuIGl0IHdpbGwgaGF2ZSBhIHBlbmRpbmcgaW5zZXJ0aW9uIGVmZmVjdCBvbiBpdC5cbiAgICB2YXIgbmV4dE5vZGUgPSBub2RlO1xuXG4gICAgZG8ge1xuICAgICAgbm9kZSA9IG5leHROb2RlO1xuXG4gICAgICBpZiAoKG5vZGUuZmxhZ3MgJiAoUGxhY2VtZW50IHwgSHlkcmF0aW5nKSkgIT09IE5vRmxhZ3MpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhbiBpbnNlcnRpb24gb3IgaW4tcHJvZ3Jlc3MgaHlkcmF0aW9uLiBUaGUgbmVhcmVzdCBwb3NzaWJsZVxuICAgICAgICAvLyBtb3VudGVkIGZpYmVyIGlzIHRoZSBwYXJlbnQgYnV0IHdlIG5lZWQgdG8gY29udGludWUgdG8gZmlndXJlIG91dFxuICAgICAgICAvLyBpZiB0aGF0IG9uZSBpcyBzdGlsbCBtb3VudGVkLlxuICAgICAgICBuZWFyZXN0TW91bnRlZCA9IG5vZGUucmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBuZXh0Tm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH0gd2hpbGUgKG5leHROb2RlKTtcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAobm9kZS5yZXR1cm4pIHtcbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9XG4gIH1cblxuICBpZiAobm9kZS50YWcgPT09IEhvc3RSb290KSB7XG4gICAgLy8gVE9ETzogQ2hlY2sgaWYgdGhpcyB3YXMgYSBuZXN0ZWQgSG9zdFJvb3Qgd2hlbiB1c2VkIHdpdGhcbiAgICAvLyByZW5kZXJDb250YWluZXJJbnRvU3VidHJlZS5cbiAgICByZXR1cm4gbmVhcmVzdE1vdW50ZWQ7XG4gIH0gLy8gSWYgd2UgZGlkbid0IGhpdCB0aGUgcm9vdCwgdGhhdCBtZWFucyB0aGF0IHdlJ3JlIGluIGFuIGRpc2Nvbm5lY3RlZCB0cmVlXG4gIC8vIHRoYXQgaGFzIGJlZW4gdW5tb3VudGVkLlxuXG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGFzc2VydElzTW91bnRlZChmaWJlcikge1xuICBpZiAoZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcihmaWJlcikgIT09IGZpYmVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgoZmliZXIpIHtcbiAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcblxuICBpZiAoIWFsdGVybmF0ZSkge1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIGFsdGVybmF0ZSwgdGhlbiB3ZSBvbmx5IG5lZWQgdG8gY2hlY2sgaWYgaXQgaXMgbW91bnRlZC5cbiAgICB2YXIgbmVhcmVzdE1vdW50ZWQgPSBnZXROZWFyZXN0TW91bnRlZEZpYmVyKGZpYmVyKTtcblxuICAgIGlmIChuZWFyZXN0TW91bnRlZCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJyk7XG4gICAgfVxuXG4gICAgaWYgKG5lYXJlc3RNb3VudGVkICE9PSBmaWJlcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpYmVyO1xuICB9IC8vIElmIHdlIGhhdmUgdHdvIHBvc3NpYmxlIGJyYW5jaGVzLCB3ZSdsbCB3YWxrIGJhY2t3YXJkcyB1cCB0byB0aGUgcm9vdFxuICAvLyB0byBzZWUgd2hhdCBwYXRoIHRoZSByb290IHBvaW50cyB0by4gT24gdGhlIHdheSB3ZSBtYXkgaGl0IG9uZSBvZiB0aGVcbiAgLy8gc3BlY2lhbCBjYXNlcyBhbmQgd2UnbGwgZGVhbCB3aXRoIHRoZW0uXG5cblxuICB2YXIgYSA9IGZpYmVyO1xuICB2YXIgYiA9IGFsdGVybmF0ZTtcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciBwYXJlbnRBID0gYS5yZXR1cm47XG5cbiAgICBpZiAocGFyZW50QSA9PT0gbnVsbCkge1xuICAgICAgLy8gV2UncmUgYXQgdGhlIHJvb3QuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgcGFyZW50QiA9IHBhcmVudEEuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKHBhcmVudEIgPT09IG51bGwpIHtcbiAgICAgIC8vIFRoZXJlIGlzIG5vIGFsdGVybmF0ZS4gVGhpcyBpcyBhbiB1bnVzdWFsIGNhc2UuIEN1cnJlbnRseSwgaXQgb25seVxuICAgICAgLy8gaGFwcGVucyB3aGVuIGEgU3VzcGVuc2UgY29tcG9uZW50IGlzIGhpZGRlbi4gQW4gZXh0cmEgZnJhZ21lbnQgZmliZXJcbiAgICAgIC8vIGlzIGluc2VydGVkIGluIGJldHdlZW4gdGhlIFN1c3BlbnNlIGZpYmVyIGFuZCBpdHMgY2hpbGRyZW4uIFNraXBcbiAgICAgIC8vIG92ZXIgdGhpcyBleHRyYSBmcmFnbWVudCBmaWJlciBhbmQgcHJvY2VlZCB0byB0aGUgbmV4dCBwYXJlbnQuXG4gICAgICB2YXIgbmV4dFBhcmVudCA9IHBhcmVudEEucmV0dXJuO1xuXG4gICAgICBpZiAobmV4dFBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgICBhID0gYiA9IG5leHRQYXJlbnQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBJZiB0aGVyZSdzIG5vIHBhcmVudCwgd2UncmUgYXQgdGhlIHJvb3QuXG5cblxuICAgICAgYnJlYWs7XG4gICAgfSAvLyBJZiBib3RoIGNvcGllcyBvZiB0aGUgcGFyZW50IGZpYmVyIHBvaW50IHRvIHRoZSBzYW1lIGNoaWxkLCB3ZSBjYW5cbiAgICAvLyBhc3N1bWUgdGhhdCB0aGUgY2hpbGQgaXMgY3VycmVudC4gVGhpcyBoYXBwZW5zIHdoZW4gd2UgYmFpbG91dCBvbiBsb3dcbiAgICAvLyBwcmlvcml0eTogdGhlIGJhaWxlZCBvdXQgZmliZXIncyBjaGlsZCByZXVzZXMgdGhlIGN1cnJlbnQgY2hpbGQuXG5cblxuICAgIGlmIChwYXJlbnRBLmNoaWxkID09PSBwYXJlbnRCLmNoaWxkKSB7XG4gICAgICB2YXIgY2hpbGQgPSBwYXJlbnRBLmNoaWxkO1xuXG4gICAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgICAgaWYgKGNoaWxkID09PSBhKSB7XG4gICAgICAgICAgLy8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IEEgaXMgdGhlIGN1cnJlbnQgYnJhbmNoLlxuICAgICAgICAgIGFzc2VydElzTW91bnRlZChwYXJlbnRBKTtcbiAgICAgICAgICByZXR1cm4gZmliZXI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2hpbGQgPT09IGIpIHtcbiAgICAgICAgICAvLyBXZSd2ZSBkZXRlcm1pbmVkIHRoYXQgQiBpcyB0aGUgY3VycmVudCBicmFuY2guXG4gICAgICAgICAgYXNzZXJ0SXNNb3VudGVkKHBhcmVudEEpO1xuICAgICAgICAgIHJldHVybiBhbHRlcm5hdGU7XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgICB9IC8vIFdlIHNob3VsZCBuZXZlciBoYXZlIGFuIGFsdGVybmF0ZSBmb3IgYW55IG1vdW50aW5nIG5vZGUuIFNvIHRoZSBvbmx5XG4gICAgICAvLyB3YXkgdGhpcyBjb3VsZCBwb3NzaWJseSBoYXBwZW4gaXMgaWYgdGhpcyB3YXMgdW5tb3VudGVkLCBpZiBhdCBhbGwuXG5cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJyk7XG4gICAgfVxuXG4gICAgaWYgKGEucmV0dXJuICE9PSBiLnJldHVybikge1xuICAgICAgLy8gVGhlIHJldHVybiBwb2ludGVyIG9mIEEgYW5kIHRoZSByZXR1cm4gcG9pbnRlciBvZiBCIHBvaW50IHRvIGRpZmZlcmVudFxuICAgICAgLy8gZmliZXJzLiBXZSBhc3N1bWUgdGhhdCByZXR1cm4gcG9pbnRlcnMgbmV2ZXIgY3Jpc3MtY3Jvc3MsIHNvIEEgbXVzdFxuICAgICAgLy8gYmVsb25nIHRvIHRoZSBjaGlsZCBzZXQgb2YgQS5yZXR1cm4sIGFuZCBCIG11c3QgYmVsb25nIHRvIHRoZSBjaGlsZFxuICAgICAgLy8gc2V0IG9mIEIucmV0dXJuLlxuICAgICAgYSA9IHBhcmVudEE7XG4gICAgICBiID0gcGFyZW50QjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIHJldHVybiBwb2ludGVycyBwb2ludCB0byB0aGUgc2FtZSBmaWJlci4gV2UnbGwgaGF2ZSB0byB1c2UgdGhlXG4gICAgICAvLyBkZWZhdWx0LCBzbG93IHBhdGg6IHNjYW4gdGhlIGNoaWxkIHNldHMgb2YgZWFjaCBwYXJlbnQgYWx0ZXJuYXRlIHRvIHNlZVxuICAgICAgLy8gd2hpY2ggY2hpbGQgYmVsb25ncyB0byB3aGljaCBzZXQuXG4gICAgICAvL1xuICAgICAgLy8gU2VhcmNoIHBhcmVudCBBJ3MgY2hpbGQgc2V0XG4gICAgICB2YXIgZGlkRmluZENoaWxkID0gZmFsc2U7XG4gICAgICB2YXIgX2NoaWxkID0gcGFyZW50QS5jaGlsZDtcblxuICAgICAgd2hpbGUgKF9jaGlsZCkge1xuICAgICAgICBpZiAoX2NoaWxkID09PSBhKSB7XG4gICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICBhID0gcGFyZW50QTtcbiAgICAgICAgICBiID0gcGFyZW50QjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfY2hpbGQgPT09IGIpIHtcbiAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgIGIgPSBwYXJlbnRBO1xuICAgICAgICAgIGEgPSBwYXJlbnRCO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgX2NoaWxkID0gX2NoaWxkLnNpYmxpbmc7XG4gICAgICB9XG5cbiAgICAgIGlmICghZGlkRmluZENoaWxkKSB7XG4gICAgICAgIC8vIFNlYXJjaCBwYXJlbnQgQidzIGNoaWxkIHNldFxuICAgICAgICBfY2hpbGQgPSBwYXJlbnRCLmNoaWxkO1xuXG4gICAgICAgIHdoaWxlIChfY2hpbGQpIHtcbiAgICAgICAgICBpZiAoX2NoaWxkID09PSBhKSB7XG4gICAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgICAgYSA9IHBhcmVudEI7XG4gICAgICAgICAgICBiID0gcGFyZW50QTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChfY2hpbGQgPT09IGIpIHtcbiAgICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgICBiID0gcGFyZW50QjtcbiAgICAgICAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX2NoaWxkID0gX2NoaWxkLnNpYmxpbmc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWRpZEZpbmRDaGlsZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2hpbGQgd2FzIG5vdCBmb3VuZCBpbiBlaXRoZXIgcGFyZW50IHNldC4gVGhpcyBpbmRpY2F0ZXMgYSBidWcgJyArICdpbiBSZWFjdCByZWxhdGVkIHRvIHRoZSByZXR1cm4gcG9pbnRlci4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYS5hbHRlcm5hdGUgIT09IGIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlJldHVybiBmaWJlcnMgc2hvdWxkIGFsd2F5cyBiZSBlYWNoIG90aGVycycgYWx0ZXJuYXRlcy4gXCIgKyAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH0gLy8gSWYgdGhlIHJvb3QgaXMgbm90IGEgaG9zdCBjb250YWluZXIsIHdlJ3JlIGluIGEgZGlzY29ubmVjdGVkIHRyZWUuIEkuZS5cbiAgLy8gdW5tb3VudGVkLlxuXG5cbiAgaWYgKGEudGFnICE9PSBIb3N0Um9vdCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO1xuICB9XG5cbiAgaWYgKGEuc3RhdGVOb2RlLmN1cnJlbnQgPT09IGEpIHtcbiAgICAvLyBXZSd2ZSBkZXRlcm1pbmVkIHRoYXQgQSBpcyB0aGUgY3VycmVudCBicmFuY2guXG4gICAgcmV0dXJuIGZpYmVyO1xuICB9IC8vIE90aGVyd2lzZSBCIGhhcyB0byBiZSBjdXJyZW50IGJyYW5jaC5cblxuXG4gIHJldHVybiBhbHRlcm5hdGU7XG59XG5cbnZhciBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuXG4vKipcbiAqIGBjaGFyQ29kZWAgcmVwcmVzZW50cyB0aGUgYWN0dWFsIFwiY2hhcmFjdGVyIGNvZGVcIiBhbmQgaXMgc2FmZSB0byB1c2Ugd2l0aFxuICogYFN0cmluZy5mcm9tQ2hhckNvZGVgLiBBcyBzdWNoLCBvbmx5IGtleXMgdGhhdCBjb3JyZXNwb25kIHRvIHByaW50YWJsZVxuICogY2hhcmFjdGVycyBwcm9kdWNlIGEgdmFsaWQgYGNoYXJDb2RlYCwgdGhlIG9ubHkgZXhjZXB0aW9uIHRvIHRoaXMgaXMgRW50ZXIuXG4gKiBUaGUgVGFiLWtleSBpcyBjb25zaWRlcmVkIG5vbi1wcmludGFibGUgYW5kIGRvZXMgbm90IGhhdmUgYSBgY2hhckNvZGVgLFxuICogcHJlc3VtYWJseSBiZWNhdXNlIGl0IGRvZXMgbm90IHByb2R1Y2UgYSB0YWItY2hhcmFjdGVyIGluIGJyb3dzZXJzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge251bWJlcn0gTm9ybWFsaXplZCBgY2hhckNvZGVgIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBjaGFyQ29kZTtcbiAgdmFyIGtleUNvZGUgPSBuYXRpdmVFdmVudC5rZXlDb2RlO1xuXG4gIGlmICgnY2hhckNvZGUnIGluIG5hdGl2ZUV2ZW50KSB7XG4gICAgY2hhckNvZGUgPSBuYXRpdmVFdmVudC5jaGFyQ29kZTsgLy8gRkYgZG9lcyBub3Qgc2V0IGBjaGFyQ29kZWAgZm9yIHRoZSBFbnRlci1rZXksIGNoZWNrIGFnYWluc3QgYGtleUNvZGVgLlxuXG4gICAgaWYgKGNoYXJDb2RlID09PSAwICYmIGtleUNvZGUgPT09IDEzKSB7XG4gICAgICBjaGFyQ29kZSA9IDEzO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJRTggZG9lcyBub3QgaW1wbGVtZW50IGBjaGFyQ29kZWAsIGJ1dCBga2V5Q29kZWAgaGFzIHRoZSBjb3JyZWN0IHZhbHVlLlxuICAgIGNoYXJDb2RlID0ga2V5Q29kZTtcbiAgfSAvLyBJRSBhbmQgRWRnZSAob24gV2luZG93cykgYW5kIENocm9tZSAvIFNhZmFyaSAob24gV2luZG93cyBhbmQgTGludXgpXG4gIC8vIHJlcG9ydCBFbnRlciBhcyBjaGFyQ29kZSAxMCB3aGVuIGN0cmwgaXMgcHJlc3NlZC5cblxuXG4gIGlmIChjaGFyQ29kZSA9PT0gMTApIHtcbiAgICBjaGFyQ29kZSA9IDEzO1xuICB9IC8vIFNvbWUgbm9uLXByaW50YWJsZSBrZXlzIGFyZSByZXBvcnRlZCBpbiBgY2hhckNvZGVgL2BrZXlDb2RlYCwgZGlzY2FyZCB0aGVtLlxuICAvLyBNdXN0IG5vdCBkaXNjYXJkIHRoZSAobm9uLSlwcmludGFibGUgRW50ZXIta2V5LlxuXG5cbiAgaWYgKGNoYXJDb2RlID49IDMyIHx8IGNoYXJDb2RlID09PSAxMykge1xuICAgIHJldHVybiBjaGFyQ29kZTtcbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBmdW5jdGlvblRoYXRSZXR1cm5zVHJ1ZSgpIHtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGZ1bmN0aW9uVGhhdFJldHVybnNGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufSAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYSBmYWN0b3J5IHNvIHRoYXQgd2UgaGF2ZSBkaWZmZXJlbnQgcmV0dXJuZWQgY29uc3RydWN0b3JzLlxuLy8gSWYgd2UgaGFkIGEgc2luZ2xlIGNvbnN0cnVjdG9yLCBpdCB3b3VsZCBiZSBtZWdhbW9ycGhpYyBhbmQgZW5naW5lcyB3b3VsZCBkZW9wdC5cblxuXG5mdW5jdGlvbiBjcmVhdGVTeW50aGV0aWNFdmVudChJbnRlcmZhY2UpIHtcbiAgLyoqXG4gICAqIFN5bnRoZXRpYyBldmVudHMgYXJlIGRpc3BhdGNoZWQgYnkgZXZlbnQgcGx1Z2lucywgdHlwaWNhbGx5IGluIHJlc3BvbnNlIHRvIGFcbiAgICogdG9wLWxldmVsIGV2ZW50IGRlbGVnYXRpb24gaGFuZGxlci5cbiAgICpcbiAgICogVGhlc2Ugc3lzdGVtcyBzaG91bGQgZ2VuZXJhbGx5IHVzZSBwb29saW5nIHRvIHJlZHVjZSB0aGUgZnJlcXVlbmN5IG9mIGdhcmJhZ2VcbiAgICogY29sbGVjdGlvbi4gVGhlIHN5c3RlbSBzaG91bGQgY2hlY2sgYGlzUGVyc2lzdGVudGAgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlXG4gICAqIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBpbnRvIHRoZSBwb29sIGFmdGVyIGJlaW5nIGRpc3BhdGNoZWQuIFVzZXJzIHRoYXRcbiAgICogbmVlZCBhIHBlcnNpc3RlZCBldmVudCBzaG91bGQgaW52b2tlIGBwZXJzaXN0YC5cbiAgICpcbiAgICogU3ludGhldGljIGV2ZW50cyAoYW5kIHN1YmNsYXNzZXMpIGltcGxlbWVudCB0aGUgRE9NIExldmVsIDMgRXZlbnRzIEFQSSBieVxuICAgKiBub3JtYWxpemluZyBicm93c2VyIHF1aXJrcy4gU3ViY2xhc3NlcyBkbyBub3QgbmVjZXNzYXJpbHkgaGF2ZSB0byBpbXBsZW1lbnQgYVxuICAgKiBET00gaW50ZXJmYWNlOyBjdXN0b20gYXBwbGljYXRpb24tc3BlY2lmaWMgZXZlbnRzIGNhbiBhbHNvIHN1YmNsYXNzIHRoaXMuXG4gICAqL1xuICBmdW5jdGlvbiBTeW50aGV0aWNCYXNlRXZlbnQocmVhY3ROYW1lLCByZWFjdEV2ZW50VHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdGhpcy5fcmVhY3ROYW1lID0gcmVhY3ROYW1lO1xuICAgIHRoaXMuX3RhcmdldEluc3QgPSB0YXJnZXRJbnN0O1xuICAgIHRoaXMudHlwZSA9IHJlYWN0RXZlbnRUeXBlO1xuICAgIHRoaXMubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgICB0aGlzLnRhcmdldCA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICAgIHRoaXMuY3VycmVudFRhcmdldCA9IG51bGw7XG5cbiAgICBmb3IgKHZhciBfcHJvcE5hbWUgaW4gSW50ZXJmYWNlKSB7XG4gICAgICBpZiAoIUludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShfcHJvcE5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgbm9ybWFsaXplID0gSW50ZXJmYWNlW19wcm9wTmFtZV07XG5cbiAgICAgIGlmIChub3JtYWxpemUpIHtcbiAgICAgICAgdGhpc1tfcHJvcE5hbWVdID0gbm9ybWFsaXplKG5hdGl2ZUV2ZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbX3Byb3BOYW1lXSA9IG5hdGl2ZUV2ZW50W19wcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRQcmV2ZW50ZWQgPSBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkICE9IG51bGwgPyBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkIDogbmF0aXZlRXZlbnQucmV0dXJuVmFsdWUgPT09IGZhbHNlO1xuXG4gICAgaWYgKGRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZnVuY3Rpb25UaGF0UmV0dXJuc1RydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZnVuY3Rpb25UaGF0UmV0dXJuc0ZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBmdW5jdGlvblRoYXRSZXR1cm5zRmFsc2U7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBhc3NpZ24oU3ludGhldGljQmFzZUV2ZW50LnByb3RvdHlwZSwge1xuICAgIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuICAgICAgdmFyIGV2ZW50ID0gdGhpcy5uYXRpdmVFdmVudDtcblxuICAgICAgaWYgKCFldmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudC5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAvLyAkRmxvd0ZpeE1lIC0gZmxvdyBpcyBub3QgYXdhcmUgb2YgYHVua25vd25gIGluIElFXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBldmVudC5yZXR1cm5WYWx1ZSAhPT0gJ3Vua25vd24nKSB7XG4gICAgICAgIGV2ZW50LnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZnVuY3Rpb25UaGF0UmV0dXJuc1RydWU7XG4gICAgfSxcbiAgICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBldmVudCA9IHRoaXMubmF0aXZlRXZlbnQ7XG5cbiAgICAgIGlmICghZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXZlbnQuc3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOyAvLyAkRmxvd0ZpeE1lIC0gZmxvdyBpcyBub3QgYXdhcmUgb2YgYHVua25vd25gIGluIElFXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBldmVudC5jYW5jZWxCdWJibGUgIT09ICd1bmtub3duJykge1xuICAgICAgICAvLyBUaGUgQ2hhbmdlRXZlbnRQbHVnaW4gcmVnaXN0ZXJzIGEgXCJwcm9wZXJ0eWNoYW5nZVwiIGV2ZW50IGZvclxuICAgICAgICAvLyBJRS4gVGhpcyBldmVudCBkb2VzIG5vdCBzdXBwb3J0IGJ1YmJsaW5nIG9yIGNhbmNlbGxpbmcsIGFuZFxuICAgICAgICAvLyBhbnkgcmVmZXJlbmNlcyB0byBjYW5jZWxCdWJibGUgdGhyb3cgXCJNZW1iZXIgbm90IGZvdW5kXCIuICBBXG4gICAgICAgIC8vIHR5cGVvZiBjaGVjayBvZiBcInVua25vd25cIiBjaXJjdW12ZW50cyB0aGlzIGlzc3VlIChhbmQgaXMgYWxzb1xuICAgICAgICAvLyBJRSBzcGVjaWZpYykuXG4gICAgICAgIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBmdW5jdGlvblRoYXRSZXR1cm5zVHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2UgcmVsZWFzZSBhbGwgZGlzcGF0Y2hlZCBgU3ludGhldGljRXZlbnRgcyBhZnRlciBlYWNoIGV2ZW50IGxvb3AsIGFkZGluZ1xuICAgICAqIHRoZW0gYmFjayBpbnRvIHRoZSBwb29sLiBUaGlzIGFsbG93cyBhIHdheSB0byBob2xkIG9udG8gYSByZWZlcmVuY2UgdGhhdFxuICAgICAqIHdvbid0IGJlIGFkZGVkIGJhY2sgaW50byB0aGUgcG9vbC5cbiAgICAgKi9cbiAgICBwZXJzaXN0OiBmdW5jdGlvbiAoKSB7Ly8gTW9kZXJuIGV2ZW50IHN5c3RlbSBkb2Vzbid0IHVzZSBwb29saW5nLlxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhpcyBldmVudCBzaG91bGQgYmUgcmVsZWFzZWQgYmFjayBpbnRvIHRoZSBwb29sLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGlzIHNob3VsZCBub3QgYmUgcmVsZWFzZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBpc1BlcnNpc3RlbnQ6IGZ1bmN0aW9uVGhhdFJldHVybnNUcnVlXG4gIH0pO1xuICByZXR1cm4gU3ludGhldGljQmFzZUV2ZW50O1xufVxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xuXG5cbnZhciBFdmVudEludGVyZmFjZSA9IHtcbiAgZXZlbnRQaGFzZTogMCxcbiAgYnViYmxlczogMCxcbiAgY2FuY2VsYWJsZTogMCxcbiAgdGltZVN0YW1wOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQudGltZVN0YW1wIHx8IERhdGUubm93KCk7XG4gIH0sXG4gIGRlZmF1bHRQcmV2ZW50ZWQ6IDAsXG4gIGlzVHJ1c3RlZDogMFxufTtcbnZhciBTeW50aGV0aWNFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KEV2ZW50SW50ZXJmYWNlKTtcblxudmFyIFVJRXZlbnRJbnRlcmZhY2UgPSBhc3NpZ24oe30sIEV2ZW50SW50ZXJmYWNlLCB7XG4gIHZpZXc6IDAsXG4gIGRldGFpbDogMFxufSk7XG5cbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoVUlFdmVudEludGVyZmFjZSk7XG52YXIgbGFzdE1vdmVtZW50WDtcbnZhciBsYXN0TW92ZW1lbnRZO1xudmFyIGxhc3RNb3VzZUV2ZW50O1xuXG5mdW5jdGlvbiB1cGRhdGVNb3VzZU1vdmVtZW50UG9seWZpbGxTdGF0ZShldmVudCkge1xuICBpZiAoZXZlbnQgIT09IGxhc3RNb3VzZUV2ZW50KSB7XG4gICAgaWYgKGxhc3RNb3VzZUV2ZW50ICYmIGV2ZW50LnR5cGUgPT09ICdtb3VzZW1vdmUnKSB7XG4gICAgICBsYXN0TW92ZW1lbnRYID0gZXZlbnQuc2NyZWVuWCAtIGxhc3RNb3VzZUV2ZW50LnNjcmVlblg7XG4gICAgICBsYXN0TW92ZW1lbnRZID0gZXZlbnQuc2NyZWVuWSAtIGxhc3RNb3VzZUV2ZW50LnNjcmVlblk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhc3RNb3ZlbWVudFggPSAwO1xuICAgICAgbGFzdE1vdmVtZW50WSA9IDA7XG4gICAgfVxuXG4gICAgbGFzdE1vdXNlRXZlbnQgPSBldmVudDtcbiAgfVxufVxuLyoqXG4gKiBAaW50ZXJmYWNlIE1vdXNlRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG5cblxudmFyIE1vdXNlRXZlbnRJbnRlcmZhY2UgPSBhc3NpZ24oe30sIFVJRXZlbnRJbnRlcmZhY2UsIHtcbiAgc2NyZWVuWDogMCxcbiAgc2NyZWVuWTogMCxcbiAgY2xpZW50WDogMCxcbiAgY2xpZW50WTogMCxcbiAgcGFnZVg6IDAsXG4gIHBhZ2VZOiAwLFxuICBjdHJsS2V5OiAwLFxuICBzaGlmdEtleTogMCxcbiAgYWx0S2V5OiAwLFxuICBtZXRhS2V5OiAwLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gIGJ1dHRvbjogMCxcbiAgYnV0dG9uczogMCxcbiAgcmVsYXRlZFRhcmdldDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnJlbGF0ZWRUYXJnZXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGV2ZW50LmZyb21FbGVtZW50ID09PSBldmVudC5zcmNFbGVtZW50ID8gZXZlbnQudG9FbGVtZW50IDogZXZlbnQuZnJvbUVsZW1lbnQ7XG4gICAgcmV0dXJuIGV2ZW50LnJlbGF0ZWRUYXJnZXQ7XG4gIH0sXG4gIG1vdmVtZW50WDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKCdtb3ZlbWVudFgnIGluIGV2ZW50KSB7XG4gICAgICByZXR1cm4gZXZlbnQubW92ZW1lbnRYO1xuICAgIH1cblxuICAgIHVwZGF0ZU1vdXNlTW92ZW1lbnRQb2x5ZmlsbFN0YXRlKGV2ZW50KTtcbiAgICByZXR1cm4gbGFzdE1vdmVtZW50WDtcbiAgfSxcbiAgbW92ZW1lbnRZOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoJ21vdmVtZW50WScgaW4gZXZlbnQpIHtcbiAgICAgIHJldHVybiBldmVudC5tb3ZlbWVudFk7XG4gICAgfSAvLyBEb24ndCBuZWVkIHRvIGNhbGwgdXBkYXRlTW91c2VNb3ZlbWVudFBvbHlmaWxsU3RhdGUoKSBoZXJlXG4gICAgLy8gYmVjYXVzZSBpdCdzIGd1YXJhbnRlZWQgdG8gaGF2ZSBhbHJlYWR5IHJ1biB3aGVuIG1vdmVtZW50WFxuICAgIC8vIHdhcyBjb3BpZWQuXG5cblxuICAgIHJldHVybiBsYXN0TW92ZW1lbnRZO1xuICB9XG59KTtcblxudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChNb3VzZUV2ZW50SW50ZXJmYWNlKTtcbi8qKlxuICogQGludGVyZmFjZSBEcmFnRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG5cbnZhciBEcmFnRXZlbnRJbnRlcmZhY2UgPSBhc3NpZ24oe30sIE1vdXNlRXZlbnRJbnRlcmZhY2UsIHtcbiAgZGF0YVRyYW5zZmVyOiAwXG59KTtcblxudmFyIFN5bnRoZXRpY0RyYWdFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KERyYWdFdmVudEludGVyZmFjZSk7XG4vKipcbiAqIEBpbnRlcmZhY2UgRm9jdXNFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cblxudmFyIEZvY3VzRXZlbnRJbnRlcmZhY2UgPSBhc3NpZ24oe30sIFVJRXZlbnRJbnRlcmZhY2UsIHtcbiAgcmVsYXRlZFRhcmdldDogMFxufSk7XG5cbnZhciBTeW50aGV0aWNGb2N1c0V2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoRm9jdXNFdmVudEludGVyZmFjZSk7XG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1hbmltYXRpb25zLyNBbmltYXRpb25FdmVudC1pbnRlcmZhY2VcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0FuaW1hdGlvbkV2ZW50XG4gKi9cblxudmFyIEFuaW1hdGlvbkV2ZW50SW50ZXJmYWNlID0gYXNzaWduKHt9LCBFdmVudEludGVyZmFjZSwge1xuICBhbmltYXRpb25OYW1lOiAwLFxuICBlbGFwc2VkVGltZTogMCxcbiAgcHNldWRvRWxlbWVudDogMFxufSk7XG5cbnZhciBTeW50aGV0aWNBbmltYXRpb25FdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KEFuaW1hdGlvbkV2ZW50SW50ZXJmYWNlKTtcbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jbGlwYm9hcmQtYXBpcy9cbiAqL1xuXG52YXIgQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UgPSBhc3NpZ24oe30sIEV2ZW50SW50ZXJmYWNlLCB7XG4gIGNsaXBib2FyZERhdGE6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnY2xpcGJvYXJkRGF0YScgaW4gZXZlbnQgPyBldmVudC5jbGlwYm9hcmREYXRhIDogd2luZG93LmNsaXBib2FyZERhdGE7XG4gIH1cbn0pO1xuXG52YXIgU3ludGhldGljQ2xpcGJvYXJkRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChDbGlwYm9hcmRFdmVudEludGVyZmFjZSk7XG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtY29tcG9zaXRpb25ldmVudHNcbiAqL1xuXG52YXIgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZSA9IGFzc2lnbih7fSwgRXZlbnRJbnRlcmZhY2UsIHtcbiAgZGF0YTogMFxufSk7XG5cbnZhciBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoQ29tcG9zaXRpb25FdmVudEludGVyZmFjZSk7XG4vKipcbiAqIE5vcm1hbGl6YXRpb24gb2YgZGVwcmVjYXRlZCBIVE1MNSBga2V5YCB2YWx1ZXNcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQjS2V5X25hbWVzXG4gKi9cblxudmFyIG5vcm1hbGl6ZUtleSA9IHtcbiAgRXNjOiAnRXNjYXBlJyxcbiAgU3BhY2ViYXI6ICcgJyxcbiAgTGVmdDogJ0Fycm93TGVmdCcsXG4gIFVwOiAnQXJyb3dVcCcsXG4gIFJpZ2h0OiAnQXJyb3dSaWdodCcsXG4gIERvd246ICdBcnJvd0Rvd24nLFxuICBEZWw6ICdEZWxldGUnLFxuICBXaW46ICdPUycsXG4gIE1lbnU6ICdDb250ZXh0TWVudScsXG4gIEFwcHM6ICdDb250ZXh0TWVudScsXG4gIFNjcm9sbDogJ1Njcm9sbExvY2snLFxuICBNb3pQcmludGFibGVLZXk6ICdVbmlkZW50aWZpZWQnXG59O1xuLyoqXG4gKiBUcmFuc2xhdGlvbiBmcm9tIGxlZ2FjeSBga2V5Q29kZWAgdG8gSFRNTDUgYGtleWBcbiAqIE9ubHkgc3BlY2lhbCBrZXlzIHN1cHBvcnRlZCwgYWxsIG90aGVycyBkZXBlbmQgb24ga2V5Ym9hcmQgbGF5b3V0IG9yIGJyb3dzZXJcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQjS2V5X25hbWVzXG4gKi9cblxudmFyIHRyYW5zbGF0ZVRvS2V5ID0ge1xuICAnOCc6ICdCYWNrc3BhY2UnLFxuICAnOSc6ICdUYWInLFxuICAnMTInOiAnQ2xlYXInLFxuICAnMTMnOiAnRW50ZXInLFxuICAnMTYnOiAnU2hpZnQnLFxuICAnMTcnOiAnQ29udHJvbCcsXG4gICcxOCc6ICdBbHQnLFxuICAnMTknOiAnUGF1c2UnLFxuICAnMjAnOiAnQ2Fwc0xvY2snLFxuICAnMjcnOiAnRXNjYXBlJyxcbiAgJzMyJzogJyAnLFxuICAnMzMnOiAnUGFnZVVwJyxcbiAgJzM0JzogJ1BhZ2VEb3duJyxcbiAgJzM1JzogJ0VuZCcsXG4gICczNic6ICdIb21lJyxcbiAgJzM3JzogJ0Fycm93TGVmdCcsXG4gICczOCc6ICdBcnJvd1VwJyxcbiAgJzM5JzogJ0Fycm93UmlnaHQnLFxuICAnNDAnOiAnQXJyb3dEb3duJyxcbiAgJzQ1JzogJ0luc2VydCcsXG4gICc0Nic6ICdEZWxldGUnLFxuICAnMTEyJzogJ0YxJyxcbiAgJzExMyc6ICdGMicsXG4gICcxMTQnOiAnRjMnLFxuICAnMTE1JzogJ0Y0JyxcbiAgJzExNic6ICdGNScsXG4gICcxMTcnOiAnRjYnLFxuICAnMTE4JzogJ0Y3JyxcbiAgJzExOSc6ICdGOCcsXG4gICcxMjAnOiAnRjknLFxuICAnMTIxJzogJ0YxMCcsXG4gICcxMjInOiAnRjExJyxcbiAgJzEyMyc6ICdGMTInLFxuICAnMTQ0JzogJ051bUxvY2snLFxuICAnMTQ1JzogJ1Njcm9sbExvY2snLFxuICAnMjI0JzogJ01ldGEnXG59O1xuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5vcm1hbGl6ZWQgYGtleWAgcHJvcGVydHkuXG4gKi9cblxuZnVuY3Rpb24gZ2V0RXZlbnRLZXkobmF0aXZlRXZlbnQpIHtcbiAgaWYgKG5hdGl2ZUV2ZW50LmtleSkge1xuICAgIC8vIE5vcm1hbGl6ZSBpbmNvbnNpc3RlbnQgdmFsdWVzIHJlcG9ydGVkIGJ5IGJyb3dzZXJzIGR1ZSB0b1xuICAgIC8vIGltcGxlbWVudGF0aW9ucyBvZiBhIHdvcmtpbmcgZHJhZnQgc3BlY2lmaWNhdGlvbi5cbiAgICAvLyBGaXJlRm94IGltcGxlbWVudHMgYGtleWAgYnV0IHJldHVybnMgYE1velByaW50YWJsZUtleWAgZm9yIGFsbFxuICAgIC8vIHByaW50YWJsZSBjaGFyYWN0ZXJzIChub3JtYWxpemVkIHRvIGBVbmlkZW50aWZpZWRgKSwgaWdub3JlIGl0LlxuICAgIHZhciBrZXkgPSBub3JtYWxpemVLZXlbbmF0aXZlRXZlbnQua2V5XSB8fCBuYXRpdmVFdmVudC5rZXk7XG5cbiAgICBpZiAoa2V5ICE9PSAnVW5pZGVudGlmaWVkJykge1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG4gIH0gLy8gQnJvd3NlciBkb2VzIG5vdCBpbXBsZW1lbnQgYGtleWAsIHBvbHlmaWxsIGFzIG11Y2ggb2YgaXQgYXMgd2UgY2FuLlxuXG5cbiAgaWYgKG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICB2YXIgY2hhckNvZGUgPSBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KTsgLy8gVGhlIGVudGVyLWtleSBpcyB0ZWNobmljYWxseSBib3RoIHByaW50YWJsZSBhbmQgbm9uLXByaW50YWJsZSBhbmQgY2FuXG4gICAgLy8gdGh1cyBiZSBjYXB0dXJlZCBieSBga2V5cHJlc3NgLCBubyBvdGhlciBub24tcHJpbnRhYmxlIGtleSBzaG91bGQuXG5cbiAgICByZXR1cm4gY2hhckNvZGUgPT09IDEzID8gJ0VudGVyJyA6IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xuICB9XG5cbiAgaWYgKG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBuYXRpdmVFdmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgLy8gV2hpbGUgdXNlciBrZXlib2FyZCBsYXlvdXQgZGV0ZXJtaW5lcyB0aGUgYWN0dWFsIG1lYW5pbmcgb2YgZWFjaFxuICAgIC8vIGBrZXlDb2RlYCB2YWx1ZSwgYWxtb3N0IGFsbCBmdW5jdGlvbiBrZXlzIGhhdmUgYSB1bml2ZXJzYWwgdmFsdWUuXG4gICAgcmV0dXJuIHRyYW5zbGF0ZVRvS2V5W25hdGl2ZUV2ZW50LmtleUNvZGVdIHx8ICdVbmlkZW50aWZpZWQnO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuLyoqXG4gKiBUcmFuc2xhdGlvbiBmcm9tIG1vZGlmaWVyIGtleSB0byB0aGUgYXNzb2NpYXRlZCBwcm9wZXJ0eSBpbiB0aGUgZXZlbnQuXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8ja2V5cy1Nb2RpZmllcnNcbiAqL1xuXG5cbnZhciBtb2RpZmllcktleVRvUHJvcCA9IHtcbiAgQWx0OiAnYWx0S2V5JyxcbiAgQ29udHJvbDogJ2N0cmxLZXknLFxuICBNZXRhOiAnbWV0YUtleScsXG4gIFNoaWZ0OiAnc2hpZnRLZXknXG59OyAvLyBPbGRlciBicm93c2VycyAoU2FmYXJpIDw9IDEwLCBpT1MgU2FmYXJpIDw9IDEwLjIpIGRvIG5vdCBzdXBwb3J0XG4vLyBnZXRNb2RpZmllclN0YXRlLiBJZiBnZXRNb2RpZmllclN0YXRlIGlzIG5vdCBzdXBwb3J0ZWQsIHdlIG1hcCBpdCB0byBhIHNldCBvZlxuLy8gbW9kaWZpZXIga2V5cyBleHBvc2VkIGJ5IHRoZSBldmVudC4gSW4gdGhpcyBjYXNlLCBMb2NrLWtleXMgYXJlIG5vdCBzdXBwb3J0ZWQuXG5cbmZ1bmN0aW9uIG1vZGlmaWVyU3RhdGVHZXR0ZXIoa2V5QXJnKSB7XG4gIHZhciBzeW50aGV0aWNFdmVudCA9IHRoaXM7XG4gIHZhciBuYXRpdmVFdmVudCA9IHN5bnRoZXRpY0V2ZW50Lm5hdGl2ZUV2ZW50O1xuXG4gIGlmIChuYXRpdmVFdmVudC5nZXRNb2RpZmllclN0YXRlKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmdldE1vZGlmaWVyU3RhdGUoa2V5QXJnKTtcbiAgfVxuXG4gIHZhciBrZXlQcm9wID0gbW9kaWZpZXJLZXlUb1Byb3Bba2V5QXJnXTtcbiAgcmV0dXJuIGtleVByb3AgPyAhIW5hdGl2ZUV2ZW50W2tleVByb3BdIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldEV2ZW50TW9kaWZpZXJTdGF0ZShuYXRpdmVFdmVudCkge1xuICByZXR1cm4gbW9kaWZpZXJTdGF0ZUdldHRlcjtcbn1cbi8qKlxuICogQGludGVyZmFjZSBLZXlib2FyZEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xuXG5cbnZhciBLZXlib2FyZEV2ZW50SW50ZXJmYWNlID0gYXNzaWduKHt9LCBVSUV2ZW50SW50ZXJmYWNlLCB7XG4gIGtleTogZ2V0RXZlbnRLZXksXG4gIGNvZGU6IDAsXG4gIGxvY2F0aW9uOiAwLFxuICBjdHJsS2V5OiAwLFxuICBzaGlmdEtleTogMCxcbiAgYWx0S2V5OiAwLFxuICBtZXRhS2V5OiAwLFxuICByZXBlYXQ6IDAsXG4gIGxvY2FsZTogMCxcbiAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlLFxuICAvLyBMZWdhY3kgSW50ZXJmYWNlXG4gIGNoYXJDb2RlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBgY2hhckNvZGVgIGlzIHRoZSByZXN1bHQgb2YgYSBLZXlQcmVzcyBldmVudCBhbmQgcmVwcmVzZW50cyB0aGUgdmFsdWUgb2ZcbiAgICAvLyB0aGUgYWN0dWFsIHByaW50YWJsZSBjaGFyYWN0ZXIuXG4gICAgLy8gS2V5UHJlc3MgaXMgZGVwcmVjYXRlZCwgYnV0IGl0cyByZXBsYWNlbWVudCBpcyBub3QgeWV0IGZpbmFsIGFuZCBub3RcbiAgICAvLyBpbXBsZW1lbnRlZCBpbiBhbnkgbWFqb3IgYnJvd3Nlci4gT25seSBLZXlQcmVzcyBoYXMgY2hhckNvZGUuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICAgIHJldHVybiBnZXRFdmVudENoYXJDb2RlKGV2ZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbiAgfSxcbiAga2V5Q29kZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gYGtleUNvZGVgIGlzIHRoZSByZXN1bHQgb2YgYSBLZXlEb3duL1VwIGV2ZW50IGFuZCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZlxuICAgIC8vIHBoeXNpY2FsIGtleWJvYXJkIGtleS5cbiAgICAvLyBUaGUgYWN0dWFsIG1lYW5pbmcgb2YgdGhlIHZhbHVlIGRlcGVuZHMgb24gdGhlIHVzZXJzJyBrZXlib2FyZCBsYXlvdXRcbiAgICAvLyB3aGljaCBjYW5ub3QgYmUgZGV0ZWN0ZWQuIEFzc3VtaW5nIHRoYXQgaXQgaXMgYSBVUyBrZXlib2FyZCBsYXlvdXRcbiAgICAvLyBwcm92aWRlcyBhIHN1cnByaXNpbmdseSBhY2N1cmF0ZSBtYXBwaW5nIGZvciBVUyBhbmQgRXVyb3BlYW4gdXNlcnMuXG4gICAgLy8gRHVlIHRvIHRoaXMsIGl0IGlzIGxlZnQgdG8gdGhlIHVzZXIgdG8gaW1wbGVtZW50IGF0IHRoaXMgdGltZS5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleWRvd24nIHx8IGV2ZW50LnR5cGUgPT09ICdrZXl1cCcpIHtcbiAgICAgIHJldHVybiBldmVudC5rZXlDb2RlO1xuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9LFxuICB3aGljaDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gYHdoaWNoYCBpcyBhbiBhbGlhcyBmb3IgZWl0aGVyIGBrZXlDb2RlYCBvciBgY2hhckNvZGVgIGRlcGVuZGluZyBvbiB0aGVcbiAgICAvLyB0eXBlIG9mIHRoZSBldmVudC5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgICAgcmV0dXJuIGdldEV2ZW50Q2hhckNvZGUoZXZlbnQpO1xuICAgIH1cblxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5ZG93bicgfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgICAgcmV0dXJuIGV2ZW50LmtleUNvZGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG4gIH1cbn0pO1xuXG52YXIgU3ludGhldGljS2V5Ym9hcmRFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KEtleWJvYXJkRXZlbnRJbnRlcmZhY2UpO1xuLyoqXG4gKiBAaW50ZXJmYWNlIFBvaW50ZXJFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9wb2ludGVyZXZlbnRzL1xuICovXG5cbnZhciBQb2ludGVyRXZlbnRJbnRlcmZhY2UgPSBhc3NpZ24oe30sIE1vdXNlRXZlbnRJbnRlcmZhY2UsIHtcbiAgcG9pbnRlcklkOiAwLFxuICB3aWR0aDogMCxcbiAgaGVpZ2h0OiAwLFxuICBwcmVzc3VyZTogMCxcbiAgdGFuZ2VudGlhbFByZXNzdXJlOiAwLFxuICB0aWx0WDogMCxcbiAgdGlsdFk6IDAsXG4gIHR3aXN0OiAwLFxuICBwb2ludGVyVHlwZTogMCxcbiAgaXNQcmltYXJ5OiAwXG59KTtcblxudmFyIFN5bnRoZXRpY1BvaW50ZXJFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KFBvaW50ZXJFdmVudEludGVyZmFjZSk7XG4vKipcbiAqIEBpbnRlcmZhY2UgVG91Y2hFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi90b3VjaC1ldmVudHMvXG4gKi9cblxudmFyIFRvdWNoRXZlbnRJbnRlcmZhY2UgPSBhc3NpZ24oe30sIFVJRXZlbnRJbnRlcmZhY2UsIHtcbiAgdG91Y2hlczogMCxcbiAgdGFyZ2V0VG91Y2hlczogMCxcbiAgY2hhbmdlZFRvdWNoZXM6IDAsXG4gIGFsdEtleTogMCxcbiAgbWV0YUtleTogMCxcbiAgY3RybEtleTogMCxcbiAgc2hpZnRLZXk6IDAsXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZVxufSk7XG5cbnZhciBTeW50aGV0aWNUb3VjaEV2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoVG91Y2hFdmVudEludGVyZmFjZSk7XG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAwOS9XRC1jc3MzLXRyYW5zaXRpb25zLTIwMDkwMzIwLyN0cmFuc2l0aW9uLWV2ZW50cy1cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1RyYW5zaXRpb25FdmVudFxuICovXG5cbnZhciBUcmFuc2l0aW9uRXZlbnRJbnRlcmZhY2UgPSBhc3NpZ24oe30sIEV2ZW50SW50ZXJmYWNlLCB7XG4gIHByb3BlcnR5TmFtZTogMCxcbiAgZWxhcHNlZFRpbWU6IDAsXG4gIHBzZXVkb0VsZW1lbnQ6IDBcbn0pO1xuXG52YXIgU3ludGhldGljVHJhbnNpdGlvbkV2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoVHJhbnNpdGlvbkV2ZW50SW50ZXJmYWNlKTtcbi8qKlxuICogQGludGVyZmFjZSBXaGVlbEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xuXG52YXIgV2hlZWxFdmVudEludGVyZmFjZSA9IGFzc2lnbih7fSwgTW91c2VFdmVudEludGVyZmFjZSwge1xuICBkZWx0YVg6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnZGVsdGFYJyBpbiBldmVudCA/IGV2ZW50LmRlbHRhWCA6IC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhWGAgZm9yIFdlYmtpdCBhbmQgbm9ybWFsaXplIChyaWdodCBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGFYJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhWCA6IDA7XG4gIH0sXG4gIGRlbHRhWTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdkZWx0YVknIGluIGV2ZW50ID8gZXZlbnQuZGVsdGFZIDogLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFZYCBmb3IgV2Via2l0IGFuZCBub3JtYWxpemUgKGRvd24gaXMgcG9zaXRpdmUpLlxuICAgICd3aGVlbERlbHRhWScgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YVkgOiAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YWAgZm9yIElFPDkgYW5kIG5vcm1hbGl6ZSAoZG93biBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGEnIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGEgOiAwO1xuICB9LFxuICBkZWx0YVo6IDAsXG4gIC8vIEJyb3dzZXJzIHdpdGhvdXQgXCJkZWx0YU1vZGVcIiBpcyByZXBvcnRpbmcgaW4gcmF3IHdoZWVsIGRlbHRhIHdoZXJlIG9uZVxuICAvLyBub3RjaCBvbiB0aGUgc2Nyb2xsIGlzIGFsd2F5cyArLy0gMTIwLCByb3VnaGx5IGVxdWl2YWxlbnQgdG8gcGl4ZWxzLlxuICAvLyBBIGdvb2QgYXBwcm94aW1hdGlvbiBvZiBET01fREVMVEFfTElORSAoMSkgaXMgNSUgb2Ygdmlld3BvcnQgc2l6ZSBvclxuICAvLyB+NDAgcGl4ZWxzLCBmb3IgRE9NX0RFTFRBX1NDUkVFTiAoMikgaXQgaXMgODcuNSUgb2Ygdmlld3BvcnQgc2l6ZS5cbiAgZGVsdGFNb2RlOiAwXG59KTtcblxudmFyIFN5bnRoZXRpY1doZWVsRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChXaGVlbEV2ZW50SW50ZXJmYWNlKTtcblxuLyoqXG4gKiBIVE1MIG5vZGVUeXBlIHZhbHVlcyB0aGF0IHJlcHJlc2VudCB0aGUgdHlwZSBvZiB0aGUgbm9kZVxuICovXG52YXIgRUxFTUVOVF9OT0RFID0gMTtcblxuZnVuY3Rpb24gaW52b2tlR3VhcmRlZENhbGxiYWNrUHJvZChuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIHZhciBmdW5jQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMyk7XG5cbiAgdHJ5IHtcbiAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGZ1bmNBcmdzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aGlzLm9uRXJyb3IoZXJyb3IpO1xuICB9XG59XG5cbnZhciBpbnZva2VHdWFyZGVkQ2FsbGJhY2tJbXBsID0gaW52b2tlR3VhcmRlZENhbGxiYWNrUHJvZDtcblxue1xuICAvLyBJbiBERVYgbW9kZSwgd2Ugc3dhcCBvdXQgaW52b2tlR3VhcmRlZENhbGxiYWNrIGZvciBhIHNwZWNpYWwgdmVyc2lvblxuICAvLyB0aGF0IHBsYXlzIG1vcmUgbmljZWx5IHdpdGggdGhlIGJyb3dzZXIncyBEZXZUb29scy4gVGhlIGlkZWEgaXMgdG8gcHJlc2VydmVcbiAgLy8gXCJQYXVzZSBvbiBleGNlcHRpb25zXCIgYmVoYXZpb3IuIEJlY2F1c2UgUmVhY3Qgd3JhcHMgYWxsIHVzZXItcHJvdmlkZWRcbiAgLy8gZnVuY3Rpb25zIGluIGludm9rZUd1YXJkZWRDYWxsYmFjaywgYW5kIHRoZSBwcm9kdWN0aW9uIHZlcnNpb24gb2ZcbiAgLy8gaW52b2tlR3VhcmRlZENhbGxiYWNrIHVzZXMgYSB0cnktY2F0Y2gsIGFsbCB1c2VyIGV4Y2VwdGlvbnMgYXJlIHRyZWF0ZWRcbiAgLy8gbGlrZSBjYXVnaHQgZXhjZXB0aW9ucywgYW5kIHRoZSBEZXZUb29scyB3b24ndCBwYXVzZSB1bmxlc3MgdGhlIGRldmVsb3BlclxuICAvLyB0YWtlcyB0aGUgZXh0cmEgc3RlcCBvZiBlbmFibGluZyBwYXVzZSBvbiBjYXVnaHQgZXhjZXB0aW9ucy4gVGhpcyBpc1xuICAvLyB1bmludHVpdGl2ZSwgdGhvdWdoLCBiZWNhdXNlIGV2ZW4gdGhvdWdoIFJlYWN0IGhhcyBjYXVnaHQgdGhlIGVycm9yLCBmcm9tXG4gIC8vIHRoZSBkZXZlbG9wZXIncyBwZXJzcGVjdGl2ZSwgdGhlIGVycm9yIGlzIHVuY2F1Z2h0LlxuICAvL1xuICAvLyBUbyBwcmVzZXJ2ZSB0aGUgZXhwZWN0ZWQgXCJQYXVzZSBvbiBleGNlcHRpb25zXCIgYmVoYXZpb3IsIHdlIGRvbid0IHVzZSBhXG4gIC8vIHRyeS1jYXRjaCBpbiBERVYuIEluc3RlYWQsIHdlIHN5bmNocm9ub3VzbHkgZGlzcGF0Y2ggYSBmYWtlIGV2ZW50IHRvIGEgZmFrZVxuICAvLyBET00gbm9kZSwgYW5kIGNhbGwgdGhlIHVzZXItcHJvdmlkZWQgY2FsbGJhY2sgZnJvbSBpbnNpZGUgYW4gZXZlbnQgaGFuZGxlclxuICAvLyBmb3IgdGhhdCBmYWtlIGV2ZW50LiBJZiB0aGUgY2FsbGJhY2sgdGhyb3dzLCB0aGUgZXJyb3IgaXMgXCJjYXB0dXJlZFwiIHVzaW5nXG4gIC8vIGEgZ2xvYmFsIGV2ZW50IGhhbmRsZXIuIEJ1dCBiZWNhdXNlIHRoZSBlcnJvciBoYXBwZW5zIGluIGEgZGlmZmVyZW50XG4gIC8vIGV2ZW50IGxvb3AgY29udGV4dCwgaXQgZG9lcyBub3QgaW50ZXJydXB0IHRoZSBub3JtYWwgcHJvZ3JhbSBmbG93LlxuICAvLyBFZmZlY3RpdmVseSwgdGhpcyBnaXZlcyB1cyB0cnktY2F0Y2ggYmVoYXZpb3Igd2l0aG91dCBhY3R1YWxseSB1c2luZ1xuICAvLyB0cnktY2F0Y2guIE5lYXQhXG4gIC8vIENoZWNrIHRoYXQgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlIEFQSXMgd2UgbmVlZCB0byBpbXBsZW1lbnQgb3VyIHNwZWNpYWxcbiAgLy8gREVWIHZlcnNpb24gb2YgaW52b2tlR3VhcmRlZENhbGxiYWNrXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRpc3BhdGNoRXZlbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZmFrZU5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdyZWFjdCcpO1xuXG4gICAgaW52b2tlR3VhcmRlZENhbGxiYWNrSW1wbCA9IGZ1bmN0aW9uIGludm9rZUd1YXJkZWRDYWxsYmFja0RldihuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgICAvLyBJZiBkb2N1bWVudCBkb2Vzbid0IGV4aXN0IHdlIGtub3cgZm9yIHN1cmUgd2Ugd2lsbCBjcmFzaCBpbiB0aGlzIG1ldGhvZFxuICAgICAgLy8gd2hlbiB3ZSBjYWxsIGRvY3VtZW50LmNyZWF0ZUV2ZW50KCkuIEhvd2V2ZXIgdGhpcyBjYW4gY2F1c2UgY29uZnVzaW5nXG4gICAgICAvLyBlcnJvcnM6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9jcmVhdGUtcmVhY3QtYXBwL2lzc3Vlcy8zNDgyXG4gICAgICAvLyBTbyB3ZSBwcmVlbXB0aXZlbHkgdGhyb3cgd2l0aCBhIGJldHRlciBtZXNzYWdlIGluc3RlYWQuXG4gICAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyB8fCBkb2N1bWVudCA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBgZG9jdW1lbnRgIGdsb2JhbCB3YXMgZGVmaW5lZCB3aGVuIFJlYWN0IHdhcyBpbml0aWFsaXplZCwgYnV0IGlzIG5vdCAnICsgJ2RlZmluZWQgYW55bW9yZS4gVGhpcyBjYW4gaGFwcGVuIGluIGEgdGVzdCBlbnZpcm9ubWVudCBpZiBhIGNvbXBvbmVudCAnICsgJ3NjaGVkdWxlcyBhbiB1cGRhdGUgZnJvbSBhbiBhc3luY2hyb25vdXMgY2FsbGJhY2ssIGJ1dCB0aGUgdGVzdCBoYXMgYWxyZWFkeSAnICsgJ2ZpbmlzaGVkIHJ1bm5pbmcuIFRvIHNvbHZlIHRoaXMsIHlvdSBjYW4gZWl0aGVyIHVubW91bnQgdGhlIGNvbXBvbmVudCBhdCAnICsgJ3RoZSBlbmQgb2YgeW91ciB0ZXN0IChhbmQgZW5zdXJlIHRoYXQgYW55IGFzeW5jaHJvbm91cyBvcGVyYXRpb25zIGdldCAnICsgJ2NhbmNlbGVkIGluIGBjb21wb25lbnRXaWxsVW5tb3VudGApLCBvciB5b3UgY2FuIGNoYW5nZSB0aGUgdGVzdCBpdHNlbGYgJyArICd0byBiZSBhc3luY2hyb25vdXMuJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgIHZhciBkaWRDYWxsID0gZmFsc2U7IC8vIEtlZXBzIHRyYWNrIG9mIHdoZXRoZXIgdGhlIHVzZXItcHJvdmlkZWQgY2FsbGJhY2sgdGhyZXcgYW4gZXJyb3IuIFdlXG4gICAgICAvLyBzZXQgdGhpcyB0byB0cnVlIGF0IHRoZSBiZWdpbm5pbmcsIHRoZW4gc2V0IGl0IHRvIGZhbHNlIHJpZ2h0IGFmdGVyXG4gICAgICAvLyBjYWxsaW5nIHRoZSBmdW5jdGlvbi4gSWYgdGhlIGZ1bmN0aW9uIGVycm9ycywgYGRpZEVycm9yYCB3aWxsIG5ldmVyIGJlXG4gICAgICAvLyBzZXQgdG8gZmFsc2UuIFRoaXMgc3RyYXRlZ3kgd29ya3MgZXZlbiBpZiB0aGUgYnJvd3NlciBpcyBmbGFreSBhbmRcbiAgICAgIC8vIGZhaWxzIHRvIGNhbGwgb3VyIGdsb2JhbCBlcnJvciBoYW5kbGVyLCBiZWNhdXNlIGl0IGRvZXNuJ3QgcmVseSBvblxuICAgICAgLy8gdGhlIGVycm9yIGV2ZW50IGF0IGFsbC5cblxuICAgICAgdmFyIGRpZEVycm9yID0gdHJ1ZTsgLy8gS2VlcHMgdHJhY2sgb2YgdGhlIHZhbHVlIG9mIHdpbmRvdy5ldmVudCBzbyB0aGF0IHdlIGNhbiByZXNldCBpdFxuICAgICAgLy8gZHVyaW5nIHRoZSBjYWxsYmFjayB0byBsZXQgdXNlciBjb2RlIGFjY2VzcyB3aW5kb3cuZXZlbnQgaW4gdGhlXG4gICAgICAvLyBicm93c2VycyB0aGF0IHN1cHBvcnQgaXQuXG5cbiAgICAgIHZhciB3aW5kb3dFdmVudCA9IHdpbmRvdy5ldmVudDsgLy8gS2VlcHMgdHJhY2sgb2YgdGhlIGRlc2NyaXB0b3Igb2Ygd2luZG93LmV2ZW50IHRvIHJlc3RvcmUgaXQgYWZ0ZXIgZXZlbnRcbiAgICAgIC8vIGRpc3BhdGNoaW5nOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjg4XG5cbiAgICAgIHZhciB3aW5kb3dFdmVudERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHdpbmRvdywgJ2V2ZW50Jyk7XG5cbiAgICAgIGZ1bmN0aW9uIHJlc3RvcmVBZnRlckRpc3BhdGNoKCkge1xuICAgICAgICAvLyBXZSBpbW1lZGlhdGVseSByZW1vdmUgdGhlIGNhbGxiYWNrIGZyb20gZXZlbnQgbGlzdGVuZXJzIHNvIHRoYXRcbiAgICAgICAgLy8gbmVzdGVkIGBpbnZva2VHdWFyZGVkQ2FsbGJhY2tgIGNhbGxzIGRvIG5vdCBjbGFzaC4gT3RoZXJ3aXNlLCBhXG4gICAgICAgIC8vIG5lc3RlZCBjYWxsIHdvdWxkIHRyaWdnZXIgdGhlIGZha2UgZXZlbnQgaGFuZGxlcnMgb2YgYW55IGNhbGwgaGlnaGVyXG4gICAgICAgIC8vIGluIHRoZSBzdGFjay5cbiAgICAgICAgZmFrZU5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBjYWxsQ2FsbGJhY2ssIGZhbHNlKTsgLy8gV2UgY2hlY2sgZm9yIHdpbmRvdy5oYXNPd25Qcm9wZXJ0eSgnZXZlbnQnKSB0byBwcmV2ZW50IHRoZVxuICAgICAgICAvLyB3aW5kb3cuZXZlbnQgYXNzaWdubWVudCBpbiBib3RoIElFIDw9IDEwIGFzIHRoZXkgdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgLy8gXCJNZW1iZXIgbm90IGZvdW5kXCIgaW4gc3RyaWN0IG1vZGUsIGFuZCBpbiBGaXJlZm94IHdoaWNoIGRvZXMgbm90XG4gICAgICAgIC8vIHN1cHBvcnQgd2luZG93LmV2ZW50LlxuXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93LmV2ZW50ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuaGFzT3duUHJvcGVydHkoJ2V2ZW50JykpIHtcbiAgICAgICAgICB3aW5kb3cuZXZlbnQgPSB3aW5kb3dFdmVudDtcbiAgICAgICAgfVxuICAgICAgfSAvLyBDcmVhdGUgYW4gZXZlbnQgaGFuZGxlciBmb3Igb3VyIGZha2UgZXZlbnQuIFdlIHdpbGwgc3luY2hyb25vdXNseVxuICAgICAgLy8gZGlzcGF0Y2ggb3VyIGZha2UgZXZlbnQgdXNpbmcgYGRpc3BhdGNoRXZlbnRgLiBJbnNpZGUgdGhlIGhhbmRsZXIsIHdlXG4gICAgICAvLyBjYWxsIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrLlxuXG5cbiAgICAgIHZhciBmdW5jQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMyk7XG5cbiAgICAgIGZ1bmN0aW9uIGNhbGxDYWxsYmFjaygpIHtcbiAgICAgICAgZGlkQ2FsbCA9IHRydWU7XG4gICAgICAgIHJlc3RvcmVBZnRlckRpc3BhdGNoKCk7XG4gICAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgZnVuY0FyZ3MpO1xuICAgICAgICBkaWRFcnJvciA9IGZhbHNlO1xuICAgICAgfSAvLyBDcmVhdGUgYSBnbG9iYWwgZXJyb3IgZXZlbnQgaGFuZGxlci4gV2UgdXNlIHRoaXMgdG8gY2FwdHVyZSB0aGUgdmFsdWVcbiAgICAgIC8vIHRoYXQgd2FzIHRocm93bi4gSXQncyBwb3NzaWJsZSB0aGF0IHRoaXMgZXJyb3IgaGFuZGxlciB3aWxsIGZpcmUgbW9yZVxuICAgICAgLy8gdGhhbiBvbmNlOyBmb3IgZXhhbXBsZSwgaWYgbm9uLVJlYWN0IGNvZGUgYWxzbyBjYWxscyBgZGlzcGF0Y2hFdmVudGBcbiAgICAgIC8vIGFuZCBhIGhhbmRsZXIgZm9yIHRoYXQgZXZlbnQgdGhyb3dzLiBXZSBzaG91bGQgYmUgcmVzaWxpZW50IHRvIG1vc3Qgb2ZcbiAgICAgIC8vIHRob3NlIGNhc2VzLiBFdmVuIGlmIG91ciBlcnJvciBldmVudCBoYW5kbGVyIGZpcmVzIG1vcmUgdGhhbiBvbmNlLCB0aGVcbiAgICAgIC8vIGxhc3QgZXJyb3IgZXZlbnQgaXMgYWx3YXlzIHVzZWQuIElmIHRoZSBjYWxsYmFjayBhY3R1YWxseSBkb2VzIGVycm9yLFxuICAgICAgLy8gd2Uga25vdyB0aGF0IHRoZSBsYXN0IGVycm9yIGV2ZW50IGlzIHRoZSBjb3JyZWN0IG9uZSwgYmVjYXVzZSBpdCdzIG5vdFxuICAgICAgLy8gcG9zc2libGUgZm9yIGFueXRoaW5nIGVsc2UgdG8gaGF2ZSBoYXBwZW5lZCBpbiBiZXR3ZWVuIG91ciBjYWxsYmFja1xuICAgICAgLy8gZXJyb3JpbmcgYW5kIHRoZSBjb2RlIHRoYXQgZm9sbG93cyB0aGUgYGRpc3BhdGNoRXZlbnRgIGNhbGwgYmVsb3cuIElmXG4gICAgICAvLyB0aGUgY2FsbGJhY2sgZG9lc24ndCBlcnJvciwgYnV0IHRoZSBlcnJvciBldmVudCB3YXMgZmlyZWQsIHdlIGtub3cgdG9cbiAgICAgIC8vIGlnbm9yZSBpdCBiZWNhdXNlIGBkaWRFcnJvcmAgd2lsbCBiZSBmYWxzZSwgYXMgZGVzY3JpYmVkIGFib3ZlLlxuXG5cbiAgICAgIHZhciBlcnJvcjsgLy8gVXNlIHRoaXMgdG8gdHJhY2sgd2hldGhlciB0aGUgZXJyb3IgZXZlbnQgaXMgZXZlciBjYWxsZWQuXG5cbiAgICAgIHZhciBkaWRTZXRFcnJvciA9IGZhbHNlO1xuICAgICAgdmFyIGlzQ3Jvc3NPcmlnaW5FcnJvciA9IGZhbHNlO1xuXG4gICAgICBmdW5jdGlvbiBoYW5kbGVXaW5kb3dFcnJvcihldmVudCkge1xuICAgICAgICBlcnJvciA9IGV2ZW50LmVycm9yO1xuICAgICAgICBkaWRTZXRFcnJvciA9IHRydWU7XG5cbiAgICAgICAgaWYgKGVycm9yID09PSBudWxsICYmIGV2ZW50LmNvbG5vID09PSAwICYmIGV2ZW50LmxpbmVubyA9PT0gMCkge1xuICAgICAgICAgIGlzQ3Jvc3NPcmlnaW5FcnJvciA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgIC8vIFNvbWUgb3RoZXIgZXJyb3IgaGFuZGxlciBoYXMgcHJldmVudGVkIGRlZmF1bHQuXG4gICAgICAgICAgLy8gQnJvd3NlcnMgc2lsZW5jZSB0aGUgZXJyb3IgcmVwb3J0IGlmIHRoaXMgaGFwcGVucy5cbiAgICAgICAgICAvLyBXZSdsbCByZW1lbWJlciB0aGlzIHRvIGxhdGVyIGRlY2lkZSB3aGV0aGVyIHRvIGxvZyBpdCBvciBub3QuXG4gICAgICAgICAgaWYgKGVycm9yICE9IG51bGwgJiYgdHlwZW9mIGVycm9yID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZXJyb3IuX3N1cHByZXNzTG9nZ2luZyA9IHRydWU7XG4gICAgICAgICAgICB9IGNhdGNoIChpbm5lcikgey8vIElnbm9yZS5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gQ3JlYXRlIGEgZmFrZSBldmVudCB0eXBlLlxuXG5cbiAgICAgIHZhciBldnRUeXBlID0gXCJyZWFjdC1cIiArIChuYW1lID8gbmFtZSA6ICdpbnZva2VndWFyZGVkY2FsbGJhY2snKTsgLy8gQXR0YWNoIG91ciBldmVudCBoYW5kbGVyc1xuXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVXaW5kb3dFcnJvcik7XG4gICAgICBmYWtlTm9kZS5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGNhbGxDYWxsYmFjaywgZmFsc2UpOyAvLyBTeW5jaHJvbm91c2x5IGRpc3BhdGNoIG91ciBmYWtlIGV2ZW50LiBJZiB0aGUgdXNlci1wcm92aWRlZCBmdW5jdGlvblxuICAgICAgLy8gZXJyb3JzLCBpdCB3aWxsIHRyaWdnZXIgb3VyIGdsb2JhbCBlcnJvciBoYW5kbGVyLlxuXG4gICAgICBldnQuaW5pdEV2ZW50KGV2dFR5cGUsIGZhbHNlLCBmYWxzZSk7XG4gICAgICBmYWtlTm9kZS5kaXNwYXRjaEV2ZW50KGV2dCk7XG5cbiAgICAgIGlmICh3aW5kb3dFdmVudERlc2NyaXB0b3IpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdywgJ2V2ZW50Jywgd2luZG93RXZlbnREZXNjcmlwdG9yKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRpZENhbGwgJiYgZGlkRXJyb3IpIHtcbiAgICAgICAgaWYgKCFkaWRTZXRFcnJvcikge1xuICAgICAgICAgIC8vIFRoZSBjYWxsYmFjayBlcnJvcmVkLCBidXQgdGhlIGVycm9yIGV2ZW50IG5ldmVyIGZpcmVkLlxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ0FuIGVycm9yIHdhcyB0aHJvd24gaW5zaWRlIG9uZSBvZiB5b3VyIGNvbXBvbmVudHMsIGJ1dCBSZWFjdCAnICsgXCJkb2Vzbid0IGtub3cgd2hhdCBpdCB3YXMuIFRoaXMgaXMgbGlrZWx5IGR1ZSB0byBicm93c2VyIFwiICsgJ2ZsYWtpbmVzcy4gUmVhY3QgZG9lcyBpdHMgYmVzdCB0byBwcmVzZXJ2ZSB0aGUgXCJQYXVzZSBvbiAnICsgJ2V4Y2VwdGlvbnNcIiBiZWhhdmlvciBvZiB0aGUgRGV2VG9vbHMsIHdoaWNoIHJlcXVpcmVzIHNvbWUgJyArIFwiREVWLW1vZGUgb25seSB0cmlja3MuIEl0J3MgcG9zc2libGUgdGhhdCB0aGVzZSBkb24ndCB3b3JrIGluIFwiICsgJ3lvdXIgYnJvd3Nlci4gVHJ5IHRyaWdnZXJpbmcgdGhlIGVycm9yIGluIHByb2R1Y3Rpb24gbW9kZSwgJyArICdvciBzd2l0Y2hpbmcgdG8gYSBtb2Rlcm4gYnJvd3Nlci4gSWYgeW91IHN1c3BlY3QgdGhhdCB0aGlzIGlzICcgKyAnYWN0dWFsbHkgYW4gaXNzdWUgd2l0aCBSZWFjdCwgcGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNDcm9zc09yaWdpbkVycm9yKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihcIkEgY3Jvc3Mtb3JpZ2luIGVycm9yIHdhcyB0aHJvd24uIFJlYWN0IGRvZXNuJ3QgaGF2ZSBhY2Nlc3MgdG8gXCIgKyAndGhlIGFjdHVhbCBlcnJvciBvYmplY3QgaW4gZGV2ZWxvcG1lbnQuICcgKyAnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9jcm9zc29yaWdpbi1lcnJvciBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub25FcnJvcihlcnJvcik7XG4gICAgICB9IC8vIFJlbW92ZSBvdXIgZXZlbnQgbGlzdGVuZXJzXG5cblxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgaGFuZGxlV2luZG93RXJyb3IpO1xuXG4gICAgICBpZiAoIWRpZENhbGwpIHtcbiAgICAgICAgLy8gU29tZXRoaW5nIHdlbnQgcmVhbGx5IHdyb25nLCBhbmQgb3VyIGV2ZW50IHdhcyBub3QgZGlzcGF0Y2hlZC5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNjczNFxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE2NTg1XG4gICAgICAgIC8vIEZhbGwgYmFjayB0byB0aGUgcHJvZHVjdGlvbiBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgcmVzdG9yZUFmdGVyRGlzcGF0Y2goKTtcbiAgICAgICAgcmV0dXJuIGludm9rZUd1YXJkZWRDYWxsYmFja1Byb2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5cbnZhciBpbnZva2VHdWFyZGVkQ2FsbGJhY2tJbXBsJDEgPSBpbnZva2VHdWFyZGVkQ2FsbGJhY2tJbXBsO1xuXG52YXIgaGFzRXJyb3IgPSBmYWxzZTtcbnZhciBjYXVnaHRFcnJvciA9IG51bGw7IC8vIFVzZWQgYnkgZXZlbnQgc3lzdGVtIHRvIGNhcHR1cmUvcmV0aHJvdyB0aGUgZmlyc3QgZXJyb3IuXG5cbnZhciBoYXNSZXRocm93RXJyb3IgPSBmYWxzZTtcbnZhciByZXRocm93RXJyb3IgPSBudWxsO1xudmFyIHJlcG9ydGVyID0ge1xuICBvbkVycm9yOiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICBoYXNFcnJvciA9IHRydWU7XG4gICAgY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgfVxufTtcbi8qKlxuICogQ2FsbCBhIGZ1bmN0aW9uIHdoaWxlIGd1YXJkaW5nIGFnYWluc3QgZXJyb3JzIHRoYXQgaGFwcGVucyB3aXRoaW4gaXQuXG4gKiBSZXR1cm5zIGFuIGVycm9yIGlmIGl0IHRocm93cywgb3RoZXJ3aXNlIG51bGwuXG4gKlxuICogSW4gcHJvZHVjdGlvbiwgdGhpcyBpcyBpbXBsZW1lbnRlZCB1c2luZyBhIHRyeS1jYXRjaC4gVGhlIHJlYXNvbiB3ZSBkb24ndFxuICogdXNlIGEgdHJ5LWNhdGNoIGRpcmVjdGx5IGlzIHNvIHRoYXQgd2UgY2FuIHN3YXAgb3V0IGEgZGlmZmVyZW50XG4gKiBpbXBsZW1lbnRhdGlvbiBpbiBERVYgbW9kZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiB0aGUgZ3VhcmQgdG8gdXNlIGZvciBsb2dnaW5nIG9yIGRlYnVnZ2luZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gdXNlIHdoZW4gY2FsbGluZyB0aGUgZnVuY3Rpb25cbiAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcmd1bWVudHMgZm9yIGZ1bmN0aW9uXG4gKi9cblxuZnVuY3Rpb24gaW52b2tlR3VhcmRlZENhbGxiYWNrKG5hbWUsIGZ1bmMsIGNvbnRleHQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgaGFzRXJyb3IgPSBmYWxzZTtcbiAgY2F1Z2h0RXJyb3IgPSBudWxsO1xuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2tJbXBsJDEuYXBwbHkocmVwb3J0ZXIsIGFyZ3VtZW50cyk7XG59XG4vKipcbiAqIFNhbWUgYXMgaW52b2tlR3VhcmRlZENhbGxiYWNrLCBidXQgaW5zdGVhZCBvZiByZXR1cm5pbmcgYW4gZXJyb3IsIGl0IHN0b3Jlc1xuICogaXQgaW4gYSBnbG9iYWwgc28gaXQgY2FuIGJlIHJldGhyb3duIGJ5IGByZXRocm93Q2F1Z2h0RXJyb3JgIGxhdGVyLlxuICogVE9ETzogU2VlIGlmIGNhdWdodEVycm9yIGFuZCByZXRocm93RXJyb3IgY2FuIGJlIHVuaWZpZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgdGhlIGd1YXJkIHRvIHVzZSBmb3IgbG9nZ2luZyBvciBkZWJ1Z2dpbmdcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZVxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIHVzZSB3aGVuIGNhbGxpbmcgdGhlIGZ1bmN0aW9uXG4gKiBAcGFyYW0gey4uLip9IGFyZ3MgQXJndW1lbnRzIGZvciBmdW5jdGlvblxuICovXG5cbmZ1bmN0aW9uIGludm9rZUd1YXJkZWRDYWxsYmFja0FuZENhdGNoRmlyc3RFcnJvcihuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIGludm9rZUd1YXJkZWRDYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIGlmIChoYXNFcnJvcikge1xuICAgIHZhciBlcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcblxuICAgIGlmICghaGFzUmV0aHJvd0Vycm9yKSB7XG4gICAgICBoYXNSZXRocm93RXJyb3IgPSB0cnVlO1xuICAgICAgcmV0aHJvd0Vycm9yID0gZXJyb3I7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIER1cmluZyBleGVjdXRpb24gb2YgZ3VhcmRlZCBmdW5jdGlvbnMgd2Ugd2lsbCBjYXB0dXJlIHRoZSBmaXJzdCBlcnJvciB3aGljaFxuICogd2Ugd2lsbCByZXRocm93IHRvIGJlIGhhbmRsZWQgYnkgdGhlIHRvcCBsZXZlbCBlcnJvciBoYW5kbGVyLlxuICovXG5cbmZ1bmN0aW9uIHJldGhyb3dDYXVnaHRFcnJvcigpIHtcbiAgaWYgKGhhc1JldGhyb3dFcnJvcikge1xuICAgIHZhciBlcnJvciA9IHJldGhyb3dFcnJvcjtcbiAgICBoYXNSZXRocm93RXJyb3IgPSBmYWxzZTtcbiAgICByZXRocm93RXJyb3IgPSBudWxsO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5mdW5jdGlvbiBjbGVhckNhdWdodEVycm9yKCkge1xuICBpZiAoaGFzRXJyb3IpIHtcbiAgICB2YXIgZXJyb3IgPSBjYXVnaHRFcnJvcjtcbiAgICBoYXNFcnJvciA9IGZhbHNlO1xuICAgIGNhdWdodEVycm9yID0gbnVsbDtcbiAgICByZXR1cm4gZXJyb3I7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhckNhdWdodEVycm9yIHdhcyBjYWxsZWQgYnV0IG5vIGVycm9yIHdhcyBjYXB0dXJlZC4gVGhpcyBlcnJvciAnICsgJ2lzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICB9XG59XG5cbnZhciBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxuZnVuY3Rpb24gaXNBcnJheShhKSB7XG4gIHJldHVybiBpc0FycmF5SW1wbChhKTtcbn1cblxudmFyIFNlY3JldEludGVybmFscyA9IFJlYWN0RE9NLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xudmFyIEV2ZW50SW50ZXJuYWxzID0gU2VjcmV0SW50ZXJuYWxzLkV2ZW50cztcbnZhciBnZXRJbnN0YW5jZUZyb21Ob2RlID0gRXZlbnRJbnRlcm5hbHNbMF07XG52YXIgZ2V0Tm9kZUZyb21JbnN0YW5jZSA9IEV2ZW50SW50ZXJuYWxzWzFdO1xudmFyIGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUgPSBFdmVudEludGVybmFsc1syXTtcbnZhciBlbnF1ZXVlU3RhdGVSZXN0b3JlID0gRXZlbnRJbnRlcm5hbHNbM107XG52YXIgcmVzdG9yZVN0YXRlSWZOZWVkZWQgPSBFdmVudEludGVybmFsc1s0XTtcbnZhciByZWFjdEFjdCA9IFJlYWN0LnVuc3RhYmxlX2FjdDtcblxuZnVuY3Rpb24gRXZlbnQoc3VmZml4KSB7fVxuXG52YXIgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkTW9ja0NvbXBvbmVudCA9IGZhbHNlO1xuLyoqXG4gKiBAY2xhc3MgUmVhY3RUZXN0VXRpbHNcbiAqL1xuXG5mdW5jdGlvbiBmaW5kQWxsSW5SZW5kZXJlZEZpYmVyVHJlZUludGVybmFsKGZpYmVyLCB0ZXN0KSB7XG4gIGlmICghZmliZXIpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgY3VycmVudFBhcmVudCA9IGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKGZpYmVyKTtcblxuICBpZiAoIWN1cnJlbnRQYXJlbnQpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgbm9kZSA9IGN1cnJlbnRQYXJlbnQ7XG4gIHZhciByZXQgPSBbXTtcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQgfHwgbm9kZS50YWcgPT09IENsYXNzQ29tcG9uZW50IHx8IG5vZGUudGFnID09PSBGdW5jdGlvbkNvbXBvbmVudCkge1xuICAgICAgdmFyIHB1YmxpY0luc3QgPSBub2RlLnN0YXRlTm9kZTtcblxuICAgICAgaWYgKHRlc3QocHVibGljSW5zdCkpIHtcbiAgICAgICAgcmV0LnB1c2gocHVibGljSW5zdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuY2hpbGQpIHtcbiAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUgPT09IGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgd2hpbGUgKCFub2RlLnNpYmxpbmcpIHtcbiAgICAgIGlmICghbm9kZS5yZXR1cm4gfHwgbm9kZS5yZXR1cm4gPT09IGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH1cblxuICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ2xhc3NJbnN0YW5jZShpbnN0LCBtZXRob2ROYW1lKSB7XG4gIGlmICghaW5zdCkge1xuICAgIC8vIFRoaXMgaXMgcHJvYmFibHkgdG9vIHJlbGF4ZWQgYnV0IGl0J3MgZXhpc3RpbmcgYmVoYXZpb3IuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGdldChpbnN0KSkge1xuICAgIC8vIFRoaXMgaXMgYSBwdWJsaWMgaW5zdGFuY2UgaW5kZWVkLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciByZWNlaXZlZDtcbiAgdmFyIHN0cmluZ2lmaWVkID0gU3RyaW5nKGluc3QpO1xuXG4gIGlmIChpc0FycmF5KGluc3QpKSB7XG4gICAgcmVjZWl2ZWQgPSAnYW4gYXJyYXknO1xuICB9IGVsc2UgaWYgKGluc3QgJiYgaW5zdC5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFICYmIGluc3QudGFnTmFtZSkge1xuICAgIHJlY2VpdmVkID0gJ2EgRE9NIG5vZGUnO1xuICB9IGVsc2UgaWYgKHN0cmluZ2lmaWVkID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgIHJlY2VpdmVkID0gJ29iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhpbnN0KS5qb2luKCcsICcpICsgJ30nO1xuICB9IGVsc2Uge1xuICAgIHJlY2VpdmVkID0gc3RyaW5naWZpZWQ7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IobWV0aG9kTmFtZSArIFwiKC4uLik6IHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgUmVhY3QgY2xhc3MgaW5zdGFuY2UuIFwiICsgKFwiSW5zdGVhZCByZWNlaXZlZDogXCIgKyByZWNlaXZlZCArIFwiLlwiKSk7XG59XG4vKipcbiAqIFV0aWxpdGllcyBmb3IgbWFraW5nIGl0IGVhc3kgdG8gdGVzdCBSZWFjdCBjb21wb25lbnRzLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvdGVzdC11dGlscy5odG1sXG4gKlxuICogVG9kbzogU3VwcG9ydCB0aGUgZW50aXJlIERPTS5zY3J5IHF1ZXJ5IHN5bnRheC4gRm9yIG5vdywgdGhlc2Ugc2ltcGxlXG4gKiB1dGlsaXRpZXMgd2lsbCBzdWZmaWNlIGZvciB0ZXN0aW5nIHB1cnBvc2VzLlxuICogQGxlbmRzIFJlYWN0VGVzdFV0aWxzXG4gKi9cblxuXG52YXIgZGlkV2FybkFib3V0UmVhY3RUZXN0VXRpbHNEZXByZWNhdGlvbiA9IGZhbHNlO1xuXG5mdW5jdGlvbiByZW5kZXJJbnRvRG9jdW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKCFkaWRXYXJuQWJvdXRSZWFjdFRlc3RVdGlsc0RlcHJlY2F0aW9uKSB7XG4gICAgICBkaWRXYXJuQWJvdXRSZWFjdFRlc3RVdGlsc0RlcHJlY2F0aW9uID0gdHJ1ZTtcblxuICAgICAgZXJyb3IoJ1JlYWN0RE9NVGVzdFV0aWxzIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSAnICsgJ21ham9yIHJlbGVhc2UsIGJlY2F1c2UgaXQgZXhwb3NlcyBpbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzICcgKyAndGhhdCBhcmUgaGlnaGx5IGxpa2VseSB0byBjaGFuZ2UgYmV0d2VlbiByZWxlYXNlcy4gVXBncmFkZSB0byBhICcgKyAnbW9kZXJuIHRlc3RpbmcgbGlicmFyeSwgc3VjaCBhcyBAdGVzdGluZy1saWJyYXJ5L3JlYWN0LiBTZWUgJyArICdodHRwczovL3JlYWN0LmRldi93YXJuaW5ncy9yZWFjdC1kb20tdGVzdC11dGlscyBmb3IgbW9yZSBpbmZvLicpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTsgLy8gTm9uZSBvZiBvdXIgdGVzdHMgYWN0dWFsbHkgcmVxdWlyZSBhdHRhY2hpbmcgdGhlIGNvbnRhaW5lciB0byB0aGVcbiAgLy8gRE9NLCBhbmQgZG9pbmcgc28gY3JlYXRlcyBhIG1lc3MgdGhhdCB3ZSByZWx5IG9uIHRlc3QgaXNvbGF0aW9uIHRvXG4gIC8vIGNsZWFuIHVwLCBzbyB3ZSdyZSBnb2luZyB0byBzdG9wIGhvbm9yaW5nIHRoZSBuYW1lIG9mIHRoaXMgbWV0aG9kXG4gIC8vIChhbmQgcHJvYmFibHkgcmVuYW1lIGl0IGV2ZW50dWFsbHkpIGlmIG5vIHByb2JsZW1zIGFyaXNlLlxuICAvLyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoZGl2KTtcblxuICByZXR1cm4gUmVhY3RET00ucmVuZGVyKGVsZW1lbnQsIGRpdik7XG59XG5cbmZ1bmN0aW9uIGlzRWxlbWVudChlbGVtZW50KSB7XG4gIHJldHVybiBSZWFjdC5pc1ZhbGlkRWxlbWVudChlbGVtZW50KTtcbn1cblxuZnVuY3Rpb24gaXNFbGVtZW50T2ZUeXBlKGluc3QsIGNvbnZlbmllbmNlQ29uc3RydWN0b3IpIHtcbiAgcmV0dXJuIFJlYWN0LmlzVmFsaWRFbGVtZW50KGluc3QpICYmIGluc3QudHlwZSA9PT0gY29udmVuaWVuY2VDb25zdHJ1Y3Rvcjtcbn1cblxuZnVuY3Rpb24gaXNET01Db21wb25lbnQoaW5zdCkge1xuICByZXR1cm4gISEoaW5zdCAmJiBpbnN0Lm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUgJiYgaW5zdC50YWdOYW1lKTtcbn1cblxuZnVuY3Rpb24gaXNET01Db21wb25lbnRFbGVtZW50KGluc3QpIHtcbiAgcmV0dXJuICEhKGluc3QgJiYgUmVhY3QuaXNWYWxpZEVsZW1lbnQoaW5zdCkgJiYgISFpbnN0LnRhZ05hbWUpO1xufVxuXG5mdW5jdGlvbiBpc0NvbXBvc2l0ZUNvbXBvbmVudChpbnN0KSB7XG4gIGlmIChpc0RPTUNvbXBvbmVudChpbnN0KSkge1xuICAgIC8vIEFjY2Vzc2luZyBpbnN0LnNldFN0YXRlIHdhcm5zOyBqdXN0IHJldHVybiBmYWxzZSBhcyB0aGF0J2xsIGJlIHdoYXRcbiAgICAvLyB0aGlzIHJldHVybnMgd2hlbiB3ZSBoYXZlIERPTSBub2RlcyBhcyByZWZzIGRpcmVjdGx5XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGluc3QgIT0gbnVsbCAmJiB0eXBlb2YgaW5zdC5yZW5kZXIgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3Quc2V0U3RhdGUgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzQ29tcG9zaXRlQ29tcG9uZW50V2l0aFR5cGUoaW5zdCwgdHlwZSkge1xuICBpZiAoIWlzQ29tcG9zaXRlQ29tcG9uZW50KGluc3QpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXQoaW5zdCk7XG4gIHZhciBjb25zdHJ1Y3RvciA9IGludGVybmFsSW5zdGFuY2UudHlwZTtcbiAgcmV0dXJuIGNvbnN0cnVjdG9yID09PSB0eXBlO1xufVxuXG5mdW5jdGlvbiBmaW5kQWxsSW5SZW5kZXJlZFRyZWUoaW5zdCwgdGVzdCkge1xuICB2YWxpZGF0ZUNsYXNzSW5zdGFuY2UoaW5zdCwgJ2ZpbmRBbGxJblJlbmRlcmVkVHJlZScpO1xuXG4gIGlmICghaW5zdCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciBpbnRlcm5hbEluc3RhbmNlID0gZ2V0KGluc3QpO1xuICByZXR1cm4gZmluZEFsbEluUmVuZGVyZWRGaWJlclRyZWVJbnRlcm5hbChpbnRlcm5hbEluc3RhbmNlLCB0ZXN0KTtcbn1cbi8qKlxuICogRmluZHMgYWxsIGluc3RhbmNlcyBvZiBjb21wb25lbnRzIGluIHRoZSByZW5kZXJlZCB0cmVlIHRoYXQgYXJlIERPTVxuICogY29tcG9uZW50cyB3aXRoIHRoZSBjbGFzcyBuYW1lIG1hdGNoaW5nIGBjbGFzc05hbWVgLlxuICogQHJldHVybiB7YXJyYXl9IGFuIGFycmF5IG9mIGFsbCB0aGUgbWF0Y2hlcy5cbiAqL1xuXG5cbmZ1bmN0aW9uIHNjcnlSZW5kZXJlZERPTUNvbXBvbmVudHNXaXRoQ2xhc3Mocm9vdCwgY2xhc3NOYW1lcykge1xuICB2YWxpZGF0ZUNsYXNzSW5zdGFuY2Uocm9vdCwgJ3NjcnlSZW5kZXJlZERPTUNvbXBvbmVudHNXaXRoQ2xhc3MnKTtcbiAgcmV0dXJuIGZpbmRBbGxJblJlbmRlcmVkVHJlZShyb290LCBmdW5jdGlvbiAoaW5zdCkge1xuICAgIGlmIChpc0RPTUNvbXBvbmVudChpbnN0KSkge1xuICAgICAgdmFyIGNsYXNzTmFtZSA9IGluc3QuY2xhc3NOYW1lO1xuXG4gICAgICBpZiAodHlwZW9mIGNsYXNzTmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gU1ZHLCBwcm9iYWJseS5cbiAgICAgICAgY2xhc3NOYW1lID0gaW5zdC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJyc7XG4gICAgICB9XG5cbiAgICAgIHZhciBjbGFzc0xpc3QgPSBjbGFzc05hbWUuc3BsaXQoL1xccysvKTtcblxuICAgICAgaWYgKCFpc0FycmF5KGNsYXNzTmFtZXMpKSB7XG4gICAgICAgIGlmIChjbGFzc05hbWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Rlc3RVdGlscy5zY3J5UmVuZGVyZWRET01Db21wb25lbnRzV2l0aENsYXNzIGV4cGVjdHMgYSAnICsgJ2NsYXNzTmFtZSBhcyBhIHNlY29uZCBhcmd1bWVudC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNsYXNzTmFtZXMgPSBjbGFzc05hbWVzLnNwbGl0KC9cXHMrLyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjbGFzc05hbWVzLmV2ZXJ5KGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBjbGFzc0xpc3QuaW5kZXhPZihuYW1lKSAhPT0gLTE7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0pO1xufVxuLyoqXG4gKiBMaWtlIHNjcnlSZW5kZXJlZERPTUNvbXBvbmVudHNXaXRoQ2xhc3MgYnV0IGV4cGVjdHMgdGhlcmUgdG8gYmUgb25lIHJlc3VsdCxcbiAqIGFuZCByZXR1cm5zIHRoYXQgb25lIHJlc3VsdCwgb3IgdGhyb3dzIGV4Y2VwdGlvbiBpZiB0aGVyZSBpcyBhbnkgb3RoZXJcbiAqIG51bWJlciBvZiBtYXRjaGVzIGJlc2lkZXMgb25lLlxuICogQHJldHVybiB7IVJlYWN0RE9NQ29tcG9uZW50fSBUaGUgb25lIG1hdGNoLlxuICovXG5cblxuZnVuY3Rpb24gZmluZFJlbmRlcmVkRE9NQ29tcG9uZW50V2l0aENsYXNzKHJvb3QsIGNsYXNzTmFtZSkge1xuICB2YWxpZGF0ZUNsYXNzSW5zdGFuY2Uocm9vdCwgJ2ZpbmRSZW5kZXJlZERPTUNvbXBvbmVudFdpdGhDbGFzcycpO1xuICB2YXIgYWxsID0gc2NyeVJlbmRlcmVkRE9NQ29tcG9uZW50c1dpdGhDbGFzcyhyb290LCBjbGFzc05hbWUpO1xuXG4gIGlmIChhbGwubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdEaWQgbm90IGZpbmQgZXhhY3RseSBvbmUgbWF0Y2ggKGZvdW5kOiAnICsgYWxsLmxlbmd0aCArICcpICcgKyAnZm9yIGNsYXNzOicgKyBjbGFzc05hbWUpO1xuICB9XG5cbiAgcmV0dXJuIGFsbFswXTtcbn1cbi8qKlxuICogRmluZHMgYWxsIGluc3RhbmNlcyBvZiBjb21wb25lbnRzIGluIHRoZSByZW5kZXJlZCB0cmVlIHRoYXQgYXJlIERPTVxuICogY29tcG9uZW50cyB3aXRoIHRoZSB0YWcgbmFtZSBtYXRjaGluZyBgdGFnTmFtZWAuXG4gKiBAcmV0dXJuIHthcnJheX0gYW4gYXJyYXkgb2YgYWxsIHRoZSBtYXRjaGVzLlxuICovXG5cblxuZnVuY3Rpb24gc2NyeVJlbmRlcmVkRE9NQ29tcG9uZW50c1dpdGhUYWcocm9vdCwgdGFnTmFtZSkge1xuICB2YWxpZGF0ZUNsYXNzSW5zdGFuY2Uocm9vdCwgJ3NjcnlSZW5kZXJlZERPTUNvbXBvbmVudHNXaXRoVGFnJyk7XG4gIHJldHVybiBmaW5kQWxsSW5SZW5kZXJlZFRyZWUocm9vdCwgZnVuY3Rpb24gKGluc3QpIHtcbiAgICByZXR1cm4gaXNET01Db21wb25lbnQoaW5zdCkgJiYgaW5zdC50YWdOYW1lLnRvVXBwZXJDYXNlKCkgPT09IHRhZ05hbWUudG9VcHBlckNhc2UoKTtcbiAgfSk7XG59XG4vKipcbiAqIExpa2Ugc2NyeVJlbmRlcmVkRE9NQ29tcG9uZW50c1dpdGhUYWcgYnV0IGV4cGVjdHMgdGhlcmUgdG8gYmUgb25lIHJlc3VsdCxcbiAqIGFuZCByZXR1cm5zIHRoYXQgb25lIHJlc3VsdCwgb3IgdGhyb3dzIGV4Y2VwdGlvbiBpZiB0aGVyZSBpcyBhbnkgb3RoZXJcbiAqIG51bWJlciBvZiBtYXRjaGVzIGJlc2lkZXMgb25lLlxuICogQHJldHVybiB7IVJlYWN0RE9NQ29tcG9uZW50fSBUaGUgb25lIG1hdGNoLlxuICovXG5cblxuZnVuY3Rpb24gZmluZFJlbmRlcmVkRE9NQ29tcG9uZW50V2l0aFRhZyhyb290LCB0YWdOYW1lKSB7XG4gIHZhbGlkYXRlQ2xhc3NJbnN0YW5jZShyb290LCAnZmluZFJlbmRlcmVkRE9NQ29tcG9uZW50V2l0aFRhZycpO1xuICB2YXIgYWxsID0gc2NyeVJlbmRlcmVkRE9NQ29tcG9uZW50c1dpdGhUYWcocm9vdCwgdGFnTmFtZSk7XG5cbiAgaWYgKGFsbC5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RpZCBub3QgZmluZCBleGFjdGx5IG9uZSBtYXRjaCAoZm91bmQ6ICcgKyBhbGwubGVuZ3RoICsgJykgJyArICdmb3IgdGFnOicgKyB0YWdOYW1lKTtcbiAgfVxuXG4gIHJldHVybiBhbGxbMF07XG59XG4vKipcbiAqIEZpbmRzIGFsbCBpbnN0YW5jZXMgb2YgY29tcG9uZW50cyB3aXRoIHR5cGUgZXF1YWwgdG8gYGNvbXBvbmVudFR5cGVgLlxuICogQHJldHVybiB7YXJyYXl9IGFuIGFycmF5IG9mIGFsbCB0aGUgbWF0Y2hlcy5cbiAqL1xuXG5cbmZ1bmN0aW9uIHNjcnlSZW5kZXJlZENvbXBvbmVudHNXaXRoVHlwZShyb290LCBjb21wb25lbnRUeXBlKSB7XG4gIHZhbGlkYXRlQ2xhc3NJbnN0YW5jZShyb290LCAnc2NyeVJlbmRlcmVkQ29tcG9uZW50c1dpdGhUeXBlJyk7XG4gIHJldHVybiBmaW5kQWxsSW5SZW5kZXJlZFRyZWUocm9vdCwgZnVuY3Rpb24gKGluc3QpIHtcbiAgICByZXR1cm4gaXNDb21wb3NpdGVDb21wb25lbnRXaXRoVHlwZShpbnN0LCBjb21wb25lbnRUeXBlKTtcbiAgfSk7XG59XG4vKipcbiAqIFNhbWUgYXMgYHNjcnlSZW5kZXJlZENvbXBvbmVudHNXaXRoVHlwZWAgYnV0IGV4cGVjdHMgdGhlcmUgdG8gYmUgb25lIHJlc3VsdFxuICogYW5kIHJldHVybnMgdGhhdCBvbmUgcmVzdWx0LCBvciB0aHJvd3MgZXhjZXB0aW9uIGlmIHRoZXJlIGlzIGFueSBvdGhlclxuICogbnVtYmVyIG9mIG1hdGNoZXMgYmVzaWRlcyBvbmUuXG4gKiBAcmV0dXJuIHshUmVhY3RDb21wb25lbnR9IFRoZSBvbmUgbWF0Y2guXG4gKi9cblxuXG5mdW5jdGlvbiBmaW5kUmVuZGVyZWRDb21wb25lbnRXaXRoVHlwZShyb290LCBjb21wb25lbnRUeXBlKSB7XG4gIHZhbGlkYXRlQ2xhc3NJbnN0YW5jZShyb290LCAnZmluZFJlbmRlcmVkQ29tcG9uZW50V2l0aFR5cGUnKTtcbiAgdmFyIGFsbCA9IHNjcnlSZW5kZXJlZENvbXBvbmVudHNXaXRoVHlwZShyb290LCBjb21wb25lbnRUeXBlKTtcblxuICBpZiAoYWxsLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRGlkIG5vdCBmaW5kIGV4YWN0bHkgb25lIG1hdGNoIChmb3VuZDogJyArIGFsbC5sZW5ndGggKyAnKSAnICsgJ2ZvciBjb21wb25lbnRUeXBlOicgKyBjb21wb25lbnRUeXBlKTtcbiAgfVxuXG4gIHJldHVybiBhbGxbMF07XG59XG4vKipcbiAqIFBhc3MgYSBtb2NrZWQgY29tcG9uZW50IG1vZHVsZSB0byB0aGlzIG1ldGhvZCB0byBhdWdtZW50IGl0IHdpdGhcbiAqIHVzZWZ1bCBtZXRob2RzIHRoYXQgYWxsb3cgaXQgdG8gYmUgdXNlZCBhcyBhIGR1bW15IFJlYWN0IGNvbXBvbmVudC5cbiAqIEluc3RlYWQgb2YgcmVuZGVyaW5nIGFzIHVzdWFsLCB0aGUgY29tcG9uZW50IHdpbGwgYmVjb21lIGEgc2ltcGxlXG4gKiA8ZGl2PiBjb250YWluaW5nIGFueSBwcm92aWRlZCBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbW9kdWxlIHRoZSBtb2NrIGZ1bmN0aW9uIG9iamVjdCBleHBvcnRlZCBmcm9tIGFcbiAqICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlIHRoYXQgZGVmaW5lcyB0aGUgY29tcG9uZW50IHRvIGJlIG1vY2tlZFxuICogQHBhcmFtIHs/c3RyaW5nfSBtb2NrVGFnTmFtZSBvcHRpb25hbCBkdW1teSByb290IHRhZyBuYW1lIHRvIHJldHVyblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tIHJlbmRlciBtZXRob2QgKG92ZXJyaWRlc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGUubW9ja1RhZ05hbWUgaWYgcHJvdmlkZWQpXG4gKiBAcmV0dXJuIHtvYmplY3R9IHRoZSBSZWFjdFRlc3RVdGlscyBvYmplY3QgKGZvciBjaGFpbmluZylcbiAqL1xuXG5cbmZ1bmN0aW9uIG1vY2tDb21wb25lbnQobW9kdWxlLCBtb2NrVGFnTmFtZSkge1xuICB7XG4gICAgaWYgKCFoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRNb2NrQ29tcG9uZW50KSB7XG4gICAgICBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRNb2NrQ29tcG9uZW50ID0gdHJ1ZTtcblxuICAgICAgd2FybignUmVhY3RUZXN0VXRpbHMubW9ja0NvbXBvbmVudCgpIGlzIGRlcHJlY2F0ZWQuICcgKyAnVXNlIHNoYWxsb3cgcmVuZGVyaW5nIG9yIGplc3QubW9jaygpIGluc3RlYWQuXFxuXFxuJyArICdTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3Rlc3QtdXRpbHMtbW9jay1jb21wb25lbnQgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyk7XG4gICAgfVxuICB9XG5cbiAgbW9ja1RhZ05hbWUgPSBtb2NrVGFnTmFtZSB8fCBtb2R1bGUubW9ja1RhZ05hbWUgfHwgJ2Rpdic7XG4gIG1vZHVsZS5wcm90b3R5cGUucmVuZGVyLm1vY2tJbXBsZW1lbnRhdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQobW9ja1RhZ05hbWUsIG51bGwsIHRoaXMucHJvcHMuY2hpbGRyZW4pO1xuICB9KTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIG5hdGl2ZVRvdWNoRGF0YSh4LCB5KSB7XG4gIHJldHVybiB7XG4gICAgdG91Y2hlczogW3tcbiAgICAgIHBhZ2VYOiB4LFxuICAgICAgcGFnZVk6IHlcbiAgICB9XVxuICB9O1xufSAvLyBTdGFydCBvZiBpbmxpbmU6IHRoZSBiZWxvdyBmdW5jdGlvbnMgd2VyZSBpbmxpbmVkIGZyb21cbi8vIEV2ZW50UHJvcGFnYXRvci5qcywgYXMgdGhleSBkZXZpYXRlZCBmcm9tIFJlYWN0RE9NJ3MgbmV3ZXJcbi8vIGltcGxlbWVudGF0aW9ucy5cblxuLyoqXG4gKiBEaXNwYXRjaCB0aGUgZXZlbnQgdG8gdGhlIGxpc3RlbmVyLlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgU3ludGhldGljRXZlbnQgdG8gaGFuZGxlXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lciBBcHBsaWNhdGlvbi1sZXZlbCBjYWxsYmFja1xuICogQHBhcmFtIHsqfSBpbnN0IEludGVybmFsIGNvbXBvbmVudCBpbnN0YW5jZVxuICovXG5cblxuZnVuY3Rpb24gZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBsaXN0ZW5lciwgaW5zdCkge1xuICB2YXIgdHlwZSA9IGV2ZW50LnR5cGUgfHwgJ3Vua25vd24tZXZlbnQnO1xuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgaW52b2tlR3VhcmRlZENhbGxiYWNrQW5kQ2F0Y2hGaXJzdEVycm9yKHR5cGUsIGxpc3RlbmVyLCB1bmRlZmluZWQsIGV2ZW50KTtcbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IG51bGw7XG59XG4vKipcbiAqIFN0YW5kYXJkL3NpbXBsZSBpdGVyYXRpb24gdGhyb3VnaCBhbiBldmVudCdzIGNvbGxlY3RlZCBkaXNwYXRjaGVzLlxuICovXG5cblxuZnVuY3Rpb24gZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyKGV2ZW50KSB7XG4gIHZhciBkaXNwYXRjaExpc3RlbmVycyA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgdmFyIGRpc3BhdGNoSW5zdGFuY2VzID0gZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzO1xuXG4gIGlmIChpc0FycmF5KGRpc3BhdGNoTGlzdGVuZXJzKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSAvLyBMaXN0ZW5lcnMgYW5kIEluc3RhbmNlcyBhcmUgdHdvIHBhcmFsbGVsIGFycmF5cyB0aGF0IGFyZSBhbHdheXMgaW4gc3luYy5cblxuXG4gICAgICBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIGRpc3BhdGNoTGlzdGVuZXJzW2ldLCBkaXNwYXRjaEluc3RhbmNlc1tpXSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGRpc3BhdGNoTGlzdGVuZXJzKSB7XG4gICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBkaXNwYXRjaExpc3RlbmVycywgZGlzcGF0Y2hJbnN0YW5jZXMpO1xuICB9XG5cbiAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gbnVsbDtcbn1cbi8qKlxuICogRGlzcGF0Y2hlcyBhbiBldmVudCBhbmQgcmVsZWFzZXMgaXQgYmFjayBpbnRvIHRoZSBwb29sLCB1bmxlc3MgcGVyc2lzdGVudC5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGV2ZW50IFN5bnRoZXRpYyBldmVudCB0byBiZSBkaXNwYXRjaGVkLlxuICogQHByaXZhdGVcbiAqL1xuXG5cbnZhciBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgaWYgKGV2ZW50KSB7XG4gICAgZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyKGV2ZW50KTtcblxuICAgIGlmICghZXZlbnQuaXNQZXJzaXN0ZW50KCkpIHtcbiAgICAgIGV2ZW50LmNvbnN0cnVjdG9yLnJlbGVhc2UoZXZlbnQpO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gaXNJbnRlcmFjdGl2ZSh0YWcpIHtcbiAgcmV0dXJuIHRhZyA9PT0gJ2J1dHRvbicgfHwgdGFnID09PSAnaW5wdXQnIHx8IHRhZyA9PT0gJ3NlbGVjdCcgfHwgdGFnID09PSAndGV4dGFyZWEnO1xufVxuXG5mdW5jdGlvbiBnZXRQYXJlbnQoaW5zdCkge1xuICBkbyB7XG4gICAgaW5zdCA9IGluc3QucmV0dXJuOyAvLyBUT0RPOiBJZiB0aGlzIGlzIGEgSG9zdFJvb3Qgd2UgbWlnaHQgd2FudCB0byBiYWlsIG91dC5cbiAgICAvLyBUaGF0IGlzIGRlcGVuZGluZyBvbiBpZiB3ZSB3YW50IG5lc3RlZCBzdWJ0cmVlcyAobGF5ZXJzKSB0byBidWJibGVcbiAgICAvLyBldmVudHMgdG8gdGhlaXIgcGFyZW50LiBXZSBjb3VsZCBhbHNvIGdvIHRocm91Z2ggcGFyZW50Tm9kZSBvbiB0aGVcbiAgICAvLyBob3N0IG5vZGUgYnV0IHRoYXQgd291bGRuJ3Qgd29yayBmb3IgUmVhY3QgTmF0aXZlIGFuZCBkb2Vzbid0IGxldCB1c1xuICAgIC8vIGRvIHRoZSBwb3J0YWwgZmVhdHVyZS5cbiAgfSB3aGlsZSAoaW5zdCAmJiBpbnN0LnRhZyAhPT0gSG9zdENvbXBvbmVudCk7XG5cbiAgaWYgKGluc3QpIHtcbiAgICByZXR1cm4gaW5zdDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBTaW11bGF0ZXMgdGhlIHRyYXZlcnNhbCBvZiBhIHR3by1waGFzZSwgY2FwdHVyZS9idWJibGUgZXZlbnQgZGlzcGF0Y2guXG4gKi9cblxuXG5mdW5jdGlvbiB0cmF2ZXJzZVR3b1BoYXNlKGluc3QsIGZuLCBhcmcpIHtcbiAgdmFyIHBhdGggPSBbXTtcblxuICB3aGlsZSAoaW5zdCkge1xuICAgIHBhdGgucHVzaChpbnN0KTtcbiAgICBpbnN0ID0gZ2V0UGFyZW50KGluc3QpO1xuICB9XG5cbiAgdmFyIGk7XG5cbiAgZm9yIChpID0gcGF0aC5sZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgZm4ocGF0aFtpXSwgJ2NhcHR1cmVkJywgYXJnKTtcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgZm4ocGF0aFtpXSwgJ2J1YmJsZWQnLCBhcmcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZFByZXZlbnRNb3VzZUV2ZW50KG5hbWUsIHR5cGUsIHByb3BzKSB7XG4gIHN3aXRjaCAobmFtZSkge1xuICAgIGNhc2UgJ29uQ2xpY2snOlxuICAgIGNhc2UgJ29uQ2xpY2tDYXB0dXJlJzpcbiAgICBjYXNlICdvbkRvdWJsZUNsaWNrJzpcbiAgICBjYXNlICdvbkRvdWJsZUNsaWNrQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZURvd24nOlxuICAgIGNhc2UgJ29uTW91c2VEb3duQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZU1vdmUnOlxuICAgIGNhc2UgJ29uTW91c2VNb3ZlQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZVVwJzpcbiAgICBjYXNlICdvbk1vdXNlVXBDYXB0dXJlJzpcbiAgICBjYXNlICdvbk1vdXNlRW50ZXInOlxuICAgICAgcmV0dXJuICEhKHByb3BzLmRpc2FibGVkICYmIGlzSW50ZXJhY3RpdmUodHlwZSkpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gaW5zdCBUaGUgaW5zdGFuY2UsIHdoaWNoIGlzIHRoZSBzb3VyY2Ugb2YgZXZlbnRzLlxuICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgTmFtZSBvZiBsaXN0ZW5lciAoZS5nLiBgb25DbGlja2ApLlxuICogQHJldHVybiB7P2Z1bmN0aW9ufSBUaGUgc3RvcmVkIGNhbGxiYWNrLlxuICovXG5cblxuZnVuY3Rpb24gZ2V0TGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSkge1xuICAvLyBUT0RPOiBzaG91bGRQcmV2ZW50TW91c2VFdmVudCBpcyBET00tc3BlY2lmaWMgYW5kIGRlZmluaXRlbHkgc2hvdWxkIG5vdFxuICAvLyBsaXZlIGhlcmU7IG5lZWRzIHRvIGJlIG1vdmVkIHRvIGEgYmV0dGVyIHBsYWNlIHNvb25cbiAgdmFyIHN0YXRlTm9kZSA9IGluc3Quc3RhdGVOb2RlO1xuXG4gIGlmICghc3RhdGVOb2RlKSB7XG4gICAgLy8gV29yayBpbiBwcm9ncmVzcyAoZXg6IG9ubG9hZCBldmVudHMgaW4gaW5jcmVtZW50YWwgbW9kZSkuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgcHJvcHMgPSBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlKHN0YXRlTm9kZSk7XG5cbiAgaWYgKCFwcm9wcykge1xuICAgIC8vIFdvcmsgaW4gcHJvZ3Jlc3MuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbGlzdGVuZXIgPSBwcm9wc1tyZWdpc3RyYXRpb25OYW1lXTtcblxuICBpZiAoc2hvdWxkUHJldmVudE1vdXNlRXZlbnQocmVnaXN0cmF0aW9uTmFtZSwgaW5zdC50eXBlLCBwcm9wcykpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChsaXN0ZW5lciAmJiB0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBgXCIgKyByZWdpc3RyYXRpb25OYW1lICsgXCJgIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24sIGluc3RlYWQgZ290IGEgdmFsdWUgb2YgYFwiICsgdHlwZW9mIGxpc3RlbmVyICsgXCJgIHR5cGUuXCIpO1xuICB9XG5cbiAgcmV0dXJuIGxpc3RlbmVyO1xufVxuXG5mdW5jdGlvbiBsaXN0ZW5lckF0UGhhc2UoaW5zdCwgZXZlbnQsIHByb3BhZ2F0aW9uUGhhc2UpIHtcbiAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBldmVudC5fcmVhY3ROYW1lO1xuXG4gIGlmIChwcm9wYWdhdGlvblBoYXNlID09PSAnY2FwdHVyZWQnKSB7XG4gICAgcmVnaXN0cmF0aW9uTmFtZSArPSAnQ2FwdHVyZSc7XG4gIH1cblxuICByZXR1cm4gZ2V0TGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSk7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXNwYXRjaGVzKGluc3QsIGlnbm9yZWREaXJlY3Rpb24sIGV2ZW50KSB7XG4gIGlmIChpbnN0ICYmIGV2ZW50ICYmIGV2ZW50Ll9yZWFjdE5hbWUpIHtcbiAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IGV2ZW50Ll9yZWFjdE5hbWU7XG4gICAgdmFyIGxpc3RlbmVyID0gZ2V0TGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSk7XG5cbiAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgIGlmIChldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPT0gbnVsbCkge1xuICAgICAgICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcyA9PSBudWxsKSB7XG4gICAgICAgIGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcyA9IFtdO1xuICAgICAgfVxuXG4gICAgICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cbiAgICAgIGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcy5wdXNoKGluc3QpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzKGluc3QsIHBoYXNlLCBldmVudCkge1xuICB7XG4gICAgaWYgKCFpbnN0KSB7XG4gICAgICBlcnJvcignRGlzcGF0Y2hpbmcgaW5zdCBtdXN0IG5vdCBiZSBudWxsJyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJBdFBoYXNlKGluc3QsIGV2ZW50LCBwaGFzZSk7XG5cbiAgaWYgKGxpc3RlbmVyKSB7XG4gICAgaWYgKGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9PSBudWxsKSB7XG4gICAgICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBbXTtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID09IG51bGwpIHtcbiAgICAgIGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcyA9IFtdO1xuICAgIH1cblxuICAgIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcblxuICAgIGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcy5wdXNoKGluc3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlKGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5fcmVhY3ROYW1lKSB7XG4gICAgYWNjdW11bGF0ZURpc3BhdGNoZXMoZXZlbnQuX3RhcmdldEluc3QsIG51bGwsIGV2ZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlKGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5fcmVhY3ROYW1lKSB7XG4gICAgdHJhdmVyc2VUd29QaGFzZShldmVudC5fdGFyZ2V0SW5zdCwgYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcywgZXZlbnQpO1xuICB9XG59IC8vIEVuZCBvZiBpbmxpbmVcblxuXG52YXIgU2ltdWxhdGUgPSB7fTtcbnZhciBkaXJlY3REaXNwYXRjaEV2ZW50VHlwZXMgPSBuZXcgU2V0KFsnbW91c2VFbnRlcicsICdtb3VzZUxlYXZlJywgJ3BvaW50ZXJFbnRlcicsICdwb2ludGVyTGVhdmUnXSk7XG4vKipcbiAqIEV4cG9ydHM6XG4gKlxuICogLSBgU2ltdWxhdGUuY2xpY2soRWxlbWVudClgXG4gKiAtIGBTaW11bGF0ZS5tb3VzZU1vdmUoRWxlbWVudClgXG4gKiAtIGBTaW11bGF0ZS5jaGFuZ2UoRWxlbWVudClgXG4gKiAtIC4uLiAoQWxsIGtleXMgZnJvbSBldmVudCBwbHVnaW4gYGV2ZW50VHlwZXNgIG9iamVjdHMpXG4gKi9cblxuZnVuY3Rpb24gbWFrZVNpbXVsYXRvcihldmVudFR5cGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChkb21Ob2RlLCBldmVudERhdGEpIHtcbiAgICBpZiAoUmVhY3QuaXNWYWxpZEVsZW1lbnQoZG9tTm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGVzdFV0aWxzLlNpbXVsYXRlIGV4cGVjdGVkIGEgRE9NIG5vZGUgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IGJ1dCByZWNlaXZlZCAnICsgJ2EgUmVhY3QgZWxlbWVudC4gUGFzcyB0aGUgRE9NIG5vZGUgeW91IHdpc2ggdG8gc2ltdWxhdGUgdGhlIGV2ZW50IG9uIGluc3RlYWQuICcgKyAnTm90ZSB0aGF0IFRlc3RVdGlscy5TaW11bGF0ZSB3aWxsIG5vdCB3b3JrIGlmIHlvdSBhcmUgdXNpbmcgc2hhbGxvdyByZW5kZXJpbmcuJyk7XG4gICAgfVxuXG4gICAgaWYgKGlzQ29tcG9zaXRlQ29tcG9uZW50KGRvbU5vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Rlc3RVdGlscy5TaW11bGF0ZSBleHBlY3RlZCBhIERPTSBub2RlIGFzIHRoZSBmaXJzdCBhcmd1bWVudCBidXQgcmVjZWl2ZWQgJyArICdhIGNvbXBvbmVudCBpbnN0YW5jZS4gUGFzcyB0aGUgRE9NIG5vZGUgeW91IHdpc2ggdG8gc2ltdWxhdGUgdGhlIGV2ZW50IG9uIGluc3RlYWQuJyk7XG4gICAgfVxuXG4gICAgdmFyIHJlYWN0TmFtZSA9ICdvbicgKyBldmVudFR5cGVbMF0udG9VcHBlckNhc2UoKSArIGV2ZW50VHlwZS5zbGljZSgxKTtcbiAgICB2YXIgZmFrZU5hdGl2ZUV2ZW50ID0gbmV3IEV2ZW50KCk7XG4gICAgZmFrZU5hdGl2ZUV2ZW50LnRhcmdldCA9IGRvbU5vZGU7XG4gICAgZmFrZU5hdGl2ZUV2ZW50LnR5cGUgPSBldmVudFR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgdGFyZ2V0SW5zdCA9IGdldEluc3RhbmNlRnJvbU5vZGUoZG9tTm9kZSk7XG4gICAgdmFyIGV2ZW50ID0gbmV3IFN5bnRoZXRpY0V2ZW50KHJlYWN0TmFtZSwgZmFrZU5hdGl2ZUV2ZW50LnR5cGUsIHRhcmdldEluc3QsIGZha2VOYXRpdmVFdmVudCwgZG9tTm9kZSk7IC8vIFNpbmNlIHdlIGFyZW4ndCB1c2luZyBwb29saW5nLCBhbHdheXMgcGVyc2lzdCB0aGUgZXZlbnQuIFRoaXMgd2lsbCBtYWtlXG4gICAgLy8gc3VyZSBpdCdzIG1hcmtlZCBhbmQgd29uJ3Qgd2FybiB3aGVuIHNldHRpbmcgYWRkaXRpb25hbCBwcm9wZXJ0aWVzLlxuXG4gICAgZXZlbnQucGVyc2lzdCgpO1xuICAgIGFzc2lnbihldmVudCwgZXZlbnREYXRhKTtcblxuICAgIGlmIChkaXJlY3REaXNwYXRjaEV2ZW50VHlwZXMuaGFzKGV2ZW50VHlwZSkpIHtcbiAgICAgIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlKGV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZShldmVudCk7XG4gICAgfVxuXG4gICAgUmVhY3RET00udW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gTm9ybWFsbHkgZXh0cmFjdEV2ZW50IGVucXVldWVzIGEgc3RhdGUgcmVzdG9yZSwgYnV0IHdlJ2xsIGp1c3QgYWx3YXlzXG4gICAgICAvLyBkbyB0aGF0IHNpbmNlIHdlJ3JlIGJ5LXBhc3NpbmcgaXQgaGVyZS5cbiAgICAgIGVucXVldWVTdGF0ZVJlc3RvcmUoZG9tTm9kZSk7XG4gICAgICBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UoZXZlbnQpO1xuICAgICAgcmV0aHJvd0NhdWdodEVycm9yKCk7XG4gICAgfSk7XG4gICAgcmVzdG9yZVN0YXRlSWZOZWVkZWQoKTtcbiAgfTtcbn0gLy8gQSBvbmUtdGltZSBzbmFwc2hvdCB3aXRoIG5vIHBsYW5zIHRvIHVwZGF0ZS4gV2UnbGwgcHJvYmFibHkgd2FudCB0byBkZXByZWNhdGUgU2ltdWxhdGUgQVBJLlxuXG5cbnZhciBzaW11bGF0ZWRFdmVudFR5cGVzID0gWydibHVyJywgJ2NhbmNlbCcsICdjbGljaycsICdjbG9zZScsICdjb250ZXh0TWVudScsICdjb3B5JywgJ2N1dCcsICdhdXhDbGljaycsICdkb3VibGVDbGljaycsICdkcmFnRW5kJywgJ2RyYWdTdGFydCcsICdkcm9wJywgJ2ZvY3VzJywgJ2lucHV0JywgJ2ludmFsaWQnLCAna2V5RG93bicsICdrZXlQcmVzcycsICdrZXlVcCcsICdtb3VzZURvd24nLCAnbW91c2VVcCcsICdwYXN0ZScsICdwYXVzZScsICdwbGF5JywgJ3BvaW50ZXJDYW5jZWwnLCAncG9pbnRlckRvd24nLCAncG9pbnRlclVwJywgJ3JhdGVDaGFuZ2UnLCAncmVzZXQnLCAncmVzaXplJywgJ3NlZWtlZCcsICdzdWJtaXQnLCAndG91Y2hDYW5jZWwnLCAndG91Y2hFbmQnLCAndG91Y2hTdGFydCcsICd2b2x1bWVDaGFuZ2UnLCAnZHJhZycsICdkcmFnRW50ZXInLCAnZHJhZ0V4aXQnLCAnZHJhZ0xlYXZlJywgJ2RyYWdPdmVyJywgJ21vdXNlTW92ZScsICdtb3VzZU91dCcsICdtb3VzZU92ZXInLCAncG9pbnRlck1vdmUnLCAncG9pbnRlck91dCcsICdwb2ludGVyT3ZlcicsICdzY3JvbGwnLCAndG9nZ2xlJywgJ3RvdWNoTW92ZScsICd3aGVlbCcsICdhYm9ydCcsICdhbmltYXRpb25FbmQnLCAnYW5pbWF0aW9uSXRlcmF0aW9uJywgJ2FuaW1hdGlvblN0YXJ0JywgJ2NhblBsYXknLCAnY2FuUGxheVRocm91Z2gnLCAnZHVyYXRpb25DaGFuZ2UnLCAnZW1wdGllZCcsICdlbmNyeXB0ZWQnLCAnZW5kZWQnLCAnZXJyb3InLCAnZ290UG9pbnRlckNhcHR1cmUnLCAnbG9hZCcsICdsb2FkZWREYXRhJywgJ2xvYWRlZE1ldGFkYXRhJywgJ2xvYWRTdGFydCcsICdsb3N0UG9pbnRlckNhcHR1cmUnLCAncGxheWluZycsICdwcm9ncmVzcycsICdzZWVraW5nJywgJ3N0YWxsZWQnLCAnc3VzcGVuZCcsICd0aW1lVXBkYXRlJywgJ3RyYW5zaXRpb25FbmQnLCAnd2FpdGluZycsICdtb3VzZUVudGVyJywgJ21vdXNlTGVhdmUnLCAncG9pbnRlckVudGVyJywgJ3BvaW50ZXJMZWF2ZScsICdjaGFuZ2UnLCAnc2VsZWN0JywgJ2JlZm9yZUlucHV0JywgJ2NvbXBvc2l0aW9uRW5kJywgJ2NvbXBvc2l0aW9uU3RhcnQnLCAnY29tcG9zaXRpb25VcGRhdGUnXTtcblxuZnVuY3Rpb24gYnVpbGRTaW11bGF0b3JzKCkge1xuICBzaW11bGF0ZWRFdmVudFR5cGVzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50VHlwZSkge1xuICAgIFNpbXVsYXRlW2V2ZW50VHlwZV0gPSBtYWtlU2ltdWxhdG9yKGV2ZW50VHlwZSk7XG4gIH0pO1xufVxuXG5idWlsZFNpbXVsYXRvcnMoKTtcbnZhciBkaWRXYXJuQWJvdXRVc2luZ0FjdCA9IGZhbHNlO1xudmFyIGFjdCA9ICBmdW5jdGlvbiBhY3RXaXRoV2FybmluZyhjYWxsYmFjaykge1xuICB7XG4gICAgaWYgKCFkaWRXYXJuQWJvdXRVc2luZ0FjdCkge1xuICAgICAgZGlkV2FybkFib3V0VXNpbmdBY3QgPSB0cnVlO1xuXG4gICAgICBlcnJvcignYFJlYWN0RE9NVGVzdFV0aWxzLmFjdGAgaXMgZGVwcmVjYXRlZCBpbiBmYXZvciBvZiBgUmVhY3QuYWN0YC4gJyArICdJbXBvcnQgYGFjdGAgZnJvbSBgcmVhY3RgIGluc3RlYWQgb2YgYHJlYWN0LWRvbS90ZXN0LXV0aWxzYC4gJyArICdTZWUgaHR0cHM6Ly9yZWFjdC5kZXYvd2FybmluZ3MvcmVhY3QtZG9tLXRlc3QtdXRpbHMgZm9yIG1vcmUgaW5mby4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVhY3RBY3QoY2FsbGJhY2spO1xufSA7XG5cbmV4cG9ydHMuU2ltdWxhdGUgPSBTaW11bGF0ZTtcbmV4cG9ydHMuYWN0ID0gYWN0O1xuZXhwb3J0cy5maW5kQWxsSW5SZW5kZXJlZFRyZWUgPSBmaW5kQWxsSW5SZW5kZXJlZFRyZWU7XG5leHBvcnRzLmZpbmRSZW5kZXJlZENvbXBvbmVudFdpdGhUeXBlID0gZmluZFJlbmRlcmVkQ29tcG9uZW50V2l0aFR5cGU7XG5leHBvcnRzLmZpbmRSZW5kZXJlZERPTUNvbXBvbmVudFdpdGhDbGFzcyA9IGZpbmRSZW5kZXJlZERPTUNvbXBvbmVudFdpdGhDbGFzcztcbmV4cG9ydHMuZmluZFJlbmRlcmVkRE9NQ29tcG9uZW50V2l0aFRhZyA9IGZpbmRSZW5kZXJlZERPTUNvbXBvbmVudFdpdGhUYWc7XG5leHBvcnRzLmlzQ29tcG9zaXRlQ29tcG9uZW50ID0gaXNDb21wb3NpdGVDb21wb25lbnQ7XG5leHBvcnRzLmlzQ29tcG9zaXRlQ29tcG9uZW50V2l0aFR5cGUgPSBpc0NvbXBvc2l0ZUNvbXBvbmVudFdpdGhUeXBlO1xuZXhwb3J0cy5pc0RPTUNvbXBvbmVudCA9IGlzRE9NQ29tcG9uZW50O1xuZXhwb3J0cy5pc0RPTUNvbXBvbmVudEVsZW1lbnQgPSBpc0RPTUNvbXBvbmVudEVsZW1lbnQ7XG5leHBvcnRzLmlzRWxlbWVudCA9IGlzRWxlbWVudDtcbmV4cG9ydHMuaXNFbGVtZW50T2ZUeXBlID0gaXNFbGVtZW50T2ZUeXBlO1xuZXhwb3J0cy5tb2NrQ29tcG9uZW50ID0gbW9ja0NvbXBvbmVudDtcbmV4cG9ydHMubmF0aXZlVG91Y2hEYXRhID0gbmF0aXZlVG91Y2hEYXRhO1xuZXhwb3J0cy5yZW5kZXJJbnRvRG9jdW1lbnQgPSByZW5kZXJJbnRvRG9jdW1lbnQ7XG5leHBvcnRzLnNjcnlSZW5kZXJlZENvbXBvbmVudHNXaXRoVHlwZSA9IHNjcnlSZW5kZXJlZENvbXBvbmVudHNXaXRoVHlwZTtcbmV4cG9ydHMuc2NyeVJlbmRlcmVkRE9NQ29tcG9uZW50c1dpdGhDbGFzcyA9IHNjcnlSZW5kZXJlZERPTUNvbXBvbmVudHNXaXRoQ2xhc3M7XG5leHBvcnRzLnNjcnlSZW5kZXJlZERPTUNvbXBvbmVudHNXaXRoVGFnID0gc2NyeVJlbmRlcmVkRE9NQ29tcG9uZW50c1dpdGhUYWc7XG5leHBvcnRzLnRyYXZlcnNlVHdvUGhhc2UgPSB0cmF2ZXJzZVR3b1BoYXNlO1xuICB9KSgpO1xufVxuIl0sInZlcnNpb24iOjN9