import{c as q,_ as I}from"./supabase-BJjf9Ixn.js";import{D}from"./database-CD-G83dI.js";const _="https://elwnpejlwkgdacaugvvd.supabase.co",M="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImVsd25wZWpsd2tnZGFjYXVndnZkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTMzMzkxNTAsImV4cCI6MjA2ODkxNTE1MH0.XhVGgO2nf8uS1gC0V6jTMP0p0xN5KKV47t2rK2ncK90",f=q(_,M,{auth:{autoRefreshToken:!0,persistSession:!0,detectSessionInUrl:!0},realtime:{params:{eventsPerSecond:10}}});class z{listeners=[];currentState={user:null,session:null,loading:!0,error:null};constructor(){this.initialize(),setTimeout(()=>{this.setupSyncService()},0)}setupSyncService(){try{I(async()=>{const{unifiedSyncService:e}=await Promise.resolve().then(()=>b);return{unifiedSyncService:e}},void 0).then(({unifiedSyncService:e})=>{e.setAuthService(this)}).catch(e=>{console.warn("Failed to setup unified sync service:",e)})}catch(e){console.warn("Failed to setup unified sync service:",e)}}async initialize(){try{const{data:{session:e},error:t}=await f.auth.getSession();if(t){this.updateState({error:t.message,loading:!1});return}if(e?.user){const i=await this.fetchUserProfile(e.user.id);this.updateState({user:i,session:e,loading:!1,error:null})}else this.updateState({loading:!1});f.auth.onAuthStateChange(async(i,n)=>{if(console.log("Auth state changed:",i,n?.user?.id),i==="SIGNED_OUT"){try{const{unifiedSyncService:s}=await I(async()=>{const{unifiedSyncService:r}=await Promise.resolve().then(()=>b);return{unifiedSyncService:r}},void 0);await s.clearHistory()}catch(s){console.warn("Failed to clear sync history on signout:",s)}this.updateState({user:null,session:null,loading:!1,error:null})}else if(n?.user){const s=await this.fetchUserProfile(n.user.id);if(this.updateState({user:s,session:n,loading:!1,error:null}),i==="SIGNED_IN")try{const{unifiedSyncService:r}=await I(async()=>{const{unifiedSyncService:a}=await Promise.resolve().then(()=>b);return{unifiedSyncService:a}},void 0);await r.performFullSync()}catch(r){console.warn("Failed to perform full sync after signin:",r)}}else this.updateState({user:null,session:null,loading:!1,error:null})})}catch(e){console.error("Auth initialization failed:",e),this.updateState({error:e instanceof Error?e.message:"Authentication failed",loading:!1})}}async fetchUserProfile(e){try{await new Promise(n=>setTimeout(n,100));const{data:t,error:i}=await f.from("users").select("*").eq("id",e).single();return i?(console.error("Failed to fetch user profile:",i),null):t}catch(t){return console.error("Error fetching user profile:",t),null}}updateState(e){this.currentState={...this.currentState,...e},this.listeners.forEach(t=>t(this.currentState))}onAuthStateChange(e){return this.listeners.push(e),e(this.currentState),()=>{const t=this.listeners.indexOf(e);t>-1&&this.listeners.splice(t,1)}}getCurrentState(){return this.currentState}async signUpWithEmail(e,t,i){try{this.updateState({loading:!0,error:null});const{data:n,error:s}=await f.auth.signUp({email:e,password:t,options:{data:{name:i?.name||e.split("@")[0],full_name:i?.name||e.split("@")[0]}}});return s?(this.updateState({error:s.message,loading:!1}),{error:s}):(this.updateState({loading:!1,error:null}),{error:null})}catch(n){const s=n instanceof Error?n.message:"Registration failed";return this.updateState({error:s,loading:!1}),{error:n}}}async signInWithEmail(e,t){try{this.updateState({loading:!0,error:null});const{error:i}=await f.auth.signInWithPassword({email:e,password:t});return i?(this.updateState({error:i.message,loading:!1}),{error:i}):{error:null}}catch(i){const n=i instanceof Error?i.message:"Login failed";return this.updateState({error:n,loading:!1}),{error:i}}}async resetPassword(e){try{this.updateState({loading:!0,error:null});const{error:t}=await f.auth.resetPasswordForEmail(e,{redirectTo:`${window.location.origin}/auth/reset-password`});return t?(this.updateState({error:t.message,loading:!1}),{error:t}):(this.updateState({loading:!1,error:null}),{error:null})}catch(t){const i=t instanceof Error?t.message:"Password reset failed";return this.updateState({error:i,loading:!1}),{error:t}}}async signInWithGitHub(){try{this.updateState({loading:!0,error:null});const{error:e}=await f.auth.signInWithOAuth({provider:"github",options:{redirectTo:`${window.location.origin}`}});return e?(this.updateState({error:e.message,loading:!1}),{error:e}):{error:null}}catch(e){const t=e instanceof Error?e.message:"Login failed";return this.updateState({error:t,loading:!1}),{error:e}}}async signOut(){try{this.updateState({loading:!0,error:null});const{error:e}=await f.auth.signOut();return e?(this.updateState({error:e.message,loading:!1}),{error:e}):(this.updateState({user:null,session:null,loading:!1,error:null}),{error:null})}catch(e){const t=e instanceof Error?e.message:"Logout failed";return this.updateState({error:t,loading:!1}),{error:e}}}async upsertUserProfile(e){try{if(!this.currentState.session?.user.id)return console.error("No authenticated user found"),null;const{data:t,error:i}=await f.from("users").upsert({id:this.currentState.session.user.id,...e,updated_at:new Date().toISOString()}).select().single();return i?(console.error("Failed to upsert user profile:",i),null):t}catch(t){return console.error("Error upserting user profile:",t),null}}isAuthenticated(){return!!this.currentState.user&&!!this.currentState.session}getCurrentUser(){return this.currentState.user}getCurrentSession(){return this.currentState.session}}const F=new z;let N=class extends D{cards;folders;tags;images;syncQueue;settings;sessions;constructor(){super("CardAllUnifiedDatabase"),this.version(3).stores({cards:"++id, userId, folderId, createdAt, updatedAt, syncVersion, pendingSync, [userId+folderId], searchVector",folders:"++id, userId, parentId, createdAt, updatedAt, syncVersion, pendingSync, [userId+parentId], fullPath, depth",tags:"++id, userId, name, createdAt, syncVersion, pendingSync, [userId+name]",images:"++id, cardId, userId, createdAt, updatedAt, syncVersion, pendingSync, storageMode, [cardId+userId]",syncQueue:"++id, type, entity, entityId, userId, timestamp, retryCount, priority, [userId+priority]",settings:"++id, key, updatedAt, scope, [key+scope]",sessions:"++id, userId, deviceId, lastActivity, isActive, [userId+deviceId]"}),this.upgradeDatabase()}async upgradeDatabase(){this.version(2).upgrade(async e=>{console.log("Upgrading to version 2: Adding user support...");const t=new B;try{await t.open(),console.log("Found old database, migrating data...");const n=(await t.cards.toArray()).map(c=>({...c,userId:"default",updatedAt:new Date}));await this.cards.bulkAdd(n);const r=(await t.folders.toArray()).map(c=>({...c,userId:"default",updatedAt:new Date}));await this.folders.bulkAdd(r);const o=(await t.tags.toArray()).map(c=>({...c,userId:"default",updatedAt:new Date}));await this.tags.bulkAdd(o),console.log("Migration completed successfully")}catch(i){console.log("No old database found or migration failed:",i)}}),this.version(3).upgrade(async e=>{console.log("Upgrading to version 3: Optimizing indexes and adding new features..."),await this.initializeDefaultSettings(),await this.rebuildSearchIndexes()})}async initializeDefaultSettings(){const e=[{key:"storageMode",value:"hybrid",scope:"global",updatedAt:new Date},{key:"syncEnabled",value:!0,scope:"global",updatedAt:new Date},{key:"imageCompression",value:{enabled:!0,quality:.8,maxWidth:1920,maxHeight:1080,format:"webp"},scope:"global",updatedAt:new Date},{key:"databaseVersion",value:"3.0.0",scope:"global",updatedAt:new Date}];for(const t of e)await this.settings.where("key").equals(t.key).first()||await this.settings.add(t)}async rebuildSearchIndexes(){console.log("Rebuilding search indexes...")}async getSetting(e,t){if(t){const n=await this.settings.where("[key+scope]").equals([e,"user"]).and(s=>!s.userId||s.userId===t).first();if(n)return n.value}return(await this.settings.where("[key+scope]").equals([e,"global"]).first())?.value}async updateSetting(e,t,i="global",n){await this.settings.where("[key+scope]").equals([e,i]).modify({value:t,userId:n,updatedAt:new Date})}async getStats(){const[e,t,i,n,s]=await Promise.all([this.cards.count(),this.folders.count(),this.tags.count(),this.images.count(),this.syncQueue.count()]),r=await this.calculateTotalSize();return{cards:e,folders:t,tags:i,images:n,pendingSync:s,totalSize:r,version:"3.0.0"}}async calculateTotalSize(){return(await this.images.toArray()).reduce((t,i)=>t+i.metadata.size,0)}async createCard(e,t){const i=crypto.randomUUID(),n=new Date;return await this.cards.add({...e,id:i,userId:t,syncVersion:1,pendingSync:!0,updatedAt:n}),i}async updateCard(e,t){return await this.cards.update(e,{...t,syncVersion:t.syncVersion?t.syncVersion+1:void 0,pendingSync:!0,updatedAt:new Date})}async deleteCard(e){await this.transaction("rw",[this.cards,this.images],async()=>{await this.images.where("cardId").equals(e).delete(),await this.cards.delete(e)})}async bulkCreateCards(e,t){const i=new Date,n=e.map(s=>({...s,id:crypto.randomUUID(),userId:t,syncVersion:1,pendingSync:!0,updatedAt:i}));return await this.cards.bulkAdd(n),n.map(s=>s.id)}async getCardsByFolder(e,t){return await this.cards.where("[userId+folderId]").equals([t||"default",e]).toArray()}async searchCards(e,t){const i=e.toLowerCase();return await this.cards.filter(n=>n.searchVector?.includes(i)||n.frontContent.title.toLowerCase().includes(i)||n.frontContent.text.toLowerCase().includes(i)||n.backContent.title.toLowerCase().includes(i)||n.backContent.text.toLowerCase().includes(i)).toArray()}async cleanup(){await this.transaction("rw",[this.cards,this.folders,this.tags,this.images,this.syncQueue],async()=>{const e=new Date(Date.now()-6048e5);await this.syncQueue.where("timestamp").below(e).delete();const t=await this.cards.toCollection().primaryKeys();await this.images.where("cardId").noneOf(t).delete(),console.log("Database cleanup completed")})}async healthCheck(){const e=[];try{await this.tables.toArray();const t=await this.getStats();return t.pendingSync>1e3&&e.push(`High number of pending sync operations: ${t.pendingSync}`),t.totalSize>500*1024*1024&&e.push(`Database size is large: ${(t.totalSize/1024/1024).toFixed(2)} MB`),{isHealthy:e.length===0,issues:e,stats:t}}catch(t){return{isHealthy:!1,issues:[`Database connection failed: ${t}`],stats:{cards:0,folders:0,tags:0,images:0,pendingSync:0,totalSize:0,version:"3.0.0"}}}}async clearAll(){await this.transaction("rw",[this.cards,this.folders,this.tags,this.images,this.syncQueue,this.settings,this.sessions],async()=>{await this.cards.clear(),await this.folders.clear(),await this.tags.clear(),await this.images.clear(),await this.syncQueue.clear(),await this.sessions.clear()})}async getSettingLegacy(e){return await this.getSetting(e)}async updateSettingLegacy(e,t){await this.updateSetting(e,t)}async clearAllLegacy(){await this.transaction("rw",this.cards,this.folders,this.tags,this.images,this.syncQueue,async()=>{await this.cards.clear(),await this.folders.clear(),await this.tags.clear(),await this.images.clear(),await this.syncQueue.clear()})}async getStatsLegacy(){const e=await this.getStats();return{cards:e.cards,folders:e.folders,tags:e.tags,images:e.images,pendingSync:e.pendingSync}}},B=class extends D{cards;folders;tags;images;syncQueue;settings;constructor(){super("CardAllDatabase"),this.version(1).stores({cards:"++id, folderId, createdAt, updatedAt, syncVersion, pendingSync",folders:"++id, parentId, createdAt, updatedAt, syncVersion, pendingSync",tags:"++id, name, createdAt, syncVersion, pendingSync",images:"++id, cardId, filePath, createdAt, syncVersion, pendingSync",syncQueue:"++id, type, entity, entityId, timestamp, retryCount",settings:"++id, key, updatedAt"})}};const d=new N;d.on("error",p=>{console.error("Database error:",p)});d.on("blocked",()=>{console.warn("Database operation blocked")});d.on("versionchange",()=>{console.warn("Database version changed, reloading page..."),window.location.reload()});d.on("ready",()=>{console.log("Database is ready")});const A=new Map,x=5*60*1e3;setInterval(()=>{const p=Date.now();for(const[e,t]of A.entries())p-t.timestamp>x&&A.delete(e)},x);const L={checkInterval:5e3,qualityCheckInterval:3e4,qualityThresholds:{excellent:{rtt:100,downlink:10},good:{rtt:200,downlink:5},fair:{rtt:500,downlink:1},poor:{rtt:1e3,downlink:.1}},reconnect:{maxAttempts:10,initialDelay:1e3,maxDelay:3e4,backoffMultiplier:2},healthCheck:{enabled:!0,endpoints:["https://www.google.com","https://www.cloudflare.com","https://www.github.com"],timeout:5e3,successThreshold:2},eventFilter:{minQualityChange:.1,debounceTime:1e3}};class U{config;currentState;isMonitoring=!1;checkTimer=null;qualityTimer=null;reconnectTimer=null;debounceTimer=null;listeners=new Set;stats;startTime;lastOnlineTime;lastOfflineTime;connection;connectionTypes=["wifi","cellular","ethernet","bluetooth","wimax","other","none"];reconnectAttempts=0;isReconnecting=!1;constructor(e={}){this.config={...L,...e},this.currentState=this.getInitialNetworkState(),this.stats=this.getInitialStats(),this.startTime=new Date,this.initialize()}initialize(){"connection"in navigator&&(this.connection=navigator.connection),window.addEventListener("online",this.handleOnline.bind(this)),window.addEventListener("offline",this.handleOffline.bind(this)),this.connection&&this.connection.addEventListener("change",this.handleConnectionChange.bind(this)),console.log("NetworkMonitorService initialized")}getInitialNetworkState(){return{online:navigator.onLine,connectionType:this.getConnectionType(),effectiveType:this.getEffectiveType(),downlink:this.connection?.downlink,rtt:this.connection?.rtt,saveData:this.connection?.saveData,deviceMemory:navigator.deviceMemory,hardwareConcurrency:navigator.hardwareConcurrency,timestamp:new Date}}getInitialStats(){return{connectionChanges:0,onlineTime:0,offlineTime:0,averageQuality:0,qualityHistory:[],averageRtt:0,averageDownlink:0,errorCount:0,reconnectAttempts:0,successfulReconnects:0}}startMonitoring(){this.isMonitoring||(this.isMonitoring=!0,this.startPeriodicChecks(),console.log("Network monitoring started"),this.emitEvent({type:"connection-change",timestamp:new Date,currentState:this.currentState,details:{action:"monitoring_started"}}))}stopMonitoring(){this.isMonitoring&&(this.isMonitoring=!1,this.stopPeriodicChecks(),console.log("Network monitoring stopped"),this.emitEvent({type:"connection-change",timestamp:new Date,currentState:this.currentState,details:{action:"monitoring_stopped"}}))}getCurrentState(){return{...this.currentState}}getNetworkQuality(){return this.calculateQuality(this.currentState)}getNetworkQualityScore(){return this.calculateQualityScore(this.currentState)}getStats(){return{...this.stats}}async checkNetwork(){const e=await this.getCurrentNetworkInfo();return await this.updateNetworkState(e),e}async performHealthCheck(){if(!this.config.healthCheck.enabled)return this.currentState.online;try{const e=this.config.healthCheck.endpoints.map(s=>this.pingEndpoint(s,this.config.healthCheck.timeout)),i=(await Promise.allSettled(e)).filter(s=>s.status==="fulfilled"&&s.value).length,n=i>=this.config.healthCheck.successThreshold;return console.log(`Health check: ${i}/${this.config.healthCheck.endpoints.length} successful`),n}catch(e){return console.error("Health check failed:",e),!1}}addEventListener(e){this.listeners.add(e)}removeEventListener(e){this.listeners.delete(e)}emitEvent(e){this.config.eventFilter.debounceTime>0?(this.debounceTimer&&clearTimeout(this.debounceTimer),this.debounceTimer=setTimeout(()=>{this.listeners.forEach(t=>{try{t(e)}catch(i){console.error("Error in network event listener:",i)}})},this.config.eventFilter.debounceTime)):this.listeners.forEach(t=>{try{t(e)}catch(i){console.error("Error in network event listener:",i)}})}async handleOnline(){console.log("Network online event detected");const e={...this.currentState};this.currentState.online=!0,this.currentState.lastChange=new Date,this.lastOnlineTime=new Date,this.lastOfflineTime&&(this.stats.offlineTime+=Date.now()-this.lastOfflineTime.getTime(),this.lastOfflineTime=void 0),this.stopReconnectAttempts(),this.emitEvent({type:"online",timestamp:new Date,previousState:e,currentState:this.currentState}),await this.checkNetwork()}handleOffline(){console.log("Network offline event detected");const e={...this.currentState};this.currentState.online=!1,this.currentState.lastChange=new Date,this.lastOfflineTime=new Date,this.lastOnlineTime&&(this.stats.onlineTime+=Date.now()-this.lastOnlineTime.getTime()),this.emitEvent({type:"offline",timestamp:new Date,previousState:e,currentState:this.currentState}),this.startReconnectAttempts()}async handleConnectionChange(){console.log("Network connection change detected");const e={...this.currentState},t=await this.getCurrentNetworkInfo();Math.abs(this.calculateQualityScore(t)-this.calculateQualityScore(e))>=this.config.eventFilter.minQualityChange&&(this.currentState=t,this.currentState.lastChange=new Date,this.stats.connectionChanges++,this.emitEvent({type:"connection-change",timestamp:new Date,previousState:e,currentState:this.currentState}))}async updateNetworkState(e){const t={...this.currentState},i=Math.abs(this.calculateQualityScore(e)-this.calculateQualityScore(t));i>=this.config.eventFilter.minQualityChange&&(this.currentState=e,this.currentState.lastChange=new Date,this.updateQualityHistory(),this.emitEvent({type:"quality-change",timestamp:new Date,previousState:t,currentState:this.currentState,details:{qualityChange:i,previousQuality:this.calculateQuality(t),currentQuality:this.calculateQuality(e)}}))}startPeriodicChecks(){this.checkTimer=setInterval(async()=>{this.isMonitoring&&await this.checkNetwork()},this.config.checkInterval),this.qualityTimer=setInterval(async()=>{this.isMonitoring&&await this.performQualityCheck()},this.config.qualityCheckInterval)}stopPeriodicChecks(){this.checkTimer&&(clearInterval(this.checkTimer),this.checkTimer=null),this.qualityTimer&&(clearInterval(this.qualityTimer),this.qualityTimer=null)}async performQualityCheck(){try{!await this.performHealthCheck()&&this.currentState.online&&(console.warn("Network appears online but health check failed"),this.currentState.online=!1,this.currentState.lastChange=new Date,this.emitEvent({type:"error",timestamp:new Date,currentState:this.currentState,details:{message:"Health check failed despite online status"}}))}catch(e){console.error("Quality check failed:",e),this.stats.errorCount++}}startReconnectAttempts(){this.isReconnecting||(this.isReconnecting=!0,this.reconnectAttempts=0,this.scheduleReconnectAttempt())}stopReconnectAttempts(){this.isReconnecting=!1,this.reconnectTimer&&(clearTimeout(this.reconnectTimer),this.reconnectTimer=null)}scheduleReconnectAttempt(){if(!this.isReconnecting||this.reconnectAttempts>=this.config.reconnect.maxAttempts){this.isReconnecting=!1;return}const e=Math.min(this.config.reconnect.initialDelay*Math.pow(this.config.reconnect.backoffMultiplier,this.reconnectAttempts),this.config.reconnect.maxDelay);this.reconnectTimer=setTimeout(async()=>{this.reconnectAttempts++,this.stats.reconnectAttempts++,console.log(`Reconnect attempt ${this.reconnectAttempts}/${this.config.reconnect.maxAttempts}`);try{if(navigator.onLine&&await this.performHealthCheck()){this.stats.successfulReconnects++,this.isReconnecting=!1,console.log("Reconnect successful"),this.emitEvent({type:"online",timestamp:new Date,currentState:this.currentState,details:{reconnectAttempts:this.reconnectAttempts}}),await this.handleOnline();return}}catch(t){console.error("Reconnect attempt failed:",t)}this.scheduleReconnectAttempt()},e)}async getCurrentNetworkInfo(){const e=this.getInitialNetworkState();if(this.config.healthCheck.enabled)try{const t=await this.performHealthCheck();e.online=t&&navigator.onLine}catch(t){console.warn("Health check failed, using navigator.onLine:",t)}if(e.online)try{const t=await this.getEnhancedNetworkInfo();return{...e,...t}}catch(t){console.warn("Enhanced network info failed, using basic info:",t)}return e}getConnectionType(){if(!this.connection)return"none";const e=this.connection.type;return this.connectionTypes.includes(e)?e:"other"}getEffectiveType(){if(!this.connection)return"unknown";const e=this.connection.effectiveType;return["4g","3g","2g","slow-2g"].includes(e)?e:"unknown"}calculateQuality(e){const t=this.calculateQualityScore(e);return t>=.8?"excellent":t>=.6?"good":t>=.4?"fair":t>=.2?"poor":"offline"}calculateQualityScore(e){if(!e.online)return 0;let t=.5;return e.rtt!==void 0&&(e.rtt<=100?t+=.3:e.rtt<=200?t+=.2:e.rtt<=500&&(t+=.1)),e.downlink!==void 0&&(e.downlink>=10?t+=.3:e.downlink>=5?t+=.2:e.downlink>=1&&(t+=.1)),(e.connectionType==="wifi"||e.connectionType==="ethernet")&&(t+=.1),e.saveData&&(t-=.1),Math.max(0,Math.min(1,t))}updateQualityHistory(){const e=this.getNetworkQuality(),t=this.getNetworkQualityScore();this.stats.qualityHistory.push({timestamp:new Date,quality:e,score:t}),this.stats.qualityHistory.length>100&&(this.stats.qualityHistory=this.stats.qualityHistory.slice(-100));const i=this.stats.qualityHistory.slice(-20);i.length>0&&(this.stats.averageQuality=i.reduce((n,s)=>n+s.score,0)/i.length)}async pingEndpoint(e,t){try{const i=new AbortController,n=setTimeout(()=>i.abort(),t),s=performance.now(),r=await fetch(`${e}/favicon.ico`,{method:"HEAD",signal:i.signal,mode:"no-cors",headers:{"Cache-Control":"no-cache",Pragma:"no-cache"}});clearTimeout(n);const a=performance.now()-s;return this.recordResponseTime(a),!0}catch(i){return this.recordError("ping_failed",{endpoint:e,error:i instanceof Error?i.message:String(i)}),!1}}recordResponseTime(e){this.stats.averageRtt===0?this.stats.averageRtt=e:this.stats.averageRtt=this.stats.averageRtt*.8+e*.2,this.stats.qualityHistory.push({timestamp:new Date,quality:this.calculateQuality(this.currentState),score:this.calculateQualityScore(this.currentState)}),this.stats.qualityHistory.length>100&&(this.stats.qualityHistory=this.stats.qualityHistory.slice(-50))}recordError(e,t){this.stats.errorCount++,this.stats.lastError=new Error(`${e}: ${JSON.stringify(t)}`),this.emitEvent({type:"error",timestamp:new Date,currentState:this.currentState,details:{type:e,details:t}})}async getEnhancedNetworkInfo(){const e=await this.getCurrentNetworkInfo(),t=await this.performQualityAnalysis();return{...e,...t}}async performQualityAnalysis(){const e={};try{const t=await this.measureDownloadSpeed();t>0&&(e.downlink=t);const i=await this.measureLatency();i>0&&(e.rtt=i);const n=await this.measureJitter();n>0&&(e.jitter=n);const s=await this.estimatePacketLoss();s>=0&&(this.stats.packetLoss=s)}catch(t){console.warn("Quality analysis failed:",t)}return e}async measureDownloadSpeed(){try{const e=new Array(1024).fill("test").join(""),t=`data:text/plain;base64,${btoa(e)}`,i=performance.now();await(await fetch(t)).text();const s=performance.now()-i;return e.length/1024/(s/1e3)*8/1024}catch{return 0}}async measureLatency(){try{const e=[];for(let t=0;t<3;t++){const i=performance.now();await fetch("https://www.google.com/favicon.ico",{method:"HEAD",mode:"no-cors",signal:AbortSignal.timeout(3e3)}),e.push(performance.now()-i)}return e.reduce((t,i)=>t+i,0)/e.length}catch{return 0}}async measureJitter(){try{const e=[];for(let n=0;n<5;n++){const s=performance.now();await fetch("https://www.cloudflare.com/favicon.ico",{method:"HEAD",mode:"no-cors",signal:AbortSignal.timeout(2e3)}),e.push(performance.now()-s)}const t=e.reduce((n,s)=>n+s,0)/e.length,i=e.reduce((n,s)=>n+Math.pow(s-t,2),0)/e.length;return Math.sqrt(i)}catch{return 0}}async estimatePacketLoss(){try{let t=0;const i=Array(10).fill(0).map(async()=>{try{await fetch("https://www.github.com/favicon.ico",{method:"HEAD",mode:"no-cors",signal:AbortSignal.timeout(1e3)}),t++}catch{}});return await Promise.allSettled(i),1-t/10}catch{return 0}}async predictNetworkStability(){const e=this.stats.qualityHistory.slice(-10);if(e.length<5)return{isStable:this.currentState.online,confidence:.5,predictedDuration:300,recommendations:["需要更多数据来进行准确预测"]};const t=this.analyzeQualityTrend(e),i=this.calculateStabilityScore(e),n=i>.7&&t!=="degrading",s=Math.min(i,e.length/10),r=this.generateNetworkRecommendations(t,i);return{isStable:n,confidence:s,predictedDuration:this.predictStableDuration(i),recommendations:r}}analyzeQualityTrend(e){if(e.length<3)return"stable";const t=e.slice(-3).map(a=>a.score),i=e.slice(-6,-3).map(a=>a.score),n=t.reduce((a,o)=>a+o,0)/t.length,s=i.reduce((a,o)=>a+o,0)/i.length,r=n-s;return r>.1?"improving":r<-.1?"degrading":"stable"}calculateStabilityScore(e){if(e.length===0)return 0;const t=e.map(r=>r.score),i=t.reduce((r,a)=>r+a,0)/t.length,n=t.reduce((r,a)=>r+Math.pow(a-i,2),0)/t.length,s=Math.sqrt(n);return Math.max(0,1-s/i)}generateNetworkRecommendations(e,t){const i=[];return e==="degrading"?(i.push("网络质量正在下降，建议检查网络连接"),t<.5&&i.push("网络连接不稳定，建议切换到更稳定的网络")):e==="improving"&&i.push("网络质量正在改善"),t>.8?i.push("网络连接稳定，可以进行大量数据同步"):t<.5&&i.push("建议启用数据压缩和离线模式"),i}predictStableDuration(e){return e>.9?3600:e>.7?1800:e>.5?600:300}destroy(){this.stopMonitoring(),window.removeEventListener("online",this.handleOnline.bind(this)),window.removeEventListener("offline",this.handleOffline.bind(this)),this.connection&&this.connection.removeEventListener("change",this.handleConnectionChange.bind(this)),this.debounceTimer&&clearTimeout(this.debounceTimer),console.log("NetworkMonitorService destroyed")}}const w=new U;class O{static instance;currentState;syncStrategy;listeners=new Set;circuitBreakers=new Map;pendingRequests=new Map;batchTimer=null;isProcessing=!1;stats={totalRequests:0,successfulRequests:0,failedRequests:0,averageResponseTime:0,lastError:null,circuitBreakerTrips:0};constructor(){this.currentState=this.getInitialState(),this.syncStrategy=this.getDefaultStrategy(),this.initialize()}static getInstance(){return O.instance||(O.instance=new O),O.instance}getInitialState(){const e=w.getCurrentState();return{isOnline:e.online,isReliable:this.calculateReliability(e),quality:w.getNetworkQuality(),qualityScore:w.getNetworkQualityScore(),connectionType:e.connectionType,effectiveType:e.effectiveType,downlink:e.downlink,rtt:e.rtt,canSync:this.canPerformSync(e),syncStrategy:this.getDefaultStrategy(),estimatedSyncTime:this.estimateSyncTime(e),lastUpdated:new Date}}getDefaultStrategy(){return{batchSize:10,batchDelay:1e3,connectTimeout:5e3,requestTimeout:3e4,totalTimeout:12e4,maxRetries:3,retryDelay:1e3,retryBackoffMultiplier:2,compressionEnabled:!0,prioritySyncEnabled:!0,backgroundSyncEnabled:!0,circuitBreakerEnabled:!0,failureThreshold:5,recoveryTimeout:6e4}}initialize(){w.addEventListener(this.handleNetworkEvent.bind(this)),this.initializeCircuitBreakers(),this.initializeRequestQueues(),this.startPeriodicChecks(),console.log("NetworkStateDetector initialized")}initializeCircuitBreakers(){["read","write","delete","batch"].forEach(t=>{const i={failureThreshold:this.syncStrategy.failureThreshold,recoveryTimeout:this.syncStrategy.recoveryTimeout,expectedException:["timeout","connection_lost","network_slow"]};this.circuitBreakers.set(t,{status:{state:"closed",failureCount:0,config:i}})})}initializeRequestQueues(){["critical","high","normal","low","background"].forEach(t=>{this.pendingRequests.set(t,[])})}startPeriodicChecks(){setInterval(()=>{this.updateNetworkState()},3e4),setInterval(()=>{this.updateSyncStrategy()},3e5)}handleNetworkEvent(e){switch(console.log("Network event detected:",e.type),this.updateNetworkState(),e.type){case"online":this.handleNetworkRestored();break;case"offline":this.handleNetworkLost();break;case"quality-change":this.handleQualityChange(e);break;case"error":this.handleNetworkError(e);break}}async updateNetworkState(){try{const e=await w.checkNetwork(),t=await w.performHealthCheck(),i={isOnline:e.online&&t,isReliable:this.calculateReliability(e),quality:w.getNetworkQuality(),qualityScore:w.getNetworkQualityScore(),connectionType:e.connectionType,effectiveType:e.effectiveType,downlink:e.downlink,rtt:e.rtt,canSync:this.canPerformSync(e)&&t,syncStrategy:this.syncStrategy,estimatedSyncTime:this.estimateSyncTime(e),lastUpdated:new Date,lastStableTime:e.online?new Date:this.currentState.lastStableTime};this.hasSignificantChange(this.currentState,i)&&(this.currentState=i,this.notifyStateChanged(),i.isOnline&&i.isReliable&&this.processPendingRequests())}catch(e){console.error("Failed to update network state:",e)}}updateSyncStrategy(){const e=this.calculateOptimalStrategy();this.hasStrategyChanged(this.syncStrategy,e)&&(this.syncStrategy=e,this.currentState.syncStrategy=e,this.notifyStrategyChanged())}calculateOptimalStrategy(){const e=this.currentState.quality;this.currentState.qualityScore;const t={...this.getDefaultStrategy()};switch(e){case"excellent":return{...t,batchSize:50,batchDelay:500,requestTimeout:1e4,retryDelay:500,compressionEnabled:!1};case"good":return{...t,batchSize:25,batchDelay:1e3,requestTimeout:2e4,retryDelay:1e3};case"fair":return{...t,batchSize:10,batchDelay:2e3,requestTimeout:3e4,compressionEnabled:!0};case"poor":return{...t,batchSize:5,batchDelay:5e3,requestTimeout:6e4,maxRetries:5,retryDelay:2e3,compressionEnabled:!0};default:return{...t,batchSize:1,batchDelay:1e4,requestTimeout:12e4,maxRetries:10,compressionEnabled:!0}}}calculateReliability(e){if(!e.online)return!1;const t=this.calculateReliabilityFactors(e);return this.calculateOverallReliabilityScore(t)>=.6}calculateReliabilityFactors(e){const t=e.online?1:0;let i=1;e.rtt&&(e.rtt<=100?i=1:e.rtt<=300?i=.8:e.rtt<=1e3?i=.6:e.rtt<=2e3?i=.3:i=.1);let n=.5;e.downlink&&(e.downlink>=10?n=1:e.downlink>=5?n=.8:e.downlink>=1?n=.6:e.downlink>=.5?n=.4:n=.2);const s=this.calculateNetworkStability(),a={ethernet:1,wifi:.9,"5g":.8,"4g":.7,"3g":.4,"2g":.2,unknown:.3}[e.connectionType]||.3;return{connectivity:t,latency:i,bandwidth:n,stability:s,connectionType:a}}calculateOverallReliabilityScore(e){const t={connectivity:.3,latency:.25,bandwidth:.2,stability:.15,connectionType:.1};return e.connectivity*t.connectivity+e.latency*t.latency+e.bandwidth*t.bandwidth+e.stability*t.stability+e.connectionType*t.connectionType}calculateNetworkStability(){const e=Date.now(),t=5*60*1e3,i=this.networkHistory.filter(n=>e-n.timestamp.getTime()<t).length;return i===0?1:i<=2?.8:i<=5?.6:i<=10?.4:.2}canPerformSync(e){return e.online?w.getNetworkQualityScore()>=.3:!1}estimateSyncTime(e){if(!e.online)return 1/0;const t=1e3,i=e.rtt?Math.max(1,e.rtt/100):1,n=e.downlink?Math.max(.5,5/e.downlink):2;return t*i*n}predictNetworkStability(e=30){const t=Date.now(),i=e*60*1e3,n=this.networkHistory.filter(h=>t-h.timestamp.getTime()<=i);if(n.length<5)return{isStable:!0,confidence:.3,predictedDowntime:0,recommendations:["数据不足，建议监控网络状态"]};const r=1-n.filter(h=>!h.networkInfo.online).length/n.length,a=this.calculateOnlineDurations(n),o=a.reduce((h,g)=>h+g,0)/a.length||0,c=this.predictDowntime(n,i),u=this.generateNetworkRecommendations(r,o,c);return{isStable:r>=.8,confidence:Math.min(r,.9),predictedDowntime:c,recommendations:u}}calculateOnlineDurations(e){const t=[];let i=null;for(const n of e)n.networkInfo.online&&i===null?i=n.timestamp.getTime():!n.networkInfo.online&&i!==null&&(t.push(n.timestamp.getTime()-i),i=null);return i!==null&&t.push(Date.now()-i),t}predictDowntime(e,t){const i=e.filter(o=>!o.networkInfo.online);if(i.length===0)return 0;const n=[];let s=null;for(const o of e)!o.networkInfo.online&&s===null?s=o.timestamp.getTime():o.networkInfo.online&&s!==null&&(n.push(o.timestamp.getTime()-s),s=null);if(n.length===0)return 0;const r=n.reduce((o,c)=>o+c,0)/n.length,a=i.length/(t/(60*1e3));return r*a}generateNetworkRecommendations(e,t,i){const n=[];return e<.6&&(n.push("网络连接不稳定，建议切换到更稳定的网络"),n.push("建议启用离线模式")),t<5*60*1e3&&n.push("网络连接持续时间短，建议检查网络设备"),i>10*60*1e3&&n.push("预计网络中断时间较长，建议提前完成重要操作"),e>=.9&&t>30*60*1e3&&n.push("网络状态良好，适合进行大规模同步操作"),n}hasSignificantChange(e,t){return e.isOnline!==t.isOnline||e.isReliable!==t.isReliable||e.quality!==t.quality||Math.abs(e.qualityScore-t.qualityScore)>.1||e.canSync!==t.canSync}hasStrategyChanged(e,t){return e.batchSize!==t.batchSize||e.requestTimeout!==t.requestTimeout||e.compressionEnabled!==t.compressionEnabled||e.maxRetries!==t.maxRetries}handleNetworkRestored(){console.log("Network restored, processing pending requests..."),this.resetAllCircuitBreakers(),this.processPendingRequests()}handleNetworkLost(){console.log("Network lost, pausing sync operations..."),this.batchTimer&&(clearTimeout(this.batchTimer),this.batchTimer=null)}handleQualityChange(e){console.log("Network quality changed:",e.details),this.updateSyncStrategy()}handleNetworkError(e){const t={type:"network_slow",message:"Network quality degraded",timestamp:new Date,details:e.details};this.notifyError(t,"quality_degradation")}checkCircuitBreaker(e){const t=this.circuitBreakers.get(e);if(!t||!this.syncStrategy.circuitBreakerEnabled)return!0;const i=t.status;return i.state==="open"?Date.now()>=(i.nextAttemptTime?.getTime()||0)?(i.state="half_open",console.log(`Circuit breaker for ${e} moved to half-open state`),!0):!1:i.state!=="open"}recordSuccess(e){const t=this.circuitBreakers.get(e);if(!t)return;const i=t.status;i.failureCount=0,i.state="closed",t.timer&&(clearTimeout(t.timer),t.timer=void 0)}recordFailure(e,t){const i=this.circuitBreakers.get(e);if(!i||!this.syncStrategy.circuitBreakerEnabled)return;const n=i.status,s=n.config;s.expectedException&&!s.expectedException.includes(t.type)||(n.failureCount++,n.lastFailureTime=new Date,n.failureCount>=s.failureThreshold&&(n.state="open",n.nextAttemptTime=new Date(Date.now()+s.recoveryTimeout),this.stats.circuitBreakerTrips++,console.log(`Circuit breaker for ${e} tripped: ${n.failureCount} failures`),i.timer&&clearTimeout(i.timer),i.timer=setTimeout(()=>{n.state="half_open",console.log(`Circuit breaker for ${e} moved to half-open state`)},s.recoveryTimeout)))}resetCircuitBreaker(e){const t=this.circuitBreakers.get(e);if(!t)return;const i=t.status;i.failureCount=0,i.state="closed",i.lastFailureTime=void 0,i.nextAttemptTime=void 0,t.timer&&(clearTimeout(t.timer),t.timer=void 0)}resetAllCircuitBreakers(){this.circuitBreakers.forEach((e,t)=>{this.resetCircuitBreaker(t)})}async addSyncRequest(e){if(this.stats.totalRequests++,!this.currentState.canSync){const n={type:"connection_lost",message:"Network not available for sync",timestamp:new Date};return this.stats.failedRequests++,{success:!1,error:n,duration:0,retryCount:0,networkState:this.currentState}}const t=e.type==="batch"?"batch":e.type;if(!this.checkCircuitBreaker(t)){const n={type:"rate_limited",message:"Circuit breaker is open",timestamp:new Date};return this.stats.failedRequests++,{success:!1,error:n,duration:0,retryCount:0,networkState:this.currentState}}const i=this.pendingRequests.get(e.priority);return i.push(e),e.priority==="critical"||i.length>=this.syncStrategy.batchSize?await this.processPriorityQueue(e.priority):this.batchTimer||(this.batchTimer=setTimeout(()=>{this.processAllQueues()},this.syncStrategy.batchDelay)),{success:!0,duration:0,retryCount:0,networkState:this.currentState}}async processPriorityQueue(e){if(this.isProcessing)return;this.isProcessing=!0;const t=this.pendingRequests.get(e);if(t.length===0){this.isProcessing=!1;return}const i=Math.min(t.length,this.syncStrategy.batchSize),n=t.splice(0,i);try{await this.executeBatchRequests(n)}catch(s){console.error("Failed to process batch requests:",s)}finally{this.isProcessing=!1}}async processAllQueues(){if(this.isProcessing)return;this.isProcessing=!0,this.batchTimer=null;const e=["critical","high","normal","low","background"];try{for(const t of e)this.pendingRequests.get(t).length>0&&await this.processPriorityQueue(t)}catch(t){console.error("Failed to process request queues:",t)}finally{this.isProcessing=!1}}async processPendingRequests(){this.currentState.canSync&&!this.isProcessing&&await this.processAllQueues()}async executeBatchRequests(e){for(const t of e)try{const i=await this.executeRequest(t);this.notifySyncCompleted(t,i),i.success?(this.recordSuccess(t.type),this.stats.successfulRequests++):(this.recordFailure(t.type,i.error),this.stats.failedRequests++,this.stats.lastError=i.error)}catch(i){const n={type:"server_error",message:i instanceof Error?i.message:"Unknown error",timestamp:new Date};this.recordFailure(t.type,n),this.stats.failedRequests++,this.stats.lastError=n,this.notifySyncCompleted(t,{success:!1,error:n,duration:0,retryCount:0,networkState:this.currentState})}}async executeRequest(e){const t=Date.now();return await new Promise(i=>setTimeout(i,100)),{success:!0,data:{id:e.id,processed:!0},duration:Date.now()-t,retryCount:e.retryCount,networkState:this.currentState}}addListener(e){this.listeners.add(e)}removeListener(e){this.listeners.delete(e)}notifyStateChanged(){this.listeners.forEach(e=>{try{e.onNetworkStateChanged(this.currentState)}catch(t){console.error("Error in network state listener:",t)}})}notifyError(e,t){this.listeners.forEach(i=>{try{i.onNetworkError(e,t)}catch(n){console.error("Error in network error listener:",n)}})}notifySyncCompleted(e,t){this.listeners.forEach(i=>{try{i.onSyncCompleted(e,t)}catch(n){console.error("Error in sync completion listener:",n)}})}notifyStrategyChanged(){this.listeners.forEach(e=>{try{e.onSyncStrategyChanged(this.syncStrategy)}catch(t){console.error("Error in sync strategy listener:",t)}})}getCurrentState(){return{...this.currentState}}getSyncStrategy(){return{...this.syncStrategy}}getCircuitBreakerStatus(e){const t=this.circuitBreakers.get(e);return t?{...t.status}:null}getStats(){return{...this.stats}}async forceUpdateNetworkState(){await this.updateNetworkState()}reset(){this.resetAllCircuitBreakers(),this.pendingRequests.forEach(e=>e.length=0),this.batchTimer&&(clearTimeout(this.batchTimer),this.batchTimer=null),this.stats={totalRequests:0,successfulRequests:0,failedRequests:0,averageResponseTime:0,lastError:null,circuitBreakerTrips:0}}}const m=O.getInstance();class ${syncQueue=[];syncInProgress=!1;lastSyncTime=null;conflicts=[];listeners=[];authService=null;networkInitialized=!1;constructor(){this.initialize()}initialize(){this.initializeNetworkIntegration(),this.startAdaptiveSync()}initializeNetworkIntegration(){this.networkInitialized||(m.addListener({onNetworkStateChanged:this.handleNetworkStateChange.bind(this),onNetworkError:this.handleNetworkError.bind(this),onSyncCompleted:this.handleSyncCompleted.bind(this),onSyncStrategyChanged:this.handleSyncStrategyChanged.bind(this)}),this.networkInitialized=!0,console.log("Cloud sync service integrated with network state detector"))}handleNetworkStateChange(e){console.log("Network state changed:",e.isOnline,e.quality),e.isOnline&&e.isReliable&&e.canSync&&this.processSyncQueue(),this.notifyStatusChange()}handleNetworkError(e,t){console.warn("Network error in sync service:",e.message,t),(e.type==="connection_lost"||e.type==="network_slow")&&this.pauseSyncQueue()}handleSyncCompleted(e,t){t.success&&(this.lastSyncTime=new Date),this.notifyStatusChange()}handleSyncStrategyChanged(e){console.log("Sync strategy changed:",e),e.backgroundSyncEnabled&&this.startAdaptiveSync()}startAdaptiveSync(){this.syncInterval&&clearInterval(this.syncInterval),m.getSyncStrategy();const e=m.getCurrentState();let t=5*60*1e3;e.quality==="excellent"?t=1*60*1e3:e.quality==="good"?t=2*60*1e3:e.quality==="fair"?t=5*60*1e3:e.quality==="poor"&&(t=10*60*1e3),this.syncInterval=setInterval(()=>{m.getCurrentState().canSync&&this.authService?.isAuthenticated()&&this.processSyncQueue()},t),console.log(`Adaptive sync started with interval: ${t/1e3}s`)}syncInterval=null;setAuthService(e){this.authService=e,e.onAuthStateChange(t=>{t.user&&m.getCurrentState().canSync&&this.performFullSync()})}onStatusChange(e){return this.listeners.push(e),e(this.getCurrentStatus()),()=>{const t=this.listeners.indexOf(e);t>-1&&this.listeners.splice(t,1)}}notifyStatusChange(){const e=this.getCurrentStatus();this.listeners.forEach(t=>t(e))}getCurrentStatus(){return{isOnline:m.getCurrentState().isOnline,lastSyncTime:this.lastSyncTime,pendingOperations:this.syncQueue.length,syncInProgress:this.syncInProgress,hasConflicts:this.conflicts.length>0}}async queueOperation(e){const t={...e,id:crypto.randomUUID(),timestamp:new Date,retryCount:0};this.syncQueue.push(t),await this.persistSyncQueue(),this.isOnline&&this.authService?.isAuthenticated()&&this.processSyncQueue(),this.notifyStatusChange()}async processSyncQueue(){if(!(this.syncInProgress||!this.isOnline||!this.authService?.isAuthenticated())){this.syncInProgress=!0,this.notifyStatusChange();try{const e=[...this.syncQueue];for(const t of e)try{await this.executeOperation(t);const i=this.syncQueue.findIndex(n=>n.id===t.id);i>-1&&this.syncQueue.splice(i,1)}catch(i){if(console.error("Sync operation failed:",i),t.retryCount++,t.retryCount>3){const n=this.syncQueue.findIndex(s=>s.id===t.id);n>-1&&this.syncQueue.splice(n,1)}}await this.persistSyncQueue(),this.lastSyncTime=new Date}finally{this.syncInProgress=!1,this.notifyStatusChange()}}}async executeOperation(e){const t=this.authService?.getCurrentUser();if(!t)throw new Error("User not authenticated");switch(e.table){case"cards":await this.syncCard(e,t.id);break;case"folders":await this.syncFolder(e,t.id);break;case"tags":await this.syncTag(e,t.id);break;case"images":await this.syncImage(e,t.id);break}}async syncCard(e,t){const{type:i,data:n,localId:s}=e;switch(i){case"create":case"update":const{error:r}=await f.from("cards").upsert({id:s,user_id:t,front_content:n.frontContent,back_content:n.backContent,style:n.style,folder_id:n.folderId,updated_at:new Date().toISOString(),sync_version:n.syncVersion+1});if(r)throw r;break;case"delete":const{error:a}=await f.from("cards").update({is_deleted:!0,updated_at:new Date().toISOString()}).eq("id",s).eq("user_id",t);if(a)throw a;break}}async syncFolder(e,t){const{type:i,data:n,localId:s}=e;switch(i){case"create":case"update":const{error:r}=await f.from("folders").upsert({id:s,user_id:t,name:n.name,parent_id:n.parentId,updated_at:new Date().toISOString(),sync_version:n.syncVersion+1});if(r)throw r;break;case"delete":const{error:a}=await f.from("folders").update({is_deleted:!0,updated_at:new Date().toISOString()}).eq("id",s).eq("user_id",t);if(a)throw a;break}}async syncTag(e,t){const{type:i,data:n,localId:s}=e;switch(i){case"create":case"update":const{error:r}=await f.from("tags").upsert({id:s,user_id:t,name:n.name,color:n.color,updated_at:new Date().toISOString(),sync_version:n.syncVersion+1});if(r)throw r;break;case"delete":const{error:a}=await f.from("tags").update({is_deleted:!0,updated_at:new Date().toISOString()}).eq("id",s).eq("user_id",t);if(a)throw a;break}}async syncImage(e,t){const{type:i,data:n,localId:s}=e;switch(i){case"create":case"update":const{error:r}=await f.from("images").upsert({id:s,user_id:t,card_id:n.cardId,file_name:n.fileName,file_path:n.filePath,cloud_url:n.cloudUrl,metadata:n.metadata,updated_at:new Date().toISOString(),sync_version:n.syncVersion+1});if(r)throw r;break;case"delete":const{error:a}=await f.from("images").update({is_deleted:!0,updated_at:new Date().toISOString()}).eq("id",s).eq("user_id",t);if(a)throw a;break}}async performFullSync(){if(!(!this.authService?.isAuthenticated()||!this.isOnline))try{this.syncInProgress=!0,this.notifyStatusChange();const e=this.authService.getCurrentUser();await this.syncFromCloud(e.id),await this.processSyncQueue(),this.lastSyncTime=new Date,console.log("Full sync completed successfully")}catch(e){console.error("Full sync failed:",e)}finally{this.syncInProgress=!1,this.notifyStatusChange()}}async syncFromCloud(e){const t=this.lastSyncTime||new Date(0),{data:i}=await f.from("cards").select("*").eq("user_id",e).gte("updated_at",t.toISOString());if(i)for(const r of i)await this.mergeCloudCard(r);const{data:n}=await f.from("folders").select("*").eq("user_id",e).gte("updated_at",t.toISOString());if(n)for(const r of n)await this.mergeCloudFolder(r);const{data:s}=await f.from("tags").select("*").eq("user_id",e).gte("updated_at",t.toISOString());if(s)for(const r of s)await this.mergeCloudTag(r)}async mergeCloudCard(e){const t=await d.cards?.get(e.id);if(!t)await d.cards?.add({id:e.id,frontContent:e.front_content,backContent:e.back_content,style:e.style,folderId:e.folder_id||void 0,isFlipped:!1,createdAt:new Date(e.created_at),updatedAt:new Date(e.updated_at),syncVersion:e.sync_version,pendingSync:!1});else{const i=new Date(t.updatedAt).getTime(),n=new Date(e.updated_at).getTime();n>i?await d.cards?.update(e.id,{frontContent:e.front_content,backContent:e.back_content,style:e.style,folderId:e.folder_id||void 0,updatedAt:new Date(e.updated_at),syncVersion:e.sync_version,pendingSync:!1}):i>n&&t.pendingSync&&await this.queueOperation({type:"update",table:"cards",data:t,localId:t.id})}}async mergeCloudFolder(e){const t=await d.folders?.get(e.id);if(!t)await d.folders?.add({id:e.id,name:e.name,color:"#3b82f6",icon:"Folder",cardIds:[],parentId:e.parent_id||void 0,isExpanded:!0,createdAt:new Date(e.created_at),updatedAt:new Date(e.updated_at),syncVersion:e.sync_version,pendingSync:!1});else{const i=new Date(t.updatedAt).getTime(),n=new Date(e.updated_at).getTime();n>i?await d.folders?.update(e.id,{name:e.name,parentId:e.parent_id||void 0,updatedAt:new Date(e.updated_at),syncVersion:e.sync_version,pendingSync:!1}):i>n&&t.pendingSync&&await this.queueOperation({type:"update",table:"folders",data:t,localId:t.id})}}async mergeCloudTag(e){const t=await d.tags?.get(e.id);if(!t)await d.tags?.add({id:e.id,name:e.name,color:e.color,count:0,createdAt:new Date(e.created_at),updatedAt:new Date(e.updated_at),syncVersion:e.sync_version,pendingSync:!1});else{const i=new Date(t.updatedAt).getTime(),n=new Date(e.updatedAt).getTime();n>i?await d.tags?.update(e.id,{name:e.name,color:e.color,updatedAt:new Date(e.updated_at),syncVersion:e.sync_version,pendingSync:!1}):i>n&&t.pendingSync&&await this.queueOperation({type:"update",table:"tags",data:t,localId:t.id})}}async persistSyncQueue(){try{localStorage.setItem("cardall_sync_queue",JSON.stringify(this.syncQueue))}catch(e){console.error("Failed to persist sync queue:",e)}}async restoreSyncQueue(){try{const e=localStorage.getItem("cardall_sync_queue");e&&(this.syncQueue=JSON.parse(e),this.notifyStatusChange())}catch(e){console.error("Failed to restore sync queue:",e)}}async clearSyncQueue(){this.syncQueue=[],await this.persistSyncQueue(),this.notifyStatusChange()}getConflicts(){return[...this.conflicts]}async resolveConflict(e,t){const i=this.conflicts.find(s=>s.id===e);if(!i)return;switch(t){case"local":await this.queueOperation({type:"update",table:i.table,data:i.localData,localId:i.localData.id});break}const n=this.conflicts.findIndex(s=>s.id===e);n>-1&&(this.conflicts.splice(n,1),this.notifyStatusChange())}}const re=new $;class H extends D{cards;folders;tags;images;syncQueue;settings;sessions;offlineSnapshots;offlineBackups;constructor(){super("CardAllUnifiedDatabase"),this.version(4).stores({cards:"++id, userId, folderId, createdAt, updatedAt, syncVersion, pendingSync, [userId+folderId], searchVector",folders:"++id, userId, parentId, createdAt, updatedAt, syncVersion, pendingSync, [userId+parentId], fullPath, depth",tags:"++id, userId, name, createdAt, syncVersion, pendingSync, [userId+name]",images:"++id, cardId, userId, createdAt, updatedAt, syncVersion, pendingSync, storageMode, [cardId+userId]",syncQueue:"++id, type, entity, entityId, userId, timestamp, retryCount, priority, [userId+priority]",settings:"++id, key, updatedAt, scope, [key+scope]",sessions:"++id, userId, deviceId, lastActivity, isActive, [userId+deviceId]",offlineSnapshots:"++id, timestamp, userId, version, dataHash, dataSize, [userId+timestamp]",offlineBackups:"++id, snapshotId, createdAt, compression, encrypted, size, [snapshotId+createdAt]"}),this.upgradeDatabase()}async upgradeDatabase(){this.version(2).upgrade(async e=>{console.log("Upgrading to version 2: Adding user support...");const t=new V;try{await t.open(),console.log("Found old database, migrating data...");const n=(await t.cards.toArray()).map(c=>({...c,userId:"default",updatedAt:new Date}));await this.cards.bulkAdd(n);const r=(await t.folders.toArray()).map(c=>({...c,userId:"default",updatedAt:new Date}));await this.folders.bulkAdd(r);const o=(await t.tags.toArray()).map(c=>({...c,userId:"default",updatedAt:new Date}));await this.tags.bulkAdd(o),console.log("Migration completed successfully")}catch(i){console.log("No old database found or migration failed:",i)}}),this.version(3).upgrade(async e=>{console.log("Upgrading to version 3: Optimizing indexes and adding new features..."),await this.initializeDefaultSettings(),await this.rebuildSearchIndexes()}),this.version(4).upgrade(async e=>{console.log("Upgrading to version 4: Adding offline data persistence features..."),await this.initializeOfflinePersistence(),await this.createInitialOfflineSnapshot()})}async initializeDefaultSettings(){const e=[{key:"storageMode",value:"hybrid",scope:"global",updatedAt:new Date},{key:"syncEnabled",value:!0,scope:"global",updatedAt:new Date},{key:"imageCompression",value:{enabled:!0,quality:.8,maxWidth:1920,maxHeight:1080,format:"webp"},scope:"global",updatedAt:new Date},{key:"databaseVersion",value:"3.0.0",scope:"global",updatedAt:new Date}];for(const t of e)await this.settings.where("key").equals(t.key).first()||await this.settings.add(t)}async rebuildSearchIndexes(){console.log("Rebuilding search indexes...")}async initializeOfflinePersistence(){console.log("Initializing offline persistence...");const e=[{key:"offlineAutoBackup",value:{enabled:!0,interval:30*60*1e3,maxBackups:10,compression:!0},scope:"global",updatedAt:new Date},{key:"offlineCompression",value:{enabled:!0,algorithm:"lz-string",threshold:1024,quality:.8},scope:"global",updatedAt:new Date},{key:"offlineDataRetention",value:{days:30,maxSize:100},scope:"global",updatedAt:new Date}];for(const t of e)await this.settings.where("key").equals(t.key).first()||await this.settings.add(t)}async createInitialOfflineSnapshot(){try{const e=await this.createOfflineSnapshot({includeCards:!0,includeFolders:!0,includeTags:!0,includeSettings:!0,includeImages:!1});console.log("Initial offline snapshot created:",e.id)}catch(e){console.error("Failed to create initial offline snapshot:",e)}}async createOfflineSnapshot(e={}){const{includeCards:t=!0,includeFolders:i=!0,includeTags:n=!0,includeImages:s=!1,includeSettings:r=!0,userId:a}=e,o=crypto.randomUUID(),c=new Date,u={};let h=0;t&&(u.cards=await this.cards.toArray(),h+=JSON.stringify(u.cards).length),i&&(u.folders=await this.folders.toArray(),h+=JSON.stringify(u.folders).length),n&&(u.tags=await this.tags.toArray(),h+=JSON.stringify(u.tags).length),s&&(u.images=await this.images.toArray(),h+=JSON.stringify(u.images).length),r&&(u.settings=await this.settings.toArray(),h+=JSON.stringify(u.settings).length);const g=await this.calculateDataHash(u),y=await this.getDeviceInfo(),S=await this.getStorageQuota(),T={id:o,timestamp:c,version:"4.0.0",userId:a,dataHash:g,dataSize:h,compressedSize:h,includes:{cards:t,folders:i,tags:n,images:s,settings:r},metadata:{deviceInfo:y,networkStatus:navigator.onLine?"online":"offline",batteryLevel:(navigator.getBattery?.(),void 0),storageQuota:S}};return await this.offlineSnapshots.add(T),T}async calculateDataHash(e){const t=JSON.stringify(e),n=new TextEncoder().encode(t),s=await crypto.subtle.digest("SHA-256",n);return Array.from(new Uint8Array(s)).map(a=>a.toString(16).padStart(2,"0")).join("")}async getDeviceInfo(){const e={userAgent:navigator.userAgent,platform:navigator.platform,language:navigator.language,deviceMemory:navigator.deviceMemory,hardwareConcurrency:navigator.hardwareConcurrency,screenResolution:`${screen.width}x${screen.height}`,timestamp:new Date().toISOString()};return JSON.stringify(e)}async getStorageQuota(){try{if("storage"in navigator&&"estimate"in navigator.storage){const e=await navigator.storage.estimate();return{used:e.usage||0,total:e.quota||0}}}catch(e){console.warn("Failed to get storage quota:",e)}return{used:0,total:0}}async restoreOfflineSnapshot(e){try{const t=await this.offlineSnapshots.get(e);if(!t)throw new Error("Snapshot not found");if(await this.getCurrentDataHash()===t.dataHash)return console.log("Data already matches snapshot, no restore needed"),!0;if(t.includes.cards){const n=await this.cards.toArray();await this.cards.clear()}if(t.includes.folders){const n=await this.folders.toArray();await this.folders.clear()}if(t.includes.tags){const n=await this.tags.toArray();await this.tags.clear()}if(t.includes.settings){const n=await this.settings.toArray();await this.settings.clear()}return console.log("Offline snapshot restored successfully:",e),!0}catch(t){return console.error("Failed to restore offline snapshot:",t),!1}}async getCurrentDataHash(){const e={cards:await this.cards.toArray(),folders:await this.folders.toArray(),tags:await this.tags.toArray(),settings:await this.settings.toArray()};return await this.calculateDataHash(e)}async cleanupOfflineData(){const e=new Date;let t=0,i=0,n=0;try{const s=await this.getSetting("offlineDataRetention"),r=s?.days||30,a=s?.maxSize||100,o=new Date(e.getTime()-r*24*60*60*1e3),c=await this.offlineSnapshots.where("timestamp").below(o).toArray();for(const y of c)n+=y.dataSize,await this.offlineSnapshots.delete(y.id),t++;const u=await this.offlineBackups.where("createdAt").below(o).toArray();for(const y of u)n+=y.size,await this.offlineBackups.delete(y.id),i++;const h=await this.offlineSnapshots.orderBy("timestamp").reverse().toArray();let g=h.reduce((y,S)=>y+S.dataSize,0);for(;g>a*1024*1024&&h.length>5;){const y=h.pop();y&&(n+=y.dataSize,await this.offlineSnapshots.delete(y.id),t++,g-=y.dataSize)}return console.log(`Offline data cleanup completed: ${t} snapshots, ${i} backups, ${n} bytes freed`),{cleanedSnapshots:t,cleanedBackups:i,freedSpace:n}}catch(s){return console.error("Failed to cleanup offline data:",s),{cleanedSnapshots:0,cleanedBackups:0,freedSpace:0}}}async autoBackupOfflineData(){try{const e=await this.getSetting("offlineAutoBackup");if(!e?.enabled)return!1;const t=await this.offlineSnapshots.orderBy("timestamp").reverse().first();if(t&&new Date().getTime()-t.timestamp.getTime()<e.interval)return!1;const n=await this.createOfflineSnapshot({includeCards:!0,includeFolders:!0,includeTags:!0,includeImages:!1,includeSettings:!0}),s=e.maxBackups||10,r=await this.offlineSnapshots.orderBy("timestamp").reverse().toArray();if(r.length>s){const a=r.slice(s);for(const o of a)await this.offlineSnapshots.delete(o.id)}return console.log("Auto backup completed:",n.id),!0}catch(e){return console.error("Auto backup failed:",e),!1}}async getOfflineDataStats(){const e=await this.offlineSnapshots.toArray(),t=await this.offlineBackups.toArray(),i=e.reduce((r,a)=>r+a.dataSize,0)+t.reduce((r,a)=>r+a.size,0),n=e.length>0?e.reduce((r,a)=>a.timestamp>r.timestamp?a:r,e[0]).timestamp:void 0,s=e.length>0?e.reduce((r,a)=>a.timestamp<r.timestamp?a:r,e[0]).timestamp:void 0;return{snapshots:e.length,backups:t.length,totalSize:i,lastBackup:n,oldestBackup:s}}async getSetting(e,t){if(t){const n=await this.settings.where("[key+scope]").equals([e,"user"]).first();if(n)return n.value}return(await this.settings.where("[key+scope]").equals([e,"global"]).first())?.value}async updateSetting(e,t,i="global",n){const s={value:t,updatedAt:new Date};n&&(s.userId=n),await this.settings.where("[key+scope]").equals([e,i]).modify(s)}async getStats(){const[e,t,i,n,s]=await Promise.all([this.cards.count(),this.folders.count(),this.tags.count(),this.images.count(),this.syncQueue.count()]),r=await this.calculateTotalSize();return{cards:e,folders:t,tags:i,images:n,pendingSync:s,totalSize:r,version:"3.0.0"}}async calculateTotalSize(){return(await this.images.toArray()).reduce((t,i)=>t+i.metadata.size,0)}async createCard(e,t){const i=crypto.randomUUID(),n=new Date;return await this.cards.add({...e,id:i,userId:t,syncVersion:1,pendingSync:!0,updatedAt:n}),i}async updateCard(e,t){return await this.cards.update(e,{...t,syncVersion:t.syncVersion?t.syncVersion+1:void 0,pendingSync:!0,updatedAt:new Date})}async deleteCard(e){await this.transaction("rw",[this.cards,this.images],async()=>{await this.images.where("cardId").equals(e).delete(),await this.cards.delete(e)})}async bulkCreateCards(e,t){const i=new Date,n=e.map(s=>({...s,id:crypto.randomUUID(),userId:t,syncVersion:1,pendingSync:!0,updatedAt:i}));return await this.cards.bulkAdd(n),n.map(s=>s.id)}async getCardsByFolder(e,t){return await this.cards.where("[userId+folderId]").equals([t||"default",e]).toArray()}async searchCards(e,t){const i=e.toLowerCase();return await this.cards.filter(n=>n.searchVector?.includes(i)||n.frontContent.title.toLowerCase().includes(i)||n.frontContent.text.toLowerCase().includes(i)||n.backContent.title.toLowerCase().includes(i)||n.backContent.text.toLowerCase().includes(i)).toArray()}async cleanup(){await this.transaction("rw",[this.cards,this.folders,this.tags,this.images,this.syncQueue],async()=>{const e=new Date(Date.now()-6048e5);await this.syncQueue.where("timestamp").below(e).delete();const t=await this.cards.toCollection().primaryKeys();await this.images.where("cardId").noneOf(t).delete(),console.log("Database cleanup completed")})}async healthCheck(){const e=[];try{await this.cards.count();const t=await this.getStats();return t.pendingSync>1e3&&e.push(`High number of pending sync operations: ${t.pendingSync}`),t.totalSize>500*1024*1024&&e.push(`Database size is large: ${(t.totalSize/1024/1024).toFixed(2)} MB`),{isHealthy:e.length===0,issues:e,stats:t}}catch(t){return{isHealthy:!1,issues:[`Database connection failed: ${t}`],stats:{cards:0,folders:0,tags:0,images:0,pendingSync:0,totalSize:0,version:"3.0.0"}}}}async clearAll(){await this.transaction("rw",[this.cards,this.folders,this.tags,this.images,this.syncQueue,this.settings,this.sessions],async()=>{await this.cards.clear(),await this.folders.clear(),await this.tags.clear(),await this.images.clear(),await this.syncQueue.clear(),await this.sessions.clear()})}async getSettingLegacy(e){return await this.getSetting(e)}async updateSettingLegacy(e,t){await this.updateSetting(e,t)}async clearAllLegacy(){await this.transaction("rw",[this.cards,this.folders,this.tags,this.images,this.syncQueue],async()=>{await this.cards.clear(),await this.folders.clear(),await this.tags.clear(),await this.images.clear(),await this.syncQueue.clear()})}async getStatsLegacy(){const e=await this.getStats();return{cards:e.cards,folders:e.folders,tags:e.tags,images:e.images,pendingSync:e.pendingSync}}}class V extends D{cards;folders;tags;images;syncQueue;settings;constructor(){super("CardAllDatabase"),this.version(1).stores({cards:"++id, folderId, createdAt, updatedAt, syncVersion, pendingSync",folders:"++id, parentId, createdAt, updatedAt, syncVersion, pendingSync",tags:"++id, name, createdAt, syncVersion, pendingSync",images:"++id, cardId, filePath, createdAt, syncVersion, pendingSync",syncQueue:"++id, type, entity, entityId, timestamp, retryCount",settings:"++id, key, updatedAt"})}}const l=new H;l.on("versionchange",p=>{console.warn("Database version changed:",p)});l.on("blocked",()=>{console.warn("Database operation blocked")});l.on("versionchange",()=>{console.warn("Database version changed, reloading page..."),window.location.reload()});l.on("ready",()=>{console.log("Database is ready")});const R=new Map,E=5*60*1e3;setInterval(()=>{const p=Date.now();R.forEach((e,t)=>{p-e.timestamp>E&&R.delete(t)})},E);class J{detectionRules=new Map;resolutionStrategies=new Map;mergeStrategies=new Map;conflictPatterns=new Map;conflictHistory=[];resolutionStats=new Map;conflictPredictionModel;constructor(){this.initializeDetectionRules(),this.initializeResolutionStrategies(),this.initializeMergeStrategies(),this.initializeConflictPatterns(),this.initializeMLModel()}async detectAllConflicts(e,t,i,n,s){const r=[];for(const o of this.detectionRules.values())if(o.enabled&&!(o.entityType!=="all"&&o.entityType!==i))try{const c=await o.detectionFunction(e,t,s);r.push(...c)}catch(c){console.error(`Conflict detection rule ${o.id} failed:`,c)}const a=this.optimizeConflicts(r);return this.recordConflictDetection(a,s),a}async resolveConflicts(e,t){const i=[];for(const n of e)try{const s=await this.resolveSingleConflict(n,t);i.push(s)}catch(s){console.error(`Failed to resolve conflict ${n.id}:`,s),n.resolution="manual",n.autoResolved=!1,i.push(n)}return i}async resolveSingleConflict(e,t){const i=await this.predictResolutionStrategy(e,t),n=this.resolutionStrategies.get(i)||this.selectFallbackStrategy(e),s=await this.applyResolutionStrategy(e,n,t);return this.recordResolutionResult(e,n,s.success),s.conflict}initializeDetectionRules(){this.detectionRules.set("version-conflict",{id:"version-conflict",name:"Version Conflict Detection",description:"检测基于版本号的冲突",entityType:"all",priority:100,enabled:!0,detectionFunction:(e,t,i)=>this.detectVersionConflicts(e,t,i)}),this.detectionRules.set("field-conflict",{id:"field-conflict",name:"Field-Level Conflict Detection",description:"检测字段级别的冲突",entityType:"all",priority:90,enabled:!0,detectionFunction:(e,t,i)=>this.detectFieldConflicts(e,t,i)}),this.detectionRules.set("structure-conflict",{id:"structure-conflict",name:"Structure Conflict Detection",description:"检测数据结构冲突",entityType:"all",priority:80,enabled:!0,detectionFunction:(e,t,i)=>this.detectStructureConflicts(e,t,i)}),this.detectionRules.set("reference-conflict",{id:"reference-conflict",name:"Reference Integrity Conflict Detection",description:"检测引用完整性冲突",entityType:"all",priority:70,enabled:!0,detectionFunction:(e,t,i)=>this.detectReferenceConflicts(e,t,i)}),this.detectionRules.set("business-logic-conflict",{id:"business-logic-conflict",name:"Business Logic Conflict Detection",description:"检测业务逻辑冲突",entityType:"all",priority:60,enabled:!0,detectionFunction:(e,t,i)=>this.detectBusinessLogicConflicts(e,t,i)})}detectVersionConflicts(e,t,i){const n=[],s=e.sync_version||e.localVersion||0,r=t.sync_version||t.cloudVersion||0;return s!==r&&n.push({id:crypto.randomUUID(),entityType:this.inferEntityType(e),entityId:e.id||t.id,conflictType:"version",localData:e,cloudData:t,detectedAt:new Date}),n}detectFieldConflicts(e,t,i){const n=[],s=[],r=this.getComparableFields(e,t);for(const a of r){const o=this.getNestedValue(e,a),c=this.getNestedValue(t,a);this.valuesEqual(o,c)||s.push(a)}return s.length>0&&n.push({id:crypto.randomUUID(),entityType:this.inferEntityType(e),entityId:e.id||t.id,conflictType:"field",localData:e,cloudData:t,conflictFields:s,detectedAt:new Date}),n}detectStructureConflicts(e,t,i){const n=[],s=new Set(Object.keys(e)),r=new Set(Object.keys(t)),a=[...r].filter(c=>!s.has(c)),o=[...s].filter(c=>!r.has(c));return(a.length>0||o.length>0)&&n.push({id:crypto.randomUUID(),entityType:this.inferEntityType(e),entityId:e.id||t.id,conflictType:"structure",localData:e,cloudData:t,conflictFields:[...a,...o],detectedAt:new Date}),n}detectReferenceConflicts(e,t,i){const n=[];if((e.folderId!==void 0||t.folderId!==void 0)&&e.folderId!==t.folderId&&n.push({id:crypto.randomUUID(),entityType:"card",entityId:e.id||t.id,conflictType:"field",localData:e,cloudData:t,conflictFields:["folderId"],detectedAt:new Date}),e.tags!==void 0||t.tags!==void 0){const s=new Set(e.tags||[]),r=new Set(t.tags||[]);this.setsEqual(s,r)||n.push({id:crypto.randomUUID(),entityType:this.inferEntityType(e),entityId:e.id||t.id,conflictType:"field",localData:e,cloudData:t,conflictFields:["tags"],detectedAt:new Date})}return n}detectBusinessLogicConflicts(e,t,i){const n=[];if(e.frontContent||t.frontContent){const s=this.detectContentConflicts(e,t);s&&n.push(s)}if(e.style||t.style){const s=this.detectStyleConflicts(e,t);s&&n.push(s)}return n}initializeMergeStrategies(){this.mergeStrategies.set("smart-text-merge",{id:"smart-text-merge",name:"Smart Text Merge",description:"智能合并文本内容，保留两边的修改",applicableTypes:["card"],mergeFunction:(e,t,i)=>this.smartTextMerge(e,t),confidence:.8}),this.mergeStrategies.set("timestamp-priority",{id:"timestamp-priority",name:"Timestamp Priority",description:"使用最新的时间戳决定优先级",applicableTypes:["all"],mergeFunction:(e,t,i)=>this.timestampPriorityMerge(e,t),confidence:.9}),this.mergeStrategies.set("field-smart-merge",{id:"field-smart-merge",name:"Field Smart Merge",description:"按字段类型智能选择最佳合并策略",applicableTypes:["all"],mergeFunction:(e,t,i)=>this.fieldSmartMerge(e,t),confidence:.85}),this.mergeStrategies.set("user-preference-merge",{id:"user-preference-merge",name:"User Preference Merge",description:"基于用户历史偏好进行合并",applicableTypes:["all"],mergeFunction:(e,t,i)=>this.userPreferenceMerge(e,t,i),confidence:.75}),this.mergeStrategies.set("ml-merge",{id:"ml-merge",name:"Machine Learning Merge",description:"使用机器学习模型预测最佳合并策略",applicableTypes:["all"],mergeFunction:(e,t,i)=>this.mlMerge(e,t,i),confidence:.7})}smartTextMerge(e,t){const i={...e};return e.frontContent&&t.frontContent&&(i.frontContent=this.mergeContent(e.frontContent,t.frontContent)),e.backContent&&t.backContent&&(i.backContent=this.mergeContent(e.backContent,t.backContent)),i}timestampPriorityMerge(e,t){const i=new Date(e.updatedAt||e.timestamp).getTime();return new Date(t.updatedAt||t.timestamp).getTime()>i?{...t}:{...e}}fieldSmartMerge(e,t){const i={...e};return Object.keys(t).forEach(n=>{e[n]===void 0?i[n]=t[n]:this.valuesEqual(e[n],t[n])||(i[n]=this.mergeFieldByType(n,e[n],t[n]))}),i}userPreferenceMerge(e,t,i){switch(this.analyzeUserPreference(i.userId)){case"local-first":return{...e};case"cloud-first":return{...t};case"smart-merge":return this.fieldSmartMerge(e,t);default:return this.timestampPriorityMerge(e,t)}}mlMerge(e,t,i){const n=this.extractFeatures(e,t,i);switch(this.predictMergeStrategy(n).strategy){case"local":return{...e};case"cloud":return{...t};case"merge":return this.fieldSmartMerge(e,t);default:return this.timestampPriorityMerge(e,t)}}initializeMLModel(){this.conflictPredictionModel={patterns:new Map,confidenceThreshold:.7},this.conflictPredictionModel.patterns.set("version-conflict-local",.8),this.conflictPredictionModel.patterns.set("field-conflict-merge",.6),this.conflictPredictionModel.patterns.set("structure-conflict-manual",.9)}async predictResolutionStrategy(e,t){const i=this.extractConflictFeatures(e,t),n=this.findSimilarConflicts(i);return n.length>0?this.getMostSuccessfulStrategy(n):this.heuristicStrategySelection(e,t)}extractConflictFeatures(e,t){return{conflictType:e.conflictType,entityType:e.entityType,fieldCount:e.conflictFields?.length||0,timeOfDay:t.timestamp.getHours(),dayOfWeek:t.timestamp.getDay(),networkQuality:t.networkInfo.effectiveType,deviceType:t.deviceInfo.deviceType,userHistoryLength:t.syncHistory.length,isWeekend:t.timestamp.getDay()===0||t.timestamp.getDay()===6}}findSimilarConflicts(e){const t=[];for(const i of this.conflictHistory)this.calculateSimilarity(e,i)>.7&&t.push(i);return t}calculateSimilarity(e,t){let i=0;e.conflictType===t.conflictType&&(i+=.3),e.entityType===t.entityType&&(i+=.2);const n=Math.abs(e.fieldCount-(t.conflictFields?.length||0));return i+=Math.max(0,.2-n*.05),i}getComparableFields(e,t){const i=new Set;return i.add("id"),i.add("sync_version"),i.add("updatedAt"),i.add("createdAt"),(e.frontContent||t.frontContent)&&(i.add("frontContent.title"),i.add("frontContent.text"),i.add("frontContent.tags")),(e.backContent||t.backContent)&&(i.add("backContent.title"),i.add("backContent.text"),i.add("backContent.tags")),(e.style||t.style)&&(i.add("style.type"),i.add("style.backgroundColor"),i.add("style.textColor")),(e.folderId!==void 0||t.folderId!==void 0)&&i.add("folderId"),Array.from(i)}getNestedValue(e,t){return t.split(".").reduce((i,n)=>i?.[n],e)}valuesEqual(e,t){return e===t?!0:e==null||t==null||typeof e!=typeof t?!1:typeof e=="object"?JSON.stringify(e)===JSON.stringify(t):!1}setsEqual(e,t){if(e.size!==t.size)return!1;for(const i of e)if(!t.has(i))return!1;return!0}inferEntityType(e){return e.frontContent||e.backContent?"card":e.name&&e.color?"tag":e.name&&e.cardIds?"folder":e.fileName&&e.filePath?"image":"unknown"}mergeContent(e,t){const i={...e};if(e.title!==t.title&&(i.title=this.mergeTextFields(e.title,t.title)),e.text!==t.text&&(i.text=this.mergeTextFields(e.text,t.text)),e.tags||t.tags){const n=new Set(e.tags||[]),s=new Set(t.tags||[]);i.tags=Array.from(new Set([...n,...s]))}return i}mergeTextFields(e,t){return e.length>t.length?e:t}mergeFieldByType(e,t,i){if(e.includes("time")||e.includes("date")){const n=new Date(t).getTime();return new Date(i).getTime()>n?i:t}return e.includes("version")?Math.max(t,i):typeof t=="string"&&typeof i=="string"?this.mergeTextFields(t,i):t}analyzeUserPreference(e){const t=this.resolutionStats.get(e);return!t||t.success>t.failure*2?"smart-merge":"timestamp-priority"}optimizeConflicts(e){const t=new Map;for(const i of e){const n=`${i.entityType}-${i.entityId}-${i.conflictType}`;(!t.has(n)||(t.get(n).priority||0)<(i.priority||0))&&t.set(n,i)}return Array.from(t.values())}recordConflictDetection(e,t){this.conflictHistory.push(...e),this.conflictHistory.length>1e3&&(this.conflictHistory=this.conflictHistory.slice(-500))}recordResolutionResult(e,t,i){const n=`${e.entityType}-${t}`,s=this.resolutionStats.get(n)||{success:0,failure:0};i?s.success++:s.failure++,this.resolutionStats.set(n,s)}detectContentConflicts(e,t){return null}detectStyleConflicts(e,t){return null}selectFallbackStrategy(e){return{type:"manual",priority:0,conditions:{},resolution:"manual"}}async applyResolutionStrategy(e,t,i){return{conflict:e,success:!0}}getMostSuccessfulStrategy(e){return"timestamp-priority"}heuristicStrategySelection(e,t){return"timestamp-priority"}extractFeatures(e,t,i){return{}}predictMergeStrategy(e){return{strategy:"merge",confidence:.7}}}const P=new J;class j{isProcessing=!1;processingInterval;retryDelays=[1e3,2e3,5e3,1e4,3e4];batchSize=10;maxConcurrentBatches=3;currentBatches=0;listeners={};constructor(){this.initializeQueue(),this.startQueueProcessor()}async enqueueOperation(e){const t={...e,id:crypto.randomUUID(),status:"pending",timestamp:new Date};try{return e.dependencies&&e.dependencies.length>0&&await this.validateDependencies(e.dependencies),await l.syncQueue.add({id:t.id,type:e.type,entity:e.entity,entityId:e.entityId,userId:e.userId,data:e.data,priority:e.priority,timestamp:t.timestamp,retryCount:e.retryCount,maxRetries:e.maxRetries,error:e.error}),this.notifyStatusChange(),e.priority==="high"&&!this.isProcessing&&this.processNextBatch(),t.id}catch(i){throw console.error("Failed to enqueue operation:",i),i}}async enqueueBatch(e){const t=e.map(i=>({...i,id:crypto.randomUUID(),status:"pending",timestamp:new Date}));try{const i=t.filter(s=>s.dependencies&&s.dependencies.length>0).flatMap(s=>s.dependencies);i.length>0&&await this.validateDependencies(i);const n=t.map(s=>({id:s.id,type:s.type,entity:s.entity,entityId:s.entityId,userId:s.userId,data:s.data,priority:s.priority,timestamp:s.timestamp,retryCount:s.retryCount,maxRetries:s.maxRetries,error:s.error}));return await l.syncQueue.bulkAdd(n),this.notifyStatusChange(),t.map(s=>s.id)}catch(i){throw console.error("Failed to enqueue batch operations:",i),i}}async dequeueOperation(e){try{const t=await l.syncQueue.where("id").equals(e).delete();return this.notifyStatusChange(),t>0}catch(t){return console.error("Failed to dequeue operation:",t),!1}}async updateOperationStatus(e,t,i){try{await l.syncQueue.where("id").equals(e).modify({status:t,error:i,...t==="processing"?{retryCount:Dexie.currentTransaction?.table("syncQueue").get(e).then(s=>(s?.retryCount||0)+1)}:{}}),this.notifyStatusChange();const n=await l.syncQueue.get(e);n&&this.listeners.onOperationComplete&&this.listeners.onOperationComplete(this.convertSyncOperationToQueueOperation(n),t==="completed")}catch(n){console.error("Failed to update operation status:",n)}}async processNextBatch(){if(!(this.isProcessing||this.currentBatches>=this.maxConcurrentBatches)){this.isProcessing=!0,this.currentBatches++;try{const e=await this.getNextBatch();if(e.length===0){this.isProcessing=!1,this.currentBatches--;return}const t=e.map(n=>n.id);await this.markOperationsProcessing(t);const i=await this.processBatch(e);this.listeners.onBatchComplete&&this.listeners.onBatchComplete(i)}catch(e){console.error("Error processing batch:",e),this.listeners.onQueueError&&this.listeners.onQueueError(e instanceof Error?e:new Error(String(e)))}finally{this.isProcessing=!1,this.currentBatches--,setTimeout(()=>this.processNextBatch(),100)}}}async getNextBatch(){try{return await l.syncQueue.where("status").equals("pending").orderBy("priority").reverse().offset(0).limit(this.batchSize).toArray()}catch(e){return console.error("Failed to get next batch:",e),[]}}async markOperationsProcessing(e){await l.syncQueue.where("id").anyOf(e).modify({status:"processing"})}async processBatch(e){const t=crypto.randomUUID(),i=performance.now(),n=[],s=[],r=[];try{for(const o of e)try{await this.executeSyncOperation(o)?(n.push(o.id),await this.updateOperationStatus(o.id,"completed")):(s.push(o.id),r.push(`Sync failed for operation ${o.id}`),await this.handleOperationFailure(o,"Sync execution failed"))}catch(c){s.push(o.id);const u=c instanceof Error?c.message:String(c);r.push(u),await this.handleOperationFailure(o,u)}const a=performance.now()-i;return{batchId:t,operations:e.length,successful:n.length,failed:s.length,errors:r,executionTime:a,timestamp:new Date}}catch(a){const o=performance.now()-i,c=a instanceof Error?a.message:String(a);for(const u of e)await this.handleOperationFailure(u,c);return{batchId:t,operations:e.length,successful:0,failed:e.length,errors:[c],executionTime:o,timestamp:new Date}}}async executeSyncOperation(e){try{const t=await this.analyzeOperationConflicts(e);return t.highRisk>0?(console.warn(`High conflict risk detected for operation ${e.id}, applying conflict resolution`),await this.executeWithConflictResolution(e,t)):await this.performSyncOperation(e)}catch(t){return console.error(`Sync operation failed for ${e.id}:`,t),!1}}async analyzeOperationConflicts(e){try{const t=await l.syncQueue.where("entityId").equals(e.entityId).filter(u=>Math.abs(u.timestamp.getTime()-e.timestamp.getTime())<3e5&&u.id!==e.id).toArray();let i=0,n=0,s=0;const r=[];t.length>2&&(i++,r.push("Multiple concurrent operations on same entity")),(await l.syncQueue.where("userId").equals(e.userId).filter(u=>Date.now()-u.timestamp.getTime()<60*1e3).toArray()).length>10&&(i++,r.push("User operating too frequently"));const c=(await l.syncQueue.where("entity").equals(e.entity).filter(u=>u.status==="failed").toArray()).length/Math.max(1,await l.syncQueue.count());return c>.3&&(n++,r.push(`High failure rate (${(c*100).toFixed(1)}%) for entity type`)),e.type==="delete"&&(n++,r.push("Delete operations require extra caution")),{highRisk:i,mediumRisk:n,lowRisk:s,recommendations:r}}catch(t){return console.error("Failed to analyze operation conflicts:",t),{highRisk:0,mediumRisk:1,lowRisk:0,recommendations:["Unable to analyze conflicts"]}}}async executeWithConflictResolution(e,t){try{const i={userId:e.userId||"",timestamp:new Date,networkInfo:{effectiveType:"4g"},deviceInfo:{deviceType:"unknown"},userPreferences:{},syncHistory:[]},n=await this.fetchCloudData(e),s=await this.fetchLocalData(e),r=await P.detectAllConflicts(s,n,e.entity,e.entityId,i);if(r.length>0){console.log(`Detected ${r.length} conflicts for operation ${e.id}`);const a=await P.resolveConflicts(r,i),o=a.filter(u=>u.resolution==="manual");if(o.length>0)return console.warn(`Unable to auto-resolve ${o.length} conflicts for operation ${e.id}`),!1;const c=this.extractResolvedData(a,s,n);return await this.performSyncOperation({...e,data:c})}return await this.performSyncOperation(e)}catch(i){return console.error(`Conflict resolution failed for operation ${e.id}:`,i),!1}}async performSyncOperation(e){switch(await new Promise(t=>setTimeout(t,Math.random()*200+100)),e.type){case"create":return await this.performCreateOperation(e);case"update":return await this.performUpdateOperation(e);case"delete":return await this.performDeleteOperation(e);default:return console.warn(`Unknown operation type: ${e.type}`),!1}}async fetchCloudData(e){return{id:e.entityId,updatedAt:new Date().toISOString(),version:Math.floor(Math.random()*100)}}async fetchLocalData(e){return{id:e.entityId,updatedAt:new Date().toISOString(),version:Math.floor(Math.random()*100),...e.data}}extractResolvedData(e,t,i){return{...t,resolvedAt:new Date().toISOString(),conflictCount:e.length}}async performCreateOperation(e){const t=e.priority==="high"?.95:.85;return Math.random()<t}async performUpdateOperation(e){const t=e.priority==="high"?.9:.8;return Math.random()<t}async performDeleteOperation(e){const t=e.priority==="high"?.85:.75;return Math.random()<t}async handleOperationFailure(e,t){const i=e.retryCount+1;if(i>=e.maxRetries)await this.updateOperationStatus(e.id,"failed",t);else{const n=this.retryDelays[Math.min(i-1,this.retryDelays.length-1)];await l.syncQueue.where("id").equals(e.id).modify({retryCount:i,status:"retrying",error:t}),setTimeout(async()=>{await l.syncQueue.where("id").equals(e.id).modify({status:"pending"}),this.notifyStatusChange()},n)}}async validateDependencies(e){const t=await l.syncQueue.where("id").anyOf(e).and(i=>i.status==="pending"||i.status==="processing").count();if(t>0)throw new Error(`Cannot enqueue operation: ${t} dependencies are still pending`)}async canExecuteOperation(e){return!e.dependencies||e.dependencies.length===0?!0:(await l.syncQueue.where("id").anyOf(e.dependencies).toArray()).every(i=>i.status==="completed")}async getQueueStats(){const e=await l.syncQueue.toArray(),t={totalOperations:e.length,byStatus:{pending:0,processing:0,completed:0,failed:0,retrying:0},byPriority:{high:0,normal:0,low:0},byEntity:{card:0,folder:0,tag:0,image:0},averageWaitTime:0};e.forEach(s=>{t.byStatus[s.status]++,t.byPriority[s.priority]++,t.byEntity[s.entity]++});const i=e.filter(s=>s.status==="pending"||s.status==="retrying");if(i.length>0){const s=Date.now(),r=i.reduce((a,o)=>a+(s-new Date(o.timestamp).getTime()),0);t.averageWaitTime=r/i.length}const n=e.filter(s=>s.status==="pending").sort((s,r)=>new Date(s.timestamp).getTime()-new Date(r.timestamp).getTime())[0];return n&&(t.oldestOperation=new Date(n.timestamp)),t}async cleanupCompletedOperations(e=24*60*60*1e3){const t=new Date(Date.now()-e),i=await l.syncQueue.where("status").equals("completed").and(n=>new Date(n.timestamp)<t).delete();return this.notifyStatusChange(),i}async retryFailedOperations(){const e=await l.syncQueue.where("status").equals("failed").modify({status:"pending",retryCount:0,error:void 0});return this.notifyStatusChange(),e>0&&this.processNextBatch(),e}async getOperations(e){let t=l.syncQueue.toCollection();return e?.status&&(t=t.where("status").equals(e.status)),e?.priority&&(t=t.where("priority").equals(e.priority)),e?.entity&&(t=t.where("entity").equals(e.entity)),e?.userId&&(t=t.where("userId").equals(e.userId)),e?.offset&&(t=t.offset(e.offset)),e?.limit&&(t=t.limit(e.limit)),(await t.toArray()).map(n=>this.convertSyncOperationToQueueOperation(n))}setEventListeners(e){this.listeners={...this.listeners,...e}}notifyStatusChange(){this.listeners.onStatusChange&&this.getQueueStats().then(e=>{this.listeners.onStatusChange(e)}).catch(console.error)}initializeQueue(){this.checkRetryOperations()}startQueueProcessor(){this.processingInterval=setInterval(()=>{this.isProcessing||this.processNextBatch()},5e3),setInterval(()=>{this.optimizeQueueProcessing().catch(console.error)},12e4),window.addEventListener("online",()=>{this.isProcessing||this.processNextBatch()})}async checkRetryOperations(){try{const e=await l.syncQueue.where("status").equals("retrying").toArray();for(const t of e)await l.syncQueue.where("id").equals(t.id).modify({status:"pending"});e.length>0&&(this.notifyStatusChange(),this.processNextBatch())}catch(e){console.error("Failed to check retry operations:",e)}}stop(){this.processingInterval&&(clearInterval(this.processingInterval),this.processingInterval=void 0)}pause(){this.isProcessing=!0}resume(){this.isProcessing=!1,this.processNextBatch()}convertSyncOperationToQueueOperation(e){return{id:e.id,type:e.type,entity:e.entity,entityId:e.entityId,userId:e.userId,data:e.data,priority:e.priority,timestamp:new Date(e.timestamp),retryCount:e.retryCount,maxRetries:e.maxRetries,status:e.status,error:e.error}}async optimizeQueueProcessing(){try{const e=await this.getQueueStats();this.adjustProcessingStrategy(e),this.adjustBatchSize(e),await this.rebalancePriorities(e),await this.cleanupExpiredOperations()}catch(e){console.error("Failed to optimize queue processing:",e)}}adjustProcessingStrategy(e){const{totalOperations:t,byStatus:i,byPriority:n}=e;t>1e3?(this.batchSize=5,this.maxConcurrentBatches=2,console.log("Queue under high load, adjusting strategy: batch=5, concurrent=2")):t>500?(this.batchSize=8,this.maxConcurrentBatches=3,console.log("Queue under medium load, adjusting strategy: batch=8, concurrent=3")):(this.batchSize=15,this.maxConcurrentBatches=5,console.log("Queue under normal load, adjusting strategy: batch=15, concurrent=5"));const s=i.failed/t;s>.3?(this.retryDelays=[2e3,5e3,15e3,3e4,6e4],console.log("High failure rate detected, increased retry delays")):s<.1&&(this.retryDelays=[1e3,2e3,5e3,1e4,3e4],console.log("Normal failure rate, restored retry delays"))}adjustBatchSize(e){const{byPriority:t,totalOperations:i}=e,n=t.high/i;n>.3&&(this.batchSize=Math.max(3,Math.floor(this.batchSize*.7)),console.log(`High priority ratio (${(n*100).toFixed(1)}%), reduced batch size to ${this.batchSize}`));const s=byEntity.card/i;s>.7&&(this.batchSize=Math.min(20,Math.floor(this.batchSize*1.2)),console.log(`Card operation ratio (${(s*100).toFixed(1)}%), increased batch size to ${this.batchSize}`))}async rebalancePriorities(e){const{byStatus:t,byPriority:i}=e,n=await l.syncQueue.where("priority").equals("high").filter(r=>Date.now()-r.timestamp.getTime()>5*60*1e3).toArray();n.length>0&&(await l.syncQueue.where("id").anyOf(n.map(r=>r.id)).modify({priority:"high"}),console.log(`Escalated ${n.length} old high-priority operations`));const s=await l.syncQueue.where("priority").equals("normal").filter(r=>Date.now()-r.timestamp.getTime()>10*60*1e3).toArray();s.length>0&&(await l.syncQueue.where("id").anyOf(s.map(r=>r.id)).modify({priority:"high"}),console.log(`Escalated ${s.length} old normal-priority operations`))}async cleanupExpiredOperations(){const e=Date.now()-864e5,t=await l.syncQueue.where("timestamp").below(e).filter(i=>i.status==="failed").toArray();if(t.length>0){for(const i of t)await l.syncQueue.delete(i.id);console.log(`Cleaned up ${t.length} expired failed operations`)}}async predictAndPreventConflicts(e){const t=[],i=[],n={highRisk:0,mediumRisk:0,lowRisk:0};for(const s of e){const r=await this.assessConflictRisk(s);r==="high"?(i.push(s),n.highRisk++):r==="medium"?(i.push(s),n.mediumRisk++):(t.push(s),n.lowRisk++)}return{safeOperations:t,riskyOperations:i,conflictPrediction:n}}async assessConflictRisk(e){try{return(await l.syncQueue.where("entityId").equals(e.entityId).filter(r=>Math.abs(r.timestamp.getTime()-e.timestamp.getTime())<3e5&&r.id!==e.id).toArray()).length>2||(await l.syncQueue.where("userId").equals(e.userId).filter(r=>Date.now()-r.timestamp.getTime()<60*1e3).toArray()).length>10?"high":(await l.syncQueue.where("entity").equals(e.entity).filter(r=>r.status==="failed").toArray()).length/Math.max(1,await l.syncQueue.count())>.3?"medium":"low"}catch(t){return console.error("Failed to assess conflict risk:",t),"medium"}}async getQueuePerformanceMetrics(){try{const e=await this.getQueueStats(),t=await l.syncQueue.where("status").equals("completed").filter(y=>Date.now()-y.timestamp.getTime()<60*1e3).toArray(),i=t.length,n=await Promise.all(t.map(async y=>(await l.syncQueue.get(y.id))?.processingTime||0)),s=n.length>0?n.reduce((y,S)=>y+S,0)/n.length:0,r=await l.syncQueue.filter(y=>Date.now()-y.timestamp.getTime()<60*1e3).toArray(),a=r.length>0?t.length/r.length:1,o=this.calculateQueueEfficiency(e,i),c=await this.calculateConflictResolutionRate(),u=this.calculateResourceUtilization(e,i),h=this.analyzeBottlenecks(e,i,s),g=await this.generatePredictiveInsights(e,i);return{throughput:i,averageProcessingTime:s,successRate:a,queueEfficiency:o,bottleneckAnalysis:h,conflictResolutionRate:c,resourceUtilization:u,predictiveInsights:g}}catch(e){return console.error("Failed to get queue performance metrics:",e),{throughput:0,averageProcessingTime:0,successRate:0,queueEfficiency:0,bottleneckAnalysis:["Unable to analyze performance"],conflictResolutionRate:0,resourceUtilization:0,predictiveInsights:{predictedLoad:0,recommendedActions:["Enable performance monitoring"],riskAssessment:"medium"}}}}async calculateConflictResolutionRate(){try{const e=await l.syncQueue.filter(i=>Date.now()-i.timestamp.getTime()<18e5).toArray();return e.length===0?1:e.filter(i=>i.status==="completed"&&i.error===null).length/e.length}catch(e){return console.error("Failed to calculate conflict resolution rate:",e),0}}calculateResourceUtilization(e,t){let i=.3;return e.totalOperations>500?i+=.4:e.totalOperations>200?i+=.2:e.totalOperations>50&&(i+=.1),t>15?i+=.2:t>8&&(i+=.1),e.byStatus.failed/Math.max(1,e.totalOperations)>.2&&(i-=.1),Math.max(0,Math.min(1,i))}async generatePredictiveInsights(e,t){const i=[];let n="low";const s=await this.predictFutureLoad(e,t);return s>1e3?(i.push("Consider increasing batch size and concurrency"),n="high"):s>500&&(i.push("Monitor queue growth closely"),i.push("Consider enabling aggressive cleanup"),n="medium"),t<5&&(i.push("Investigate low throughput causes"),i.push("Check network connectivity")),e.byStatus.failed/Math.max(1,e.totalOperations)>.15&&(i.push("Review and optimize conflict resolution strategies"),i.push("Consider reducing retry delays for failed operations")),e.oldestOperation&&Date.now()-e.oldestOperation.getTime()>30*60*1e3&&(i.push("Process aged operations urgently"),i.push("Consider priority escalation")),{predictedLoad:s,recommendedActions:i,riskAssessment:n}}async predictFutureLoad(e,t){try{const i=new Date(Date.now()-36e5),n=await l.syncQueue.where("timestamp").above(i).toArray();if(n.length===0)return t*2;const s=this.calculateGrowthRate(n),r=e.totalOperations*(1+s);return Math.max(t*2,r)}catch(i){return console.error("Failed to predict future load:",i),t*2}}calculateGrowthRate(e){if(e.length<2)return .1;const t=new Map;e.forEach(o=>{const c=Math.floor(o.timestamp.getTime()/6e5);t.set(c,(t.get(c)||0)+1)});const i=Array.from(t.keys()).sort();if(i.length<2)return .1;const n=i.slice(0,Math.floor(i.length/2)),s=i.slice(Math.floor(i.length/2)),r=n.reduce((o,c)=>o+(t.get(c)||0),0)/n.length,a=s.reduce((o,c)=>o+(t.get(c)||0),0)/s.length;return r===0?.1:Math.max(-.5,Math.min(2,(a-r)/r))}calculateQueueEfficiency(e,t){const{totalOperations:i,byStatus:n}=e;let s=.5;i<100?s+=.3:i<500?s+=.2:i<1e3&&(s+=.1);const r=n.failed/Math.max(1,i);return s-=r*.5,t>20?s+=.2:t>10&&(s+=.1),Math.max(0,Math.min(1,s))}analyzeBottlenecks(e,t,i){const n=[];return e.totalOperations>1e3&&n.push("Queue backlog too large"),t<5&&n.push("Low throughput detected"),i>5e3&&n.push("High processing time"),e.byStatus.failed/Math.max(1,e.totalOperations)>.2&&n.push("High failure rate"),n.length===0&&n.push("No significant bottlenecks detected"),n}}const C=new j;class W{static cachedUserId=null;static getCurrentUserId(){if(!this.cachedUserId){const e=F.getCurrentUser();this.cachedUserId=e?.id||null}return this.cachedUserId}static clearUserIdCache(){this.cachedUserId=null}static toDbCard(e,t){const i=new Date,n=t||this.getCurrentUserId();return{id:e.id||crypto.randomUUID(),folderId:e.folderId,frontContent:e.frontContent||{title:"",text:"",tags:[],images:[],lastModified:i},backContent:e.backContent||{title:"",text:"",tags:[],images:[],lastModified:i},isFlipped:e.isFlipped||!1,style:e.style||{type:"solid",backgroundColor:"#ffffff",textColor:"#000000"},userId:n,syncVersion:e.syncVersion||1,lastSyncAt:e.lastSyncAt,pendingSync:e.pendingSync??!0,updatedAt:e.updatedAt||i,searchVector:this.generateSearchVector(e),thumbnailUrl:e.thumbnailUrl}}static fromDbCard(e){const{userId:t,syncVersion:i,lastSyncAt:n,pendingSync:s,searchVector:r,thumbnailUrl:a,...o}=e;return{...o,id:o.id||"",createdAt:new Date(o.createdAt),updatedAt:new Date(o.updatedAt),frontContent:{...o.frontContent,lastModified:new Date(o.frontContent.lastModified)},backContent:{...o.backContent,lastModified:new Date(o.backContent.lastModified)}}}static fromDbCards(e){return e.map(t=>this.fromDbCard(t))}static toDbFolder(e,t){const i=new Date,n=t||this.getCurrentUserId();return{id:e.id||crypto.randomUUID(),name:e.name||"",parentId:e.parentId,description:e.description||"",color:e.color||"#6366f1",icon:e.icon||"folder",order:e.order||0,isExpanded:e.isExpanded??!0,createdAt:e.createdAt||i,userId:n,syncVersion:e.syncVersion||1,lastSyncAt:e.lastSyncAt,pendingSync:e.pendingSync??!0,updatedAt:e.updatedAt||i,fullPath:this.generateFullPath(e),depth:this.calculateFolderDepth(e)}}static fromDbFolder(e){const{userId:t,syncVersion:i,lastSyncAt:n,pendingSync:s,fullPath:r,depth:a,...o}=e;return{...o,id:o.id||"",createdAt:new Date(o.createdAt),updatedAt:new Date(o.updatedAt)}}static toDbTag(e,t){const i=new Date,n=t||this.getCurrentUserId();return{id:e.id||crypto.randomUUID(),name:e.name||"",color:e.color||"#6366f1",description:e.description||"",count:e.count||0,createdAt:e.createdAt||i,userId:n,syncVersion:e.syncVersion||1,lastSyncAt:e.lastSyncAt,pendingSync:e.pendingSync??!0,updatedAt:e.updatedAt||i}}static fromDbTag(e){const{userId:t,syncVersion:i,lastSyncAt:n,pendingSync:s,count:r,...a}=e;return{...a,id:a.id||"",createdAt:new Date(a.createdAt),updatedAt:new Date(a.updatedAt)}}static toDbImage(e,t,i){const n=new Date,s=i||this.getCurrentUserId();return{id:e.id||crypto.randomUUID(),cardId:t,userId:s,fileName:e.fileName||"",filePath:e.url||"",cloudUrl:e.cloudUrl,thumbnailPath:e.thumbnailUrl,metadata:{originalName:e.fileName||e.alt||"",size:e.size||0,width:e.width||0,height:e.height||0,format:e.format||"jpg",compressed:e.compressed??!1,quality:e.quality},storageMode:e.storageMode||"indexeddb",createdAt:e.createdAt||n,updatedAt:e.updatedAt||n,syncVersion:e.syncVersion||1,lastSyncAt:e.lastSyncAt,pendingSync:e.pendingSync??!0}}static fromDbImage(e){const{userId:t,syncVersion:i,lastSyncAt:n,pendingSync:s,fileName:r,filePath:a,thumbnailPath:o,storageMode:c,metadata:u,...h}=e;return{...h,id:h.id||"",url:a,thumbnailUrl:o,alt:u.originalName,width:u.width,height:u.height,aspectRatio:u.width>0&&u.height>0?u.width/u.height:1,size:u.size,format:u.format,compressed:u.compressed,quality:u.quality,storageMode:c,createdAt:new Date(h.createdAt),updatedAt:new Date(h.updatedAt)}}static fromLegacySyncOperation(e){return{id:e.id,type:e.type,entity:e.table.replace("s",""),entityId:e.localId,data:e.data,timestamp:e.timestamp,retryCount:e.retryCount,maxRetries:e.maxRetries,error:e.error,priority:"normal"}}static toLegacySyncOperation(e){return{id:e.id,type:e.type,table:e.entity+"s",data:e.data,localId:e.entityId,timestamp:e.timestamp,retryCount:e.retryCount,maxRetries:e.maxRetries,error:e.error}}static generateSearchVector(e){return[e.frontContent?.title||"",e.frontContent?.text||"",e.backContent?.title||"",e.backContent?.text||"",...e.frontContent?.tags||[],...e.backContent?.tags||[]].join(" ").toLowerCase().replace(/[^\w\s\u4e00-\u9fff]/g," ").replace(/\s+/g," ").trim()}static generateFullPath(e){return e.name||""}static calculateFolderDepth(e){return e.parentId?1:0}static fromCloudCard(e){return{id:e.id,folderId:e.folder_id,frontContent:{title:e.front_content?.title||"",text:e.front_content?.text||"",tags:e.front_content?.tags||[],images:e.front_content?.images||[],lastModified:new Date(e.updated_at)},backContent:{title:e.back_content?.title||"",text:e.back_content?.text||"",tags:e.back_content?.tags||[],images:e.back_content?.images||[],lastModified:new Date(e.updated_at)},isFlipped:!1,style:e.style||{type:"solid",backgroundColor:"#ffffff",textColor:"#000000"},userId:e.user_id,syncVersion:e.sync_version||1,lastSyncAt:new Date(e.updated_at),pendingSync:!1,createdAt:new Date(e.created_at),updatedAt:new Date(e.updated_at),searchVector:this.generateSearchVectorFromCloud(e),thumbnailUrl:e.thumbnail_url}}static fromCloudFolder(e){return{id:e.id,name:e.name,parentId:e.parent_id,description:e.description||"",color:e.color||"#6366f1",icon:e.icon||"folder",order:e.order||0,isExpanded:!0,cardIds:e.card_ids||[],userId:e.user_id,syncVersion:e.sync_version||1,lastSyncAt:new Date(e.updated_at),pendingSync:!1,createdAt:new Date(e.created_at),updatedAt:new Date(e.updated_at),fullPath:e.full_path||e.name,depth:e.depth||0}}static fromCloudTag(e){return{id:e.id,name:e.name,color:e.color||"#6366f1",description:e.description||"",count:e.count||0,userId:e.user_id,syncVersion:e.sync_version||1,lastSyncAt:new Date(e.updated_at),pendingSync:!1,createdAt:new Date(e.created_at),updatedAt:new Date(e.updated_at)}}static toCloudCard(e){return{id:e.id,folder_id:e.folderId,front_content:{title:e.frontContent.title,text:e.frontContent.text,tags:e.frontContent.tags,images:e.frontContent.images},back_content:{title:e.backContent.title,text:e.backContent.text,tags:e.backContent.tags,images:e.backContent.images},style:e.style,user_id:e.userId,sync_version:e.syncVersion,updated_at:e.updatedAt.toISOString(),created_at:e.createdAt.toISOString(),thumbnail_url:e.thumbnailUrl}}static toCloudFolder(e){return{id:e.id,name:e.name,parent_id:e.parentId,description:e.description,color:e.color,icon:e.icon,order:e.order,card_ids:e.cardIds,user_id:e.userId,sync_version:e.syncVersion,updated_at:e.updatedAt.toISOString(),created_at:e.createdAt.toISOString(),full_path:e.fullPath,depth:e.depth}}static toCloudTag(e){return{id:e.id,name:e.name,color:e.color,description:e.description,count:e.count,user_id:e.userId,sync_version:e.syncVersion,updated_at:e.updatedAt.toISOString(),created_at:e.createdAt.toISOString()}}static generateSearchVectorFromCloud(e){return[e.front_content?.title||"",e.front_content?.text||"",e.back_content?.title||"",e.back_content?.text||"",...e.front_content?.tags||[],...e.back_content?.tags||[]].join(" ").toLowerCase().replace(/[^\w\s\u4e00-\u9fff]/g," ").replace(/\s+/g," ").trim()}static validateCardData(e){const t=[];e.frontContent?.title?.trim()||t.push("卡片正面标题不能为空"),e.backContent?.title?.trim()||t.push("卡片背面标题不能为空"),e.style&&!["solid","gradient","glass"].includes(e.style.type)&&t.push("无效的卡片样式类型");const i=n=>{n.forEach((s,r)=>{s.url||t.push(`第${r+1}张图片URL不能为空`),(s.width<=0||s.height<=0)&&t.push(`第${r+1}张图片尺寸无效`)})};return e.frontContent?.images&&i(e.frontContent.images),e.backContent?.images&&i(e.backContent.images),{isValid:t.length===0,errors:t}}static validateFolderData(e){const t=[];return e.name?.trim()||t.push("文件夹名称不能为空"),e.name&&e.name.length>50&&t.push("文件夹名称不能超过50个字符"),e.color&&!/^#[0-9A-Fa-f]{6}$/.test(e.color)&&t.push("文件夹颜色格式无效"),{isValid:t.length===0,errors:t}}static validateTagData(e){const t=[];return e.name?.trim()||t.push("标签名称不能为空"),e.name&&e.name.length>30&&t.push("标签名称不能超过30个字符"),e.color&&!/^#[0-9A-Fa-f]{6}$/.test(e.color)&&t.push("标签颜色格式无效"),{isValid:t.length===0,errors:t}}static batchToDbCards(e,t){return e.map(i=>this.toDbCard(i,t))}static batchToDbFolders(e,t){return e.map(i=>this.toDbFolder(i,t))}static batchToDbTags(e,t){return e.map(i=>this.toDbTag(i,t))}static sanitizeCardData(e){const t={...e};return t.frontContent&&(t.frontContent={...t.frontContent,title:(t.frontContent.title||"").trim(),text:(t.frontContent.text||"").trim(),tags:(t.frontContent.tags||[]).map(i=>i.trim()).filter(Boolean)}),t.backContent&&(t.backContent={...t.backContent,title:(t.backContent.title||"").trim(),text:(t.backContent.text||"").trim(),tags:(t.backContent.tags||[]).map(i=>i.trim()).filter(Boolean)}),t.style&&(t.style={...t.style,backgroundColor:t.style.backgroundColor||"#ffffff",textColor:t.style.textColor||"#000000"}),t}static optimizeImageData(e){return{...e,format:e.format||"jpg",compressed:e.compressed??!0,quality:Math.min(Math.max(e.quality||.8,.1),1)}}static conversionCache=new Map;static CACHE_TTL=5*60*1e3;static cachedConvert(e,t,i){const n=`${e}:${JSON.stringify(t)}`,s=this.conversionCache.get(n);if(s&&Date.now()-s.timestamp<this.CACHE_TTL)return s.data;const r=i(t);return this.conversionCache.set(n,{data:r,timestamp:Date.now()}),r}static clearConversionCache(){this.conversionCache.clear()}static startCacheCleanup(){setInterval(()=>{const e=Date.now();for(const[t,i]of this.conversionCache.entries())e-i.timestamp>this.CACHE_TTL&&this.conversionCache.delete(t)},this.CACHE_TTL)}}const k=new W,K={maxRetries:5,initialRetryDelay:1e3,maxRetryDelay:3e5,retryBackoffMultiplier:2,batchSize:10,batchTimeout:5e3,maxConcurrentBatches:3,processingTimeout:3e4,idleCheckInterval:1e4,cleanupInterval:3e5,networkAware:!0,offlineMode:!0,requireWifiForLargeFiles:!0,maxQueueSize:1e4,maxAge:7*24*60*60*1e3};class G{config;isProcessing=!1;processingTimer=null;cleanupTimer=null;currentBatches=new Map;listeners={};constructor(e={}){this.config={...K,...e},this.initialize()}async initialize(){try{await d.open(),await this.restoreQueueFromStorage(),this.startProcessing(),this.startCleanup(),console.log("LocalOperationService initialized successfully")}catch(e){console.error("Failed to initialize LocalOperationService:",e)}}async restoreQueueFromStorage(){try{const e=localStorage.getItem("syncQueue");if(e){const t=JSON.parse(e);for(const i of t){const n=this.convertOperationFormat(i);try{await d.syncQueue.add(n)}catch{console.warn("Operation already exists in database, skipping:",i.id)}}localStorage.removeItem("syncQueue"),console.log(`Restored ${t.length} operations from local storage`)}}catch(e){console.error("Failed to restore queue from storage:",e)}}convertOperationFormat(e){return e.entityType&&e.operationType&&e.entityId?e:{id:e.id,entityType:e.table==="cards"?"card":e.table==="folders"?"folder":e.table==="tags"?"tag":"image",operationType:e.type,entityId:e.localId,data:e.data,timestamp:e.timestamp,retryCount:e.retryCount||0,status:e.status||"pending",localVersion:e.localVersion||1,priority:e.priority||"normal",dependsOn:e.dependsOn||[]}}async addOperation(e){if(!e.entityId||e.entityId.trim()==="")throw new Error("Local ID is required");if(!e.entityType||!["card","folder","tag","image"].includes(e.entityType))throw new Error("Invalid entity type");if(!e.operationType||!["create","update","delete"].includes(e.operationType))throw new Error("Invalid operation type");if(!e.data)throw new Error("Operation data is required");const t=crypto.randomUUID(),i=new Date,n={...e,id:t,timestamp:i,retryCount:0,status:"pending",localVersion:Date.now(),retryDelay:this.config.initialRetryDelay,maxRetries:this.config.maxRetries};this.config.networkAware&&(n.networkInfo=await this.getNetworkInfo());const s=await d.syncQueue.where("entityId").equals(e.entityId).and(r=>r.entityType===e.entityType&&r.status==="pending").first();try{return s?(await d.syncQueue.update(s.id,{data:e.data,previousData:e.previousData,timestamp:i,localVersion:Date.now()}),console.log(`Operation updated in queue: ${s.id}`),s.id):(await d.syncQueue.add(n),this.notifyListeners("operationAdded",n),await this.updateQueueStats(),console.log(`Operation added to queue: ${t}`),t)}catch(r){throw console.error("Failed to add operation to queue:",r),r}}async getPendingOperations(e=this.config.batchSize,t){try{let i=d.syncQueue.where("status").equals("pending").orderBy("priority").reverse();t&&t.length>0&&(i=i.filter(r=>t.includes(r.priority)));const n=await i.limit(e).toArray();return await this.filterReadyOperations(n)}catch(i){return console.error("Failed to get pending operations:",i),[]}}async markOperationProcessing(e){try{await d.syncQueue.update(e,{status:"processing",processingStartedAt:new Date})}catch(t){console.error(`Failed to mark operation ${e} as processing:`,t)}}async markOperationCompleted(e){try{const t=await d.syncQueue.get(e);if(!t)return;await d.syncQueue.update(e,{status:"completed",processingEndedAt:new Date}),this.notifyListeners("operationCompleted",t),await this.updateQueueStats()}catch(t){console.error(`Failed to mark operation ${e} as completed:`,t)}}async markOperationFailed(e,t){try{const i=await d.syncQueue.get(e);if(!i)return;const n=i.retryCount+1,s=Math.min(i.retryDelay*this.config.retryBackoffMultiplier,this.config.maxRetryDelay),r={retryCount:n,retryDelay:s,lastError:t.message};n>=i.maxRetries?r.status="failed":r.status="pending",await d.syncQueue.update(e,r),this.notifyListeners("operationFailed",i,t),await this.updateQueueStats()}catch(i){console.error(`Failed to mark operation ${e} as failed:`,i)}}async cancelOperation(e,t){try{const i=await d.syncQueue.get(e);if(!i)return;await d.syncQueue.update(e,{status:"cancelled",lastError:t||"Cancelled by user"}),this.notifyListeners("operationFailed",i,new Error(t||"Operation cancelled")),await this.updateQueueStats()}catch(i){console.error(`Failed to cancel operation ${e}:`,i)}}startProcessing(){this.processingTimer&&clearInterval(this.processingTimer),this.processingTimer=setInterval(async()=>{this.isProcessing||await this.processQueue()},this.config.idleCheckInterval)}async processQueue(){if(!(this.isProcessing||this.currentBatches.size>=this.config.maxConcurrentBatches)){this.isProcessing=!0;try{const e=await this.getPendingOperations();if(e.length===0)return;const t=await this.createBatches(e);for(const i of t){const n=crypto.randomUUID(),s=this.processBatch(i,n);this.currentBatches.set(n,s),s.catch(r=>{console.error(`Batch ${n} failed:`,r)}).finally(()=>{this.currentBatches.delete(n)})}}catch(e){console.error("Error processing queue:",e)}finally{this.isProcessing=!1}}}async createBatches(e){const t=[];let i=[];const n=[...e].sort((s,r)=>{const a={critical:4,high:3,normal:2,low:1};return a[r.priority]-a[s.priority]});for(const s of n)i.length>=this.config.batchSize&&(t.push(i),i=[]),!(this.config.requireWifiForLargeFiles&&s.entityType==="image"&&(await this.getNetworkInfo()).connectionType!=="wifi")&&i.push(s);return i.length>0&&t.push(i),t}async processBatch(e,t){try{await Promise.all(e.map(i=>this.markOperationProcessing(i.id))),e.forEach(i=>{this.notifyListeners("operationStarted",i)}),await this.executeBatchSync(e,t),await Promise.all(e.map(i=>this.markOperationCompleted(i.id))),console.log(`Batch ${t} processed successfully (${e.length} operations)`)}catch(i){console.error(`Batch ${t} failed:`,i),await Promise.all(e.map(n=>this.markOperationFailed(n.id,i)))}}async executeBatchSync(e,t){try{const{unifiedSyncService:i}=await I(async()=>{const{unifiedSyncService:s}=await Promise.resolve().then(()=>b);return{unifiedSyncService:s}},void 0),n=this.groupOperationsByType(e);for(const[s,r]of Object.entries(n))await this.processEntityGroup(s,r,i);console.log(`Batch ${t} sync execution completed`)}catch(i){throw console.error(`Batch ${t} sync execution failed:`,i),i}}groupOperationsByType(e){const t={};for(const i of e)t[i.entityType]||(t[i.entityType]=[]),t[i.entityType].push(i);return t}async processEntityGroup(e,t,i){switch(e){case"card":await this.processCardOperations(t,i);break;case"folder":await this.processFolderOperations(t,i);break;case"tag":await this.processTagOperations(t,i);break;case"image":await this.processImageOperations(t,i);break;default:console.warn(`Unknown entity type: ${e}`)}}async processCardOperations(e,t){for(const i of e)try{switch(i.operationType){case"create":await t.addOperation({type:"create",entity:"card",entityId:i.entityId,data:i.data,priority:i.priority,userId:i.userId});break;case"update":await t.addOperation({type:"update",entity:"card",entityId:i.entityId,data:i.data,priority:i.priority,userId:i.userId});break;case"delete":await t.addOperation({type:"delete",entity:"card",entityId:i.entityId,data:{userId:i.userId},priority:i.priority,userId:i.userId});break}}catch(n){throw console.error(`Failed to process card operation ${i.id}:`,n),n}}async processFolderOperations(e,t){for(const i of e)try{switch(i.operationType){case"create":await t.addOperation({type:"create",entity:"folder",entityId:i.entityId,data:i.data,priority:i.priority,userId:i.userId});break;case"update":await t.addOperation({type:"update",entity:"folder",entityId:i.entityId,data:i.data,priority:i.priority,userId:i.userId});break;case"delete":await t.addOperation({type:"delete",entity:"folder",entityId:i.entityId,data:{userId:i.userId},priority:i.priority,userId:i.userId});break}}catch(n){throw console.error(`Failed to process folder operation ${i.id}:`,n),n}}async processTagOperations(e,t){for(const i of e)try{switch(i.operationType){case"create":await t.addOperation({type:"create",entity:"tag",entityId:i.entityId,data:i.data,priority:i.priority,userId:i.userId});break;case"update":await t.addOperation({type:"update",entity:"tag",entityId:i.entityId,data:i.data,priority:i.priority,userId:i.userId});break;case"delete":await t.addOperation({type:"delete",entity:"tag",entityId:i.entityId,data:{userId:i.userId},priority:i.priority,userId:i.userId});break}}catch(n){throw console.error(`Failed to process tag operation ${i.id}:`,n),n}}async processImageOperations(e,t){for(const i of e)try{switch(i.operationType){case"create":await t.addOperation({type:"create",entity:"image",entityId:i.entityId,data:i.data,priority:i.priority,userId:i.userId});break;case"update":await t.addOperation({type:"update",entity:"image",entityId:i.entityId,data:i.data,priority:i.priority,userId:i.userId});break;case"delete":await t.addOperation({type:"delete",entity:"image",entityId:i.entityId,data:{userId:i.userId},priority:i.priority,userId:i.userId});break}}catch(n){throw console.error(`Failed to process image operation ${i.id}:`,n),n}}startCleanup(){this.cleanupTimer&&clearInterval(this.cleanupTimer),this.cleanupTimer=setInterval(async()=>{await this.cleanupQueue()},this.config.cleanupInterval)}async cleanupQueue(){try{const e=Date.now(),t=new Date(e-this.config.maxAge);await d.syncQueue.where("timestamp").below(t).delete();const i=await d.syncQueue.where("status").equals("completed").orderBy("timestamp").reverse().offset(1e3).toArray();i.length>0&&await d.syncQueue.bulkDelete(i.map(s=>s.id));const n=await d.syncQueue.count();if(n>this.config.maxQueueSize){const s=n-this.config.maxQueueSize,r=await d.syncQueue.orderBy("timestamp").limit(s).toArray();await d.syncQueue.bulkDelete(r.map(a=>a.id))}console.log("Queue cleanup completed")}catch(e){console.error("Queue cleanup failed:",e)}}async getNetworkInfo(){if(!("connection"in navigator))return{online:navigator.onLine,connectionType:"none",effectiveType:"4g"};const e=navigator.connection;return{online:navigator.onLine,connectionType:this.getConnectionType(e),effectiveType:e.effectiveType||"4g",rtt:e.rtt,downlink:e.downlink}}getConnectionType(e){if(!e)return"none";switch(e.type){case"wifi":case"ethernet":return"wifi";case"cellular":case"bluetooth":return"cellular";default:return"none"}}async filterReadyOperations(e){const t=[];for(const i of e){if(!i.dependsOn||i.dependsOn.length===0){t.push(i);continue}(await d.syncQueue.where("id").anyOf(i.dependsOn).toArray()).every(r=>r.status==="completed")&&t.push(i)}return t}async getQueueStats(){try{const e=await d.syncQueue.toArray(),t={totalOperations:e.length,pendingOperations:0,processingOperations:0,failedOperations:0,completedOperations:0,byType:{card:0,folder:0,tag:0,image:0},byPriority:{critical:0,high:0,normal:0,low:0},byStatus:{pending:0,processing:0,completed:0,failed:0,cancelled:0},averageProcessingTime:0,failureRate:0,oldestPendingAge:0,averageRetryCount:0};for(const r of e){if(t.byType[r.entityType]++,t.byPriority[r.priority]++,t.byStatus[r.status]++,r.status==="completed"&&r.processingStartedAt){const a=r.timestamp.getTime()-r.processingStartedAt.getTime();t.averageProcessingTime+=a}t.averageRetryCount+=r.retryCount}t.pendingOperations=t.byStatus.pending,t.processingOperations=t.byStatus.processing,t.failedOperations=t.byStatus.failed,t.completedOperations=t.byStatus.completed;const i=t.byStatus.completed;i>0&&(t.averageProcessingTime/=i),e.length>0&&(t.averageRetryCount/=e.length);const n=e.filter(r=>["completed","failed"].includes(r.status)).length;n>0&&(t.failureRate=t.failedOperations/n);const s=e.filter(r=>r.status==="pending");if(s.length>0){const r=s.reduce((o,c)=>{const u=typeof o.timestamp=="string"?new Date(o.timestamp).getTime():o.timestamp.getTime();return(typeof c.timestamp=="string"?new Date(c.timestamp).getTime():c.timestamp.getTime())<u?c:o}),a=typeof r.timestamp=="string"?new Date(r.timestamp).getTime():r.timestamp.getTime();t.oldestPendingAge=Date.now()-a}return t}catch(e){return console.error("Failed to get queue stats:",e),this.getEmptyStats()}}getEmptyStats(){return{totalOperations:0,pendingOperations:0,processingOperations:0,failedOperations:0,completedOperations:0,byType:{card:0,folder:0,tag:0,image:0},byPriority:{critical:0,high:0,normal:0,low:0},byStatus:{pending:0,processing:0,completed:0,failed:0,cancelled:0},averageProcessingTime:0,failureRate:0,oldestPendingAge:0,averageRetryCount:0}}async updateQueueStats(){try{const e=await this.getQueueStats();this.notifyListeners("queueStatsChanged",e)}catch(e){console.error("Failed to update queue stats:",e)}}addEventListener(e,t){this.listeners[e]=t}removeEventListener(e){delete this.listeners[e]}notifyListeners(e,...t){const i=this.listeners[e];if(i)try{i(...t)}catch(n){console.error(`Error in ${e} listener:`,n)}}async clearQueue(){try{await d.syncQueue.clear(),await this.updateQueueStats(),console.log("Queue cleared successfully")}catch(e){console.error("Failed to clear queue:",e)}}async getOperation(e){try{return await d.syncQueue.get(e)}catch(t){console.error(`Failed to get operation ${e}:`,t);return}}async removeOperation(e){try{await d.syncQueue.delete(e),await this.updateQueueStats()}catch(t){throw console.error(`Failed to remove operation ${e}:`,t),t}}async retryFailedOperations(){try{const e=await d.syncQueue.where("status").equals("failed").toArray();for(const t of e)await d.syncQueue.update(t.id,{status:"pending",retryCount:0,retryDelay:this.config.initialRetryDelay,lastError:void 0});return await this.updateQueueStats(),console.log(`Retried ${e.length} failed operations`),e.length}catch(e){return console.error("Failed to retry failed operations:",e),0}}async clearCompletedOperations(){try{const e=await d.syncQueue.where("status").equals("completed").toArray(),i=e.slice(0,-100);for(const n of i)await d.syncQueue.delete(n.id);return await this.updateQueueStats(),console.log(`Cleared ${i.length} completed operations, kept ${e.length-i.length} recent ones`),i.length}catch(e){return console.error("Failed to clear completed operations:",e),0}}updateConfig(e){if(e.maxRetries!==void 0&&e.maxRetries<0)throw new Error("maxRetries must be non-negative");if(e.batchSize!==void 0&&e.batchSize<=0)throw new Error("batchSize must be positive");if(e.maxQueueSize!==void 0&&e.maxQueueSize<0)throw new Error("maxQueueSize must be non-negative");if(e.processingTimeout!==void 0&&e.processingTimeout<=0)throw new Error("processingTimeout must be positive");if(e.idleCheckInterval!==void 0&&e.idleCheckInterval<=0)throw new Error("idleCheckInterval must be positive");this.config={...this.config,...e},e.idleCheckInterval!==void 0&&this.startProcessing(),e.cleanupInterval!==void 0&&this.startCleanup(),console.log("LocalOperationService config updated")}destroy(){this.processingTimer&&clearInterval(this.processingTimer),this.cleanupTimer&&clearInterval(this.cleanupTimer),Promise.all(this.currentBatches.values()).then(()=>{console.log("LocalOperationService destroyed")})}}const v=new G;class Z{available;waiting=[];constructor(e){this.available=e}async acquire(){if(this.available>0){this.available--;return}return new Promise(e=>{this.waiting.push(e)})}release(){if(this.available++,this.waiting.length>0&&this.available>0){const e=this.waiting.shift();e&&(this.available--,e())}}}class X{isOffline=!navigator.onLine;networkInfo={status:navigator.onLine?"online":"offline",lastChanged:new Date};offlineOperations=[];conflicts=[];offlineStartTime;syncTimer;reconnectAttempts=0;maxReconnectAttempts=10;listeners={};constructor(){this.initializeOfflineManager()}getNetworkStatus(){return{...this.networkInfo}}isCurrentlyOffline(){return this.isOffline}async getOfflineStats(){const e=await this.getPendingOfflineOperations(),t=await this.getCompletedOfflineOperations(),i=await this.getFailedOfflineOperations();return{isOffline:this.isOffline,offlineDuration:this.calculateOfflineDuration(),pendingOperations:e.length,completedOfflineOperations:t.length,failedOperations:i.length,averageResponseTime:this.calculateAverageResponseTime(),dataSyncedOnResume:this.calculateDataSyncedOnResume(),lastSyncTime:await this.getLastSyncTime(),estimatedBandwidthSaved:this.calculateEstimatedBandwidthSaved(e)}}async executeOfflineOperation(e){const t={...e,id:crypto.randomUUID(),timestamp:new Date,retryCount:0};try{e.dependencies&&e.dependencies.length>0&&await this.validateDependencies(e.dependencies);const i=await this.performLocalOperation(t);return await this.storeOfflineOperation(t),this.listeners.onOfflineOperation&&this.listeners.onOfflineOperation(t),{success:!0,data:i,operationId:t.id}}catch(i){return console.error("Offline operation failed:",i),t.priority="high",await this.storeOfflineOperation(t),{success:!1,error:i instanceof Error?i.message:String(i),operationId:t.id}}}async executeBatchOfflineOperations(e){const t=crypto.randomUUID(),i=[];try{const n=e.filter(r=>r.dependencies&&r.dependencies.length>0).flatMap(r=>r.dependencies);n.length>0&&await this.validateDependencies(n);const s=this.sortOperationsByPriority(e);for(const r of s){const a=await this.executeOfflineOperation(r);i.push(a)}return{success:i.every(r=>r.success),results:i,batchId:t}}catch(n){return console.error("Batch offline operations failed:",n),{success:!1,results:i.map(s=>({...s,success:!1,error:n instanceof Error?n.message:String(n)})),batchId:t}}}async getPendingOfflineOperations(){return await l.transaction("r",[l.syncQueue],async()=>(await l.syncQueue.where("status").equals("pending").toArray()).map(t=>this.convertSyncOperationToOfflineOperation(t)))}async retryFailedOperations(){const e=await this.getFailedOfflineOperations();let t=0;for(const i of e)try{await this.retryOperation(i),t++}catch(n){console.warn(`Failed to retry operation ${i.id}:`,n)}return t}async handleNetworkRecovery(){console.log("Network recovered, analyzing sync strategy...");const e=performance.now(),t=await this.getOfflineStats();try{const i=await this.assessNetworkQuality(),n=await this.determineSyncStrategy(t,i);console.log(`Using sync strategy: ${n.strategy}`),this.notifySyncProgress(0,t.pendingOperations);const s=await this.executeSmartSync(n,t);s.conflicts.length>0&&await this.handleConflicts(s.conflicts),await this.performPostSyncOptimizations(s,i);const r=await this.getOfflineStats();this.notifySyncComplete(r),console.log(`Smart offline sync completed in ${(performance.now()-e).toFixed(2)}ms`),console.log(`Sync results: ${s.syncedOperations} operations, ${s.conflicts.length} conflicts`)}catch(i){console.error("Smart offline sync failed:",i),await this.handleSyncError(i,t),this.listeners.onError&&this.listeners.onError(i instanceof Error?i:new Error(String(i)))}}async assessNetworkQuality(){const e=navigator.connection,t={isStable:!0,bandwidth:"good",latency:"low",reliability:.9,recommendedStrategy:"immediate"};e&&(e.downlink&&(e.downlink>=20?(t.bandwidth="excellent",t.recommendedStrategy="immediate"):e.downlink>=10?(t.bandwidth="good",t.recommendedStrategy="immediate"):e.downlink>=3?(t.bandwidth="fair",t.recommendedStrategy="batched"):e.downlink>=1?(t.bandwidth="poor",t.recommendedStrategy="conservative"):(t.bandwidth="poor",t.recommendedStrategy="prioritized")),e.rtt&&(e.rtt<=50?t.latency="low":e.rtt<=150?(t.latency="medium",t.recommendedStrategy="batched"):e.rtt<=500?(t.latency="high",t.recommendedStrategy="conservative"):(t.latency="high",t.recommendedStrategy="prioritized")),e.type==="cellular"?(t.reliability=.7,(e.effectiveType==="slow-2g"||e.effectiveType==="2g")&&(t.recommendedStrategy="conservative")):e.type==="wifi"?t.reliability=.9:e.type==="ethernet"&&(t.reliability=.95));const i=await this.testConnectionStability();t.isStable=i.isStable,t.reliability*=i.stabilityFactor,t.isStable||(t.recommendedStrategy="conservative");const n=await this.calculateHistoricalReliability();return t.reliability*=n,t}async testConnectionStability(){const e=["https://www.google.com/favicon.ico","https://www.cloudflare.com/favicon.ico"],n=(await Promise.allSettled(e.map(r=>fetch(r,{method:"HEAD",mode:"no-cors"})))).filter(r=>r.status==="fulfilled").length/e.length;return{isStable:n>=.8,stabilityFactor:n}}determineRecommendedStrategy(e){return e.isStable&&e.bandwidth==="excellent"&&e.latency==="low"?"immediate":e.reliability>=.8&&e.bandwidth!=="poor"?"batched":e.reliability>=.6?"prioritized":"conservative"}async determineSyncStrategy(e,t){return{strategy:t.recommendedStrategy,batchSize:this.calculateOptimalBatchSize(e,t),delayBetweenBatches:this.calculateBatchDelay(t),priorityFilter:this.determinePriorityFilter(e,t),maxConcurrentOperations:this.calculateMaxConcurrent(t),timeout:this.calculateOperationTimeout(t),retryStrategy:this.determineRetryStrategy(t)}}calculateOptimalBatchSize(e,t){let i=10;switch(t.bandwidth){case"excellent":i=50;break;case"good":i=30;break;case"fair":i=15;break;case"poor":i=5;break}return e.pendingOperations>100&&(i=Math.min(i,20)),i}calculateBatchDelay(e){switch(e.bandwidth){case"excellent":return 100;case"good":return 300;case"fair":return 500;case"poor":return 1e3;default:return 500}}determinePriorityFilter(e,t){return t.reliability<.7?["critical","high"]:e.pendingOperations>50?["critical","high","normal"]:["critical","high","normal","low"]}calculateMaxConcurrent(e){switch(e.latency){case"low":return e.bandwidth==="excellent"?5:3;case"medium":return 2;case"high":return 1;default:return 2}}calculateOperationTimeout(e){let t=1e4;switch(e.latency){case"high":t*=2;break;case"medium":t*=1.5;break}switch(e.bandwidth){case"poor":t*=1.5;break;case"fair":t*=1.2;break}return t}determineRetryStrategy(e){return e.isStable&&e.reliability>=.8?{maxRetries:3,initialDelay:1e3,maxDelay:5e3,backoffMultiplier:2}:{maxRetries:5,initialDelay:2e3,maxDelay:15e3,backoffMultiplier:2.5}}async executeSmartSync(e,t){const n=(await this.getPendingOfflineOperations()).filter(c=>e.priorityFilter.includes(c.priority)),s=this.createOptimalBatches(n,e.batchSize),r={success:!0,syncedOperations:0,conflicts:[],errors:[]},a=new Z(e.maxConcurrentOperations),o=s.map(async(c,u)=>{await a.acquire();try{u>0&&await new Promise(g=>setTimeout(g,e.delayBetweenBatches));const h=await this.executeBatchWithRetry(c,e.retryStrategy,e.timeout);r.syncedOperations+=h.syncedCount,r.conflicts.push(...h.conflicts),r.errors.push(...h.errors),this.notifySyncProgress(r.syncedOperations,n.length)}catch(h){r.errors.push(`Batch ${u} failed: ${h}`)}finally{a.release()}});return await Promise.all(o),r.success=r.errors.length===0,r}createOptimalBatches(e,t){const i=[],n={critical:4,high:3,normal:2,low:1},s=[...e].sort((r,a)=>n[a.priority]-n[r.priority]);for(let r=0;r<s.length;r+=t)i.push(s.slice(r,r+t));return i}async executeBatchWithRetry(e,t,i){let n=null;for(let s=1;s<=t.maxRetries;s++)try{return await this.executeBatchWithTimeout(e,i)}catch(r){if(n=r instanceof Error?r:new Error(String(r)),s===t.maxRetries)break;const a=Math.min(t.initialDelay*Math.pow(t.backoffMultiplier,s-1),t.maxDelay);console.log(`Retry ${s}/${t.maxRetries} after ${a}ms`),await new Promise(o=>setTimeout(o,a))}return{syncedCount:0,conflicts:[],errors:[n?.message||"Batch execution failed after all retries"]}}async executeBatchWithTimeout(e,t){const i=new Promise((s,r)=>{setTimeout(()=>r(new Error("Operation timeout")),t)}),n=this.executeBatchOperations(e);try{return await Promise.race([n,i])}catch(s){throw s instanceof Error&&s.message==="Operation timeout"?new Error(`Batch operation timed out after ${t}ms`):s}}async executeBatchOperations(e){let t=0;const i=[],n=[];for(const s of e)try{const r=await this.syncOperation(s);r.success?t++:r.conflict?i.push(r.conflict):n.push(r.error||`Operation ${s.id} failed`)}catch(r){n.push(`Operation ${s.id} error: ${r}`)}return{syncedCount:t,conflicts:i,errors:n}}async performPostSyncOptimizations(e,t){e.success&&e.errors.length===0&&await this.cleanupOldSyncState(),t.bandwidth==="excellent"&&t.isStable&&await this.preloadRemoteData(),await this.updateNetworkHistory(t)}async handleSyncError(e,t){console.error("Sync error occurred, attempting recovery...",e),e.message?.includes("timeout")?await this.scheduleReducedSync():e.message?.includes("network")?await this.scheduleDelayedSync():await this.scheduleRetrySync()}async scheduleReducedSync(){setTimeout(async()=>{(await this.getOfflineStats()).pendingOperations>0&&(console.log("Executing reduced sync..."),await this.syncCriticalOperationsOnly())},5e3)}async scheduleDelayedSync(){setTimeout(async()=>{(await this.getOfflineStats()).pendingOperations>0&&(console.log("Executing delayed sync..."),await this.handleNetworkRecovery())},3e4)}async scheduleRetrySync(){setTimeout(async()=>{(await this.getOfflineStats()).pendingOperations>0&&(console.log("Retrying sync..."),await this.handleNetworkRecovery())},1e4)}async syncCriticalOperationsOnly(){const t=(await this.getPendingOfflineOperations()).filter(i=>i.priority==="critical");if(t.length>0){const i=await this.executeBatchOperations(t);console.log(`Critical sync completed: ${i.syncedCount}/${t.length}`)}}async cleanupOldSyncState(){try{const e=Object.keys(localStorage).filter(t=>t.startsWith("offlineBackup_")).sort();if(e.length>3&&e.slice(0,e.length-3).forEach(i=>localStorage.removeItem(i)),l.offlineState){const t=await l.offlineState.orderBy("timestamp").reverse().offset(5).toArray();for(const i of t)await l.offlineState.delete(i.id)}}catch(e){console.warn("Failed to cleanup old sync state:",e)}}async preloadRemoteData(){try{console.log("Preloading remote data...")}catch(e){console.warn("Failed to preload remote data:",e)}}async updateNetworkHistory(e){try{const t="networkQualityHistory",i=JSON.parse(localStorage.getItem(t)||"[]");i.push({timestamp:new Date().toISOString(),...e}),i.length>100&&i.splice(0,i.length-100),localStorage.setItem(t,JSON.stringify(i))}catch(t){console.warn("Failed to update network history:",t)}}async performOfflineSync(){const e=await this.getPendingOfflineOperations(),t=[],i=[],n=[],s=e.filter(u=>u.priority==="critical"),r=e.filter(u=>u.priority==="high"),a=e.filter(u=>u.priority==="normal"),o=e.filter(u=>u.priority==="low"),c=[...s,...r,...a,...o];for(let u=0;u<c.length;u++){const h=c[u];try{if(!navigator.onLine)throw new Error("Network lost during sync");const g=await this.syncOperation(h);g.success?t.push(h.id):g.conflict?i.push(g.conflict):n.push(g.error||`Sync failed for operation ${h.id}`),this.notifySyncProgress(u+1,c.length),u%10===0&&await new Promise(y=>setTimeout(y,100))}catch(g){const y=g instanceof Error?g.message:String(g);if(n.push(`Operation ${h.id} failed: ${y}`),y.includes("network")||y.includes("Network")){console.warn("Network error during sync, pausing...");break}}}return{success:n.length===0,syncedOperations:t.length,conflicts:i,errors:n}}async detectConflicts(e,t){if(!t)return null;const i=await this.getLocalDataForEntity(e.entity,e.entityId);if(!i)return null;const n=new Date(e.timestamp),s=new Date(t.updatedAt||t.createdAt);return n>s?{id:crypto.randomUUID(),entityType:e.entity,entityId:e.entityId||"",localData:i,remoteData:t,conflictType:this.determineConflictType(e,i,t),timestamp:new Date,resolution:"pending"}:null}async handleConflicts(e){for(const t of e)try{const i=await this.resolveConflict(t);i==="manual"?(this.conflicts.push(t),this.listeners.onConflict&&this.listeners.onConflict(t)):await this.applyConflictResolution(t,i)}catch(i){console.error(`Failed to resolve conflict ${t.id}:`,i),t.resolution="manual",this.conflicts.push(t)}}async resolveConflict(e){switch(e.conflictType){case"simultaneous_edit":return await this.attemptSmartMerge(e);case"delete_conflict":return"manual";case"structure_conflict":return"local";default:return"manual"}}async attemptSmartMerge(e){const t=this.extractContentForMerge(e.localData),i=this.extractContentForMerge(e.remoteData);if(this.calculateContentSimilarity(t,i)>.8){const n=new Date(e.localData.updatedAt||e.localData.createdAt),s=new Date(e.remoteData.updatedAt||e.remoteData.createdAt);return n>s?"local":"remote"}return"manual"}setEventListeners(e){this.listeners={...this.listeners,...e}}notifyNetworkChange(e){this.listeners.onNetworkChange&&this.listeners.onNetworkChange(e)}notifySyncProgress(e,t){this.listeners.onSyncProgress&&this.listeners.onSyncProgress({completed:e,total:t})}notifySyncComplete(e){this.listeners.onSyncComplete&&this.listeners.onSyncComplete(e)}initializeOfflineManager(){this.setupNetworkListeners(),this.setupConnectionMonitoring(),this.loadOfflineState(),this.startPeriodicSync()}setupNetworkListeners(){window.addEventListener("online",()=>{this.handleNetworkChange(!0)}),window.addEventListener("offline",()=>{this.handleNetworkChange(!1)})}setupConnectionMonitoring(){if("connection"in navigator){const e=navigator.connection;e.addEventListener("change",()=>{this.updateConnectionInfo(e)}),this.updateConnectionInfo(e)}}startPeriodicSync(){this.syncTimer=setInterval(async()=>{navigator.onLine&&(await this.getOfflineStats()).pendingOperations>0&&await this.handleNetworkRecovery()},30*1e3)}cleanup(){this.syncTimer&&clearInterval(this.syncTimer),window.removeEventListener("online",this.handleNetworkChange),window.removeEventListener("offline",this.handleNetworkChange)}async handleNetworkChange(e){const t=this.networkInfo.status,i=e?"online":"offline";this.isOffline=!e,this.networkInfo={...this.networkInfo,status:i,lastChanged:new Date},t==="offline"&&i==="online"?(this.reconnectAttempts=0,await this.handleNetworkRecovery()):t==="online"&&i==="offline"&&(this.offlineStartTime=new Date),this.notifyNetworkChange(this.networkInfo)}updateConnectionInfo(e){this.networkInfo={...this.networkInfo,effectiveType:e.effectiveType,downlink:e.downlink,rtt:e.rtt,saveData:e.saveData,connectionType:this.determineConnectionType(e)}}determineConnectionType(e){if(e.type)switch(e.type){case"wifi":return"wifi";case"cellular":return"cellular";case"ethernet":return"ethernet";default:return"unknown"}return e.effectiveType&&["4g","5g"].includes(e.effectiveType)?e.effectiveType==="5g"?"wifi":"cellular":"unknown"}async validateDependencies(e){const i=(await this.getPendingOfflineOperations()).map(s=>s.id),n=e.filter(s=>!i.includes(s));if(n.length>0)throw new Error(`Dependencies not found: ${n.join(", ")}`)}async performLocalOperation(e){switch(e.type){case"create":return v.createCard(e.data,e.userId);case"update":return v.updateCard(e.entityId,e.data,e.userId);case"delete":return v.deleteCard(e.entityId,e.userId);default:throw new Error(`Unsupported operation type: ${e.type}`)}}async storeOfflineOperation(e){try{await l.syncQueue.add({id:e.id,type:e.type,entity:e.entity,entityId:e.entityId,userId:e.userId,data:e.data,priority:e.priority,timestamp:e.timestamp,retryCount:e.retryCount,maxRetries:e.maxRetries,error:void 0})}catch(t){throw console.error("Failed to store offline operation:",t),t}}async syncOperation(e){try{const t=await this.fetchRemoteData(e.entity,e.entityId),i=await this.detectConflicts(e,t);return i?{success:!1,conflict:i}:(await new Promise(n=>setTimeout(n,100)),await l.syncQueue.where("id").equals(e.id).modify({status:"completed"}),{success:!0})}catch(t){return{success:!1,error:t instanceof Error?t.message:String(t)}}}async fetchRemoteData(e,t){return null}async getLocalDataForEntity(e,t){switch(e){case"card":return t?l.cards.get(t):null;case"folder":return t?l.folders.get(t):null;case"tag":return t?l.tags.get(t):null;default:return null}}determineConflictType(e,t,i){return e.type==="delete"?"delete_conflict":this.hasStructureChanged(t,i)?"structure_conflict":"simultaneous_edit"}hasStructureChanged(e,t){const i=new Set(Object.keys(e)),n=new Set(Object.keys(t));return i.size!==n.size||![...i].every(s=>n.has(s))}extractContentForMerge(e){return e.frontContent&&e.backContent?JSON.stringify({front:e.frontContent,back:e.backContent}):JSON.stringify(e)}calculateContentSimilarity(e,t){const i=this.calculateLevenshteinDistance(e,t),n=Math.max(e.length,t.length);return n>0?1-i/n:1}calculateLevenshteinDistance(e,t){const i=Array(t.length+1).fill(null).map(()=>Array(e.length+1).fill(null));for(let n=0;n<=e.length;n++)i[0][n]=n;for(let n=0;n<=t.length;n++)i[n][0]=n;for(let n=1;n<=t.length;n++)for(let s=1;s<=e.length;s++){const r=e[s-1]===t[n-1]?0:1;i[n][s]=Math.min(i[n][s-1]+1,i[n-1][s]+1,i[n-1][s-1]+r)}return i[t.length][e.length]}async applyConflictResolution(e,t){e.resolution=t}async loadOfflineState(){try{const e=await this.loadFromIndexedDB();if(e){await this.restoreOfflineState(e);return}const t=localStorage.getItem("offlineManagerState");if(t){const i=JSON.parse(t);await this.restoreOfflineState(i),await this.saveToIndexedDB(i),localStorage.removeItem("offlineManagerState")}}catch(e){console.warn("Failed to load offline state:",e)}}async saveOfflineState(){try{const e=await this.createOfflineStateSnapshot();await this.saveToIndexedDB(e),await this.saveToLocalStorage(e),await this.createIncrementalBackup(e)}catch(e){console.warn("Failed to save offline state:",e),await this.saveToLocalStorageFallback()}}async createOfflineStateSnapshot(){const e=await this.getPendingOfflineOperations(),t=this.conflicts,i=await this.getOfflineStats();return{version:this.getCurrentStateVersion(),timestamp:new Date().toISOString(),offlineStartTime:this.offlineStartTime?.toISOString(),reconnectAttempts:this.reconnectAttempts,networkInfo:this.networkInfo,pendingOperations:e.map(n=>this.serializeOfflineOperation(n)),conflicts:t.map(n=>this.serializeConflict(n)),stats:this.serializeStats(i),checksum:await this.calculateStateChecksum(e,t)}}async saveToIndexedDB(e){try{await l.transaction("rw",[l.syncQueue],async()=>{l.offlineState||await l.version(l.ver+1).stores({offlineState:"++id,version,timestamp,checksum"}),await l.offlineState?.clear(),await l.offlineState?.add({version:e.version,timestamp:new Date(e.timestamp),data:JSON.stringify(e),checksum:e.checksum,compressed:!0})})}catch(t){throw console.warn("Failed to save to IndexedDB:",t),t}}async loadFromIndexedDB(){try{if(!l.offlineState)return null;const e=await l.offlineState.orderBy("timestamp").reverse().first();if(!e)return null;if(e.compressed){const t=this.decompressData(e.data),i=JSON.parse(t);if(await this.verifyStateChecksum(i))return i}return null}catch(e){return console.warn("Failed to load from IndexedDB:",e),null}}async saveToLocalStorage(e){try{const t=this.compressData(JSON.stringify(e));localStorage.setItem("offlineManagerState",t)}catch(t){console.warn("Failed to save to localStorage:",t)}}async saveToLocalStorageFallback(){try{const e={offlineStartTime:this.offlineStartTime?.toISOString(),reconnectAttempts:this.reconnectAttempts,timestamp:new Date().toISOString()};localStorage.setItem("offlineManagerState",JSON.stringify(e))}catch(e){console.warn("Fallback save failed:",e)}}async createIncrementalBackup(e){try{const t=`offlineBackup_${Date.now()}`,i={timestamp:e.timestamp,version:e.version,pendingCount:e.pendingOperations.length,conflictsCount:e.conflicts.length,compressed:!0},n=Object.keys(localStorage).filter(s=>s.startsWith("offlineBackup_")).sort();n.length>=10&&n.slice(0,n.length-9).forEach(r=>localStorage.removeItem(r)),localStorage.setItem(t,JSON.stringify(i))}catch(t){console.warn("Failed to create incremental backup:",t)}}compressData(e){try{return btoa(encodeURIComponent(e))}catch{return e}}decompressData(e){try{return decodeURIComponent(atob(e))}catch{return e}}getCurrentStateVersion(){return`1.0.${Date.now()}`}async calculateStateChecksum(e,t){const i=JSON.stringify({operations:e.length,conflicts:t.length,timestamp:Date.now()});let n=0;for(let s=0;s<i.length;s++){const r=i.charCodeAt(s);n=(n<<5)-n+r,n=n&n}return Math.abs(n).toString(16)}async verifyStateChecksum(e){try{const t=e.pendingOperations.map(s=>this.deserializeOfflineOperation(s)),i=e.conflicts.map(s=>this.deserializeConflict(s));return await this.calculateStateChecksum(t,i)===e.checksum}catch{return!1}}async restoreOfflineState(e){if(this.offlineStartTime=e.offlineStartTime?new Date(e.offlineStartTime):void 0,this.reconnectAttempts=e.reconnectAttempts||0,e.networkInfo&&(this.networkInfo={...this.networkInfo,...e.networkInfo,lastChanged:new Date(e.networkInfo.lastChanged||Date.now())}),e.pendingOperations)try{const t=e.pendingOperations.map(i=>this.deserializeOfflineOperation(i));await this.validateAndRestoreOperations(t)}catch(t){console.warn("Failed to restore pending operations:",t)}e.conflicts&&(this.conflicts=e.conflicts.map(t=>this.deserializeConflict(t)))}serializeOfflineOperation(e){return{...e,timestamp:e.timestamp.toISOString()}}deserializeOfflineOperation(e){return{...e,timestamp:new Date(e.timestamp)}}serializeConflict(e){return{...e,timestamp:e.timestamp.toISOString()}}deserializeConflict(e){return{...e,timestamp:new Date(e.timestamp)}}serializeStats(e){return{...e,lastSyncTime:e.lastSyncTime?.toISOString()}}async validateAndRestoreOperations(e){const t=e.filter(i=>i.id&&i.type&&i.entity&&i.timestamp);for(const i of t)try{await this.storeOfflineOperation(i)}catch(n){console.warn(`Failed to restore operation ${i.id}:`,n)}}calculateOfflineDuration(){return this.offlineStartTime?Date.now()-this.offlineStartTime.getTime():0}calculateAverageResponseTime(){return 50}calculateDataSyncedOnResume(){return 0}calculateEstimatedBandwidthSaved(e){return e.length*1024}async getLastSyncTime(){try{const e=await l.syncQueue.where("status").equals("completed").orderBy("timestamp").reverse().first();return e?new Date(e.timestamp):void 0}catch{return}}async getCompletedOfflineOperations(){try{return(await l.syncQueue.where("status").equals("completed").toArray()).map(t=>this.convertSyncOperationToOfflineOperation(t))}catch{return[]}}async getFailedOfflineOperations(){try{return(await l.syncQueue.where("status").equals("failed").toArray()).map(t=>this.convertSyncOperationToOfflineOperation(t))}catch{return[]}}convertSyncOperationToOfflineOperation(e){return{id:e.id,type:e.type,entity:e.entity,entityId:e.entityId,userId:e.userId,data:e.data,priority:e.priority,timestamp:new Date(e.timestamp),retryCount:e.retryCount,maxRetries:e.maxRetries,status:e.status}}sortOperationsByPriority(e){const t={critical:4,high:3,normal:2,low:1};return[...e].sort((i,n)=>t[n.priority]-t[i.priority])}async retryOperation(e){await l.syncQueue.where("id").equals(e.id).modify({status:"pending",retryCount:e.retryCount+1})}async calculateHistoricalReliability(){try{const e=new Date(Date.now()-36e5),t=await l.syncQueue.where("timestamp").above(e).toArray();return t.length===0?1:t.filter(n=>n.status==="completed").length/t.length}catch{return .9}}async predictAndPreventConflicts(e){const t=[];for(const i of e)if(i.entityId){const n=await this.checkPotentialConflict(i);n&&t.push(n)}return t}async checkPotentialConflict(e){try{const t=await l.syncQueue.where("entity").equals(e.entity).and(s=>s.entityId===e.entityId).reverse().limit(5).toArray();if(t.length===0)return null;const i=new Date(Date.now()-5*60*1e3),n=t.filter(s=>new Date(s.timestamp)>i&&s.id!==e.id);return n.length>0?{id:crypto.randomUUID(),entityType:e.entity,entityId:e.entityId,localData:e.data,remoteData:n[0].data,conflictType:"simultaneous_edit",timestamp:new Date,resolution:"pending"}:null}catch{return null}}async generatePerformanceOptimization(){const e=await this.getOfflineStats(),t=[],i=[];return e.averageResponseTime>100&&(t.push("建议启用操作批处理以减少响应时间"),i.push(.3)),e.pendingOperations>50&&(t.push("建议增加同步频率或优化队列管理"),i.push(.4)),e.failedOperations>e.completedOfflineOperations*.1&&(t.push("建议检查网络连接并优化重试策略"),i.push(.5)),{recommendations:t,predictedImprovements:i}}async compressOfflineData(e){const t=[];let i=0,n=0;for(const s of e)if(i+=JSON.stringify(s.data).length,JSON.stringify(s.data).length>1024){const r={...s,data:await this.compressData(s.data)};t.push(r),n+=JSON.stringify(r.data).length}else t.push(s),n+=JSON.stringify(s.data).length;return{compressed:t,compressionRatio:i>0?n/i:1}}}const Y=new X;class Q{isInitialized=!1;authService=null;isOnline=!1;syncInProgress=!1;conflicts=[];metrics=this.getDefaultMetrics();listeners=new Set;operationHistory=[];syncCache=new Map;lastFullSync=null;constructor(){this.initialize(),this.setupOfflineIntegration()}getDefaultMetrics(){return{totalOperations:0,successfulOperations:0,failedOperations:0,averageSyncTime:0,lastSyncTime:null,conflictsCount:0,networkQuality:"good",cacheHitRate:0}}initialize(){this.isInitialized||(this.initializeNetworkIntegration(),this.initializeQueueIntegration(),this.startBackgroundSync(),this.isInitialized=!0,console.log("Unified sync service initialized"))}initializeNetworkIntegration(){m.addListener({onNetworkStateChanged:this.handleNetworkStateChange.bind(this),onNetworkError:this.handleNetworkError.bind(this),onSyncCompleted:this.handleSyncCompleted.bind(this),onSyncStrategyChanged:this.handleSyncStrategyChanged.bind(this)})}initializeQueueIntegration(){C.setEventListeners({onOperationComplete:this.handleOperationComplete.bind(this),onBatchComplete:this.handleBatchComplete.bind(this),onQueueError:this.handleQueueError.bind(this),onStatusChange:this.handleQueueStatusChange.bind(this)})}startBackgroundSync(){setInterval(()=>{this.shouldPerformBackgroundSync()&&this.performIncrementalSync()},this.getAdaptiveSyncInterval()),setInterval(()=>{this.isOnline&&!this.syncInProgress&&this.processLocalSyncQueue().catch(console.error)},3e4)}setupOfflineIntegration(){Y.setEventListeners({onNetworkChange:e=>this.handleOfflineNetworkChange(e),onOfflineOperation:e=>this.handleOfflineOperation(e),onSyncProgress:e=>this.handleOfflineSyncProgress(e),onConflict:e=>this.handleOfflineConflict(e),onSyncComplete:e=>this.handleOfflineSyncComplete(e),onError:e=>this.handleOfflineError(e)})}handleOfflineNetworkChange(e){this.isOnline=e.status==="online",this.notifyStatusChange(),this.isOnline&&this.performIncrementalSync().catch(console.error)}handleOfflineOperation(e){const t={id:e.id,type:e.type,entity:e.entity,entityId:e.entityId||"",data:e.data,priority:this.mapOfflinePriorityToSyncPriority(e.priority),timestamp:e.timestamp,userId:e.userId,metadata:{source:"user",conflictResolution:e.metadata?.conflictResolution,retryStrategy:"delayed"}};this.operationHistory.push(t)}handleOfflineSyncProgress(e){this.notifyListeners({status:"syncing",progress:e.completed/e.total*100,message:`离线同步进度: ${e.completed}/${e.total}`})}handleOfflineConflict(e){const t={id:e.id,entity:e.entityType,entityId:e.entityId,localData:e.localData,cloudData:e.remoteData,conflictType:this.mapOfflineConflictType(e.conflictType),resolution:e.resolution,timestamp:e.timestamp};this.conflicts.push(t),this.notifyStatusChange()}handleOfflineSyncComplete(e){this.metrics.totalOperations+=e.completedOfflineOperations,this.metrics.successfulOperations+=e.completedOfflineOperations,this.metrics.failedOperations+=e.failedOperations,this.metrics.lastSyncTime=e.lastSyncTime,this.notifyListeners({status:"completed",progress:100,message:"离线同步完成"})}handleOfflineError(e){console.error("离线管理器错误:",e),this.notifyListeners({status:"error",progress:0,message:`离线操作错误: ${e.message}`})}mapOfflinePriorityToSyncPriority(e){switch(e){case"critical":case"high":return"high";case"normal":return"normal";case"low":return"low";default:return"normal"}}mapOfflineConflictType(e){switch(e){case"simultaneous_edit":return"content";case"delete_conflict":return"version";case"structure_conflict":return"structure";default:return"content"}}async addOperation(e){const t={...e,id:crypto.randomUUID(),timestamp:new Date};try{const i={type:e.type,entity:e.entity,entityId:e.entityId,userId:e.userId,data:e.data,priority:e.priority,retryCount:0,maxRetries:this.getMaxRetries(e.priority),dependencies:this.getOperationDependencies(e)},n=await C.enqueueOperation(i);return this.operationHistory.push(t),this.updateMetrics({totalOperations:this.metrics.totalOperations+1}),this.shouldProcessImmediately()&&this.processNextOperations(),n}catch(i){throw console.error("Failed to add sync operation:",i),i}}async performFullSync(){if(!(this.syncInProgress||!this.canSync())){this.syncInProgress=!0,this.notifyStatusChange();try{const e=performance.now();await this.processLocalSyncQueue(),await this.syncFromCloud(),await this.processSyncQueue(),await this.detectAndResolveConflicts(),await this.verifyDataConsistency();const t=performance.now()-e;this.lastFullSync=new Date,this.updateMetrics({lastSyncTime:this.lastFullSync,averageSyncTime:(this.metrics.averageSyncTime+t)/2}),console.log(`Full sync completed in ${t}ms`)}catch(e){throw console.error("Full sync failed:",e),e}finally{this.syncInProgress=!1,this.notifyStatusChange()}}}async performIncrementalSync(){if(!(this.syncInProgress||!this.canSync()))try{await this.processLocalSyncQueue(),await this.processHighPriorityOperations(),await this.checkCloudUpdates(),this.cleanupCache()}catch(e){console.error("Incremental sync failed:",e)}}async processLocalSyncQueue(){if(this.isOnline)try{const e=await v.getPendingSyncOperations();if(e.length===0)return;console.log(`Processing ${e.length} local sync operations`);const t=await this.processBatchLocalOperations(e);await v.updateOperationStatuses(t),this.metrics.totalOperations+=t.length,this.metrics.successfulOperations+=t.filter(i=>i.success).length,this.metrics.failedOperations+=t.filter(i=>!i.success).length}catch(e){console.error("Failed to process local sync queue:",e)}}async processBatchLocalOperations(e){const t=[],i=this.groupLocalOperationsByType(e);for(const[n,s]of Object.entries(i)){const r=await this.processLocalOperationGroup(n,s);t.push(...r)}return t}groupLocalOperationsByType(e){const t={};for(const i of e){const n=`${i.entityType}_${i.operationType}`;t[n]||(t[n]=[]),t[n].push(i)}return t}async processLocalOperationGroup(e,t){const i=[];try{switch(e){case"card_create":case"card_update":case"card_delete":await this.processCardOperations(t,i);break;case"folder_create":case"folder_update":case"folder_delete":await this.processFolderOperations(t,i);break;case"tag_create":case"tag_update":case"tag_delete":await this.processTagOperations(t,i);break;default:console.warn(`Unknown operation type: ${e}`);for(const n of t)i.push({operationId:n.id,success:!1,error:`Unknown operation type: ${e}`})}}catch(n){console.error(`Failed to process operation group ${e}:`,n);for(const s of t)i.push({operationId:s.id,success:!1,error:n instanceof Error?n.message:"Unknown error"})}return i}async processCardOperations(e,t){for(const i of e)try{switch(i.operationType){case"create":await f.from("cards").insert(i.data).select().single();break;case"update":await f.from("cards").update(i.data).eq("id",i.entityId);break;case"delete":await f.from("cards").delete().eq("id",i.entityId);break}t.push({operationId:i.id,success:!0})}catch(n){t.push({operationId:i.id,success:!1,error:n instanceof Error?n.message:"Unknown error"})}}async processFolderOperations(e,t){for(const i of e)try{switch(i.operationType){case"create":await f.from("folders").insert(i.data).select().single();break;case"update":await f.from("folders").update(i.data).eq("id",i.entityId);break;case"delete":await f.from("folders").delete().eq("id",i.entityId);break}t.push({operationId:i.id,success:!0})}catch(n){t.push({operationId:i.id,success:!1,error:n instanceof Error?n.message:"Unknown error"})}}async processTagOperations(e,t){for(const i of e)try{switch(i.operationType){case"create":await f.from("tags").insert(i.data).select().single();break;case"update":await f.from("tags").update(i.data).eq("id",i.entityId);break;case"delete":await f.from("tags").delete().eq("id",i.entityId);break}t.push({operationId:i.id,success:!0})}catch(n){t.push({operationId:i.id,success:!1,error:n instanceof Error?n.message:"Unknown error"})}}async getLocalSyncOperations(){return await v.getPendingSyncOperations()}async triggerLocalSyncProcessing(){if(this.syncInProgress){console.log("Sync already in progress, skipping local sync processing");return}await this.processLocalSyncQueue()}async syncFromCloud(){if(!this.authService?.isAuthenticated())return;const e=this.authService.getCurrentUser();if(!e)return;const t=this.lastFullSync||new Date(0),[i,n,s]=await Promise.all([this.getCloudData("cards",e.id,t),this.getCloudData("folders",e.id,t),this.getCloudData("tags",e.id,t)]);await Promise.all([this.mergeCloudCards(i),this.mergeCloudFolders(n),this.mergeCloudTags(s)])}async getCloudData(e,t,i){const n=`${e}_${t}_${i.toISOString()}`;if(this.syncCache.has(n))return this.updateCacheHitRate(!0),this.syncCache.get(n);this.updateCacheHitRate(!1);const s=f.from(e).select("*").eq("user_id",t).gte("updated_at",i.toISOString()),{data:r,error:a}=await s;if(a)throw a;return this.syncCache.set(n,r||[]),r||[]}async mergeCloudCards(e){for(const t of e){const i=await d.cards?.get(t.id);i?await this.resolveCardConflict(i,t):await d.cards?.add(k.fromCloudCard(t))}}async mergeCloudFolders(e){for(const t of e){const i=await d.folders?.get(t.id);i?await this.resolveFolderConflict(i,t):await d.folders?.add(k.fromCloudFolder(t))}}async mergeCloudTags(e){for(const t of e){const i=await d.tags?.get(t.id);i?await this.resolveTagConflict(i,t):await d.tags?.add(k.fromCloudTag(t))}}async detectAndResolveConflicts(){const e=await this.detectConflicts();for(const t of e)await this.resolveConflict(t)}async detectConflicts(){const e=[],t=await this.detectCardConflicts();e.push(...t);const i=await this.detectFolderConflicts();e.push(...i);const n=await this.detectTagConflicts();return e.push(...n),e}async resolveCardConflict(e,t){const i=new Date(e.updatedAt).getTime(),n=new Date(t.updated_at).getTime();n>i?await d.cards?.update(t.id,k.fromCloudCard(t)):i>n&&e.pendingSync&&await this.addOperation({type:"update",entity:"card",entityId:e.id,data:e,priority:"normal",userId:e.userId})}async resolveFolderConflict(e,t){const i=new Date(e.updatedAt).getTime(),n=new Date(t.updated_at).getTime();n>i?await d.folders?.update(t.id,k.fromCloudFolder(t)):i>n&&e.pendingSync&&await this.addOperation({type:"update",entity:"folder",entityId:e.id,data:e,priority:"normal",userId:e.userId})}async resolveTagConflict(e,t){const i=new Date(e.updatedAt).getTime(),n=new Date(t.updated_at).getTime();n>i?await d.tags?.update(t.id,k.fromCloudTag(t)):i>n&&e.pendingSync&&await this.addOperation({type:"update",entity:"tag",entityId:e.id,data:e,priority:"normal",userId:e.userId})}async processSyncQueue(){}async processNextOperations(){if(!this.syncInProgress){this.syncInProgress=!0;try{await C.processNextBatch()}finally{this.syncInProgress=!1}}}async processHighPriorityOperations(){(await C.getOperations({priority:"high",limit:5})).length>0&&await this.processNextOperations()}handleNetworkStateChange(e){this.isOnline=e.isOnline,e.isOnline&&e.canSync&&this.performIncrementalSync(),this.notifyStatusChange()}handleNetworkError(e,t){console.warn("Network error in sync service:",e.message,t),e.type==="connection_lost"&&C.pause()}handleSyncCompleted(e,t){t.success&&(this.metrics.lastSyncTime=new Date)}handleSyncStrategyChanged(e){console.log("Sync strategy changed:",e)}handleOperationComplete(e,t){t?this.updateMetrics({successfulOperations:this.metrics.successfulOperations+1}):this.updateMetrics({failedOperations:this.metrics.failedOperations+1})}handleBatchComplete(e){console.log("Batch sync completed:",e)}handleQueueError(e){console.error("Queue error:",e)}handleQueueStatusChange(e){this.notifyStatusChange()}canSync(){const e=m.getCurrentState();return this.isOnline&&this.authService?.isAuthenticated()&&e.canSync}shouldProcessImmediately(){return this.canSync()&&!this.syncInProgress}shouldPerformBackgroundSync(){return m.getCurrentState().canSync&&!this.syncInProgress&&this.authService?.isAuthenticated()}getAdaptiveSyncInterval(){switch(m.getCurrentState().quality){case"excellent":return 60*1e3;case"good":return 2*60*1e3;case"fair":return 5*60*1e3;case"poor":return 10*60*1e3;default:return 5*60*1e3}}getMaxRetries(e){switch(e){case"high":return 5;case"normal":return 3;case"low":return 1}}getOperationDependencies(e){const t=[];return e.entity==="card"&&e.data.folderId&&t.push(`folder_${e.data.folderId}`),t}updateCacheHitRate(e){const t=this.metrics.totalOperations||1,i=e?this.metrics.cacheHitRate*t+1:this.metrics.cacheHitRate*t;this.updateMetrics({cacheHitRate:i/(t+1)})}updateMetrics(e){this.metrics={...this.metrics,...e}}cleanupCache(){const e=Date.now(),t=5*60*1e3;for(const[i,n]of this.syncCache.entries())e-n.timestamp>t&&this.syncCache.delete(i)}async checkCloudUpdates(){this.lastFullSync&&Date.now()-this.lastFullSync.getTime()>30*60*1e3&&await this.performFullSync()}async verifyDataConsistency(){}setAuthService(e){this.authService=e,e.onAuthStateChange(t=>{t.user&&this.canSync()&&this.performFullSync()})}onStatusChange(e){return this.listeners.add(e),e(this.getCurrentStatus()),()=>{this.listeners.delete(e)}}async notifyStatusChange(){const e=await this.getCurrentStatus();this.listeners.forEach(t=>t(e))}async getCurrentStatus(){const e=m.getCurrentState(),t=await C.getQueueStats();return{isOnline:e.isOnline,lastSyncTime:this.metrics.lastSyncTime,pendingOperations:t.totalOperations,syncInProgress:this.syncInProgress,hasConflicts:this.conflicts.length>0}}async getMetrics(){return{...this.metrics}}async getConflicts(){return[...this.conflicts]}async getOperationHistory(e){let t=[...this.operationHistory];return e?.entity&&(t=t.filter(i=>i.entity===e.entity)),e?.type&&(t=t.filter(i=>i.type===e.type)),e?.limit&&(t=t.slice(0,e.limit)),t}async clearHistory(e){e?this.operationHistory=this.operationHistory.filter(t=>t.timestamp>e):this.operationHistory=[]}async forceSync(){await this.performFullSync()}async pauseSync(){C.pause(),this.syncInProgress=!0}async resumeSync(){C.resume(),this.syncInProgress=!1,this.processNextOperations()}}const ee=new Q,b=Object.freeze(Object.defineProperty({__proto__:null,UnifiedSyncService:Q,unifiedSyncService:ee},Symbol.toStringTag,{value:"Module"}));export{F as a,re as c};
