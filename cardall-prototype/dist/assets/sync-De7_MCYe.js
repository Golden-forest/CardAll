import{c as L,_ as D}from"./supabase-BJjf9Ixn.js";import{D as A}from"./database-CD-G83dI.js";const $="https://elwnpejlwkgdacaugvvd.supabase.co",q="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImVsd25wZWpsd2tnZGFjYXVndnZkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTMzMzkxNTAsImV4cCI6MjA2ODkxNTE1MH0.XhVGgO2nf8uS1gC0V6jTMP0p0xN5KKV47t2rK2ncK90",h=L($,q,{auth:{autoRefreshToken:!0,persistSession:!0,detectSessionInUrl:!0},realtime:{params:{eventsPerSecond:10}}});class Q{listeners=[];currentState={user:null,session:null,loading:!0,error:null};constructor(){this.initialize(),setTimeout(()=>{this.setupSyncService()},0)}setupSyncService(){try{D(async()=>{const{unifiedSyncService:e}=await Promise.resolve().then(()=>T);return{unifiedSyncService:e}},void 0).then(({unifiedSyncService:e})=>{e.setAuthService(this)}).catch(e=>{console.warn("Failed to setup unified sync service:",e)})}catch(e){console.warn("Failed to setup unified sync service:",e)}}async initialize(){try{const{data:{session:e},error:t}=await h.auth.getSession();if(t){this.updateState({error:t.message,loading:!1});return}if(e?.user){const i=await this.fetchUserProfile(e.user.id);this.updateState({user:i,session:e,loading:!1,error:null})}else this.updateState({loading:!1});h.auth.onAuthStateChange(async(i,s)=>{if(console.log("Auth state changed:",i,s?.user?.id),i==="SIGNED_OUT"){try{const{unifiedSyncService:r}=await D(async()=>{const{unifiedSyncService:n}=await Promise.resolve().then(()=>T);return{unifiedSyncService:n}},void 0);await r.clearHistory()}catch(r){console.warn("Failed to clear sync history on signout:",r)}this.updateState({user:null,session:null,loading:!1,error:null})}else if(s?.user){const r=await this.fetchUserProfile(s.user.id);if(this.updateState({user:r,session:s,loading:!1,error:null}),i==="SIGNED_IN")try{const{unifiedSyncService:n}=await D(async()=>{const{unifiedSyncService:a}=await Promise.resolve().then(()=>T);return{unifiedSyncService:a}},void 0);await n.performFullSync()}catch(n){console.warn("Failed to perform full sync after signin:",n)}}else this.updateState({user:null,session:null,loading:!1,error:null})})}catch(e){console.error("Auth initialization failed:",e),this.updateState({error:e instanceof Error?e.message:"Authentication failed",loading:!1})}}async fetchUserProfile(e){try{await new Promise(s=>setTimeout(s,100));const{data:t,error:i}=await h.from("users").select("*").eq("id",e).single();return i?(console.error("Failed to fetch user profile:",i),null):t}catch(t){return console.error("Error fetching user profile:",t),null}}updateState(e){this.currentState={...this.currentState,...e},this.listeners.forEach(t=>t(this.currentState))}onAuthStateChange(e){return this.listeners.push(e),e(this.currentState),()=>{const t=this.listeners.indexOf(e);t>-1&&this.listeners.splice(t,1)}}getCurrentState(){return this.currentState}async signUpWithEmail(e,t,i){try{this.updateState({loading:!0,error:null});const{data:s,error:r}=await h.auth.signUp({email:e,password:t,options:{data:{name:i?.name||e.split("@")[0],full_name:i?.name||e.split("@")[0]}}});return r?(this.updateState({error:r.message,loading:!1}),{error:r}):(this.updateState({loading:!1,error:null}),{error:null})}catch(s){const r=s instanceof Error?s.message:"Registration failed";return this.updateState({error:r,loading:!1}),{error:s}}}async signInWithEmail(e,t){try{this.updateState({loading:!0,error:null});const{error:i}=await h.auth.signInWithPassword({email:e,password:t});return i?(this.updateState({error:i.message,loading:!1}),{error:i}):{error:null}}catch(i){const s=i instanceof Error?i.message:"Login failed";return this.updateState({error:s,loading:!1}),{error:i}}}async resetPassword(e){try{this.updateState({loading:!0,error:null});const{error:t}=await h.auth.resetPasswordForEmail(e,{redirectTo:`${window.location.origin}/auth/reset-password`});return t?(this.updateState({error:t.message,loading:!1}),{error:t}):(this.updateState({loading:!1,error:null}),{error:null})}catch(t){const i=t instanceof Error?t.message:"Password reset failed";return this.updateState({error:i,loading:!1}),{error:t}}}async signInWithGitHub(){try{this.updateState({loading:!0,error:null});const{error:e}=await h.auth.signInWithOAuth({provider:"github",options:{redirectTo:`${window.location.origin}`}});return e?(this.updateState({error:e.message,loading:!1}),{error:e}):{error:null}}catch(e){const t=e instanceof Error?e.message:"Login failed";return this.updateState({error:t,loading:!1}),{error:e}}}async signOut(){try{this.updateState({loading:!0,error:null});const{error:e}=await h.auth.signOut();return e?(this.updateState({error:e.message,loading:!1}),{error:e}):(this.updateState({user:null,session:null,loading:!1,error:null}),{error:null})}catch(e){const t=e instanceof Error?e.message:"Logout failed";return this.updateState({error:t,loading:!1}),{error:e}}}async upsertUserProfile(e){try{if(!this.currentState.session?.user.id)return console.error("No authenticated user found"),null;const{data:t,error:i}=await h.from("users").upsert({id:this.currentState.session.user.id,...e,updated_at:new Date().toISOString()}).select().single();return i?(console.error("Failed to upsert user profile:",i),null):t}catch(t){return console.error("Error upserting user profile:",t),null}}isAuthenticated(){return!!this.currentState.user&&!!this.currentState.session}getCurrentUser(){return this.currentState.user}getCurrentSession(){return this.currentState.session}}const U=new Q;let N=class extends A{cards;folders;tags;images;syncQueue;settings;sessions;constructor(){super("CardAllUnifiedDatabase"),this.version(3).stores({cards:"++id, userId, folderId, createdAt, updatedAt, syncVersion, pendingSync, [userId+folderId], searchVector",folders:"++id, userId, parentId, createdAt, updatedAt, syncVersion, pendingSync, [userId+parentId], fullPath, depth",tags:"++id, userId, name, createdAt, syncVersion, pendingSync, [userId+name]",images:"++id, cardId, userId, createdAt, updatedAt, syncVersion, pendingSync, storageMode, [cardId+userId]",syncQueue:"++id, type, entity, entityId, userId, timestamp, retryCount, priority, [userId+priority]",settings:"++id, key, updatedAt, scope, [key+scope]",sessions:"++id, userId, deviceId, lastActivity, isActive, [userId+deviceId]"}),this.upgradeDatabase()}async upgradeDatabase(){this.version(2).upgrade(async e=>{console.log("Upgrading to version 2: Adding user support...");const t=new _;try{await t.open(),console.log("Found old database, migrating data...");const s=(await t.cards.toArray()).map(c=>({...c,userId:"default",updatedAt:new Date}));await this.cards.bulkAdd(s);const n=(await t.folders.toArray()).map(c=>({...c,userId:"default",updatedAt:new Date}));await this.folders.bulkAdd(n);const o=(await t.tags.toArray()).map(c=>({...c,userId:"default",updatedAt:new Date}));await this.tags.bulkAdd(o),console.log("Migration completed successfully")}catch(i){console.log("No old database found or migration failed:",i)}}),this.version(3).upgrade(async e=>{console.log("Upgrading to version 3: Optimizing indexes and adding new features..."),await this.initializeDefaultSettings(),await this.rebuildSearchIndexes()})}async initializeDefaultSettings(){const e=[{key:"storageMode",value:"hybrid",scope:"global",updatedAt:new Date},{key:"syncEnabled",value:!0,scope:"global",updatedAt:new Date},{key:"imageCompression",value:{enabled:!0,quality:.8,maxWidth:1920,maxHeight:1080,format:"webp"},scope:"global",updatedAt:new Date},{key:"databaseVersion",value:"3.0.0",scope:"global",updatedAt:new Date}];for(const t of e)await this.settings.where("key").equals(t.key).first()||await this.settings.add(t)}async rebuildSearchIndexes(){console.log("Rebuilding search indexes...")}async getSetting(e,t){if(t){const s=await this.settings.where("[key+scope]").equals([e,"user"]).and(r=>!r.userId||r.userId===t).first();if(s)return s.value}return(await this.settings.where("[key+scope]").equals([e,"global"]).first())?.value}async updateSetting(e,t,i="global",s){await this.settings.where("[key+scope]").equals([e,i]).modify({value:t,userId:s,updatedAt:new Date})}async getStats(){const[e,t,i,s,r]=await Promise.all([this.cards.count(),this.folders.count(),this.tags.count(),this.images.count(),this.syncQueue.count()]),n=await this.calculateTotalSize();return{cards:e,folders:t,tags:i,images:s,pendingSync:r,totalSize:n,version:"3.0.0"}}async calculateTotalSize(){return(await this.images.toArray()).reduce((t,i)=>t+i.metadata.size,0)}async createCard(e,t){const i=crypto.randomUUID(),s=new Date;return await this.cards.add({...e,id:i,userId:t,syncVersion:1,pendingSync:!0,updatedAt:s}),i}async updateCard(e,t){return await this.cards.update(e,{...t,syncVersion:t.syncVersion?t.syncVersion+1:void 0,pendingSync:!0,updatedAt:new Date})}async deleteCard(e){await this.transaction("rw",[this.cards,this.images],async()=>{await this.images.where("cardId").equals(e).delete(),await this.cards.delete(e)})}async bulkCreateCards(e,t){const i=new Date,s=e.map(r=>({...r,id:crypto.randomUUID(),userId:t,syncVersion:1,pendingSync:!0,updatedAt:i}));return await this.cards.bulkAdd(s),s.map(r=>r.id)}async getCardsByFolder(e,t){return await this.cards.where("[userId+folderId]").equals([t||"default",e]).toArray()}async searchCards(e,t){const i=e.toLowerCase();return await this.cards.filter(s=>s.searchVector?.includes(i)||s.frontContent.title.toLowerCase().includes(i)||s.frontContent.text.toLowerCase().includes(i)||s.backContent.title.toLowerCase().includes(i)||s.backContent.text.toLowerCase().includes(i)).toArray()}async cleanup(){await this.transaction("rw",[this.cards,this.folders,this.tags,this.images,this.syncQueue],async()=>{const e=new Date(Date.now()-6048e5);await this.syncQueue.where("timestamp").below(e).delete();const t=await this.cards.toCollection().primaryKeys();await this.images.where("cardId").noneOf(t).delete(),console.log("Database cleanup completed")})}async healthCheck(){const e=[];try{await this.tables.toArray();const t=await this.getStats();return t.pendingSync>1e3&&e.push(`High number of pending sync operations: ${t.pendingSync}`),t.totalSize>500*1024*1024&&e.push(`Database size is large: ${(t.totalSize/1024/1024).toFixed(2)} MB`),{isHealthy:e.length===0,issues:e,stats:t}}catch(t){return{isHealthy:!1,issues:[`Database connection failed: ${t}`],stats:{cards:0,folders:0,tags:0,images:0,pendingSync:0,totalSize:0,version:"3.0.0"}}}}async clearAll(){await this.transaction("rw",[this.cards,this.folders,this.tags,this.images,this.syncQueue,this.settings,this.sessions],async()=>{await this.cards.clear(),await this.folders.clear(),await this.tags.clear(),await this.images.clear(),await this.syncQueue.clear(),await this.sessions.clear()})}async getSettingLegacy(e){return await this.getSetting(e)}async updateSettingLegacy(e,t){await this.updateSetting(e,t)}async clearAllLegacy(){await this.transaction("rw",this.cards,this.folders,this.tags,this.images,this.syncQueue,async()=>{await this.cards.clear(),await this.folders.clear(),await this.tags.clear(),await this.images.clear(),await this.syncQueue.clear()})}async getStatsLegacy(){const e=await this.getStats();return{cards:e.cards,folders:e.folders,tags:e.tags,images:e.images,pendingSync:e.pendingSync}}},_=class extends A{cards;folders;tags;images;syncQueue;settings;constructor(){super("CardAllDatabase"),this.version(1).stores({cards:"++id, folderId, createdAt, updatedAt, syncVersion, pendingSync",folders:"++id, parentId, createdAt, updatedAt, syncVersion, pendingSync",tags:"++id, name, createdAt, syncVersion, pendingSync",images:"++id, cardId, filePath, createdAt, syncVersion, pendingSync",syncQueue:"++id, type, entity, entityId, timestamp, retryCount",settings:"++id, key, updatedAt"})}};const u=new N,R=new Map,E=5*60*1e3;setInterval(()=>{const p=Date.now();for(const[e,t]of R.entries())p-t.timestamp>E&&R.delete(e)},E);const V={maxRetries:5,initialRetryDelay:1e3,maxRetryDelay:3e5,retryBackoffMultiplier:2,batchSize:10,batchTimeout:5e3,maxConcurrentBatches:3,processingTimeout:3e4,idleCheckInterval:1e4,cleanupInterval:3e5,networkAware:!0,offlineMode:!0,requireWifiForLargeFiles:!0,maxQueueSize:1e4,maxAge:7*24*60*60*1e3};class H{config;isProcessing=!1;processingTimer=null;cleanupTimer=null;currentBatches=new Map;listeners={};constructor(e={}){this.config={...V,...e},this.initialize()}async initialize(){try{await u.open(),await this.restoreQueueFromStorage(),this.startProcessing(),this.startCleanup(),console.log("LocalOperationService initialized successfully")}catch(e){console.error("Failed to initialize LocalOperationService:",e)}}async restoreQueueFromStorage(){try{const e=localStorage.getItem("syncQueue");if(e){const t=JSON.parse(e);for(const i of t){const s=this.convertOperationFormat(i);try{await u.syncQueue.add(s)}catch{console.warn("Operation already exists in database, skipping:",i.id)}}localStorage.removeItem("syncQueue"),console.log(`Restored ${t.length} operations from local storage`)}}catch(e){console.error("Failed to restore queue from storage:",e)}}convertOperationFormat(e){return e.entityType&&e.operationType&&e.entityId?e:{id:e.id,entityType:e.table==="cards"?"card":e.table==="folders"?"folder":e.table==="tags"?"tag":"image",operationType:e.type,entityId:e.localId,data:e.data,timestamp:e.timestamp,retryCount:e.retryCount||0,status:e.status||"pending",localVersion:e.localVersion||1,priority:e.priority||"normal",dependsOn:e.dependsOn||[]}}async addOperation(e){if(!e.entityId||e.entityId.trim()==="")throw new Error("Local ID is required");if(!e.entityType||!["card","folder","tag","image"].includes(e.entityType))throw new Error("Invalid entity type");if(!e.operationType||!["create","update","delete"].includes(e.operationType))throw new Error("Invalid operation type");if(!e.data)throw new Error("Operation data is required");const t=crypto.randomUUID(),i=new Date,s={...e,id:t,timestamp:i,retryCount:0,status:"pending",localVersion:Date.now(),retryDelay:this.config.initialRetryDelay,maxRetries:this.config.maxRetries};this.config.networkAware&&(s.networkInfo=await this.getNetworkInfo());const r=await u.syncQueue.where("entityId").equals(e.entityId).and(n=>n.entityType===e.entityType&&n.status==="pending").first();try{return r?(await u.syncQueue.update(r.id,{data:e.data,previousData:e.previousData,timestamp:i,localVersion:Date.now()}),console.log(`Operation updated in queue: ${r.id}`),r.id):(await u.syncQueue.add(s),this.notifyListeners("operationAdded",s),await this.updateQueueStats(),console.log(`Operation added to queue: ${t}`),t)}catch(n){throw console.error("Failed to add operation to queue:",n),n}}async getPendingOperations(e=this.config.batchSize,t){try{let i=u.syncQueue.where("status").equals("pending").orderBy("priority").reverse();t&&t.length>0&&(i=i.filter(n=>t.includes(n.priority)));const s=await i.limit(e).toArray();return await this.filterReadyOperations(s)}catch(i){return console.error("Failed to get pending operations:",i),[]}}async markOperationProcessing(e){try{await u.syncQueue.update(e,{status:"processing",processingStartedAt:new Date})}catch(t){console.error(`Failed to mark operation ${e} as processing:`,t)}}async markOperationCompleted(e){try{const t=await u.syncQueue.get(e);if(!t)return;await u.syncQueue.update(e,{status:"completed",processingEndedAt:new Date}),this.notifyListeners("operationCompleted",t),await this.updateQueueStats()}catch(t){console.error(`Failed to mark operation ${e} as completed:`,t)}}async markOperationFailed(e,t){try{const i=await u.syncQueue.get(e);if(!i)return;const s=i.retryCount+1,r=Math.min(i.retryDelay*this.config.retryBackoffMultiplier,this.config.maxRetryDelay),n={retryCount:s,retryDelay:r,lastError:t.message};s>=i.maxRetries?n.status="failed":n.status="pending",await u.syncQueue.update(e,n),this.notifyListeners("operationFailed",i,t),await this.updateQueueStats()}catch(i){console.error(`Failed to mark operation ${e} as failed:`,i)}}async cancelOperation(e,t){try{const i=await u.syncQueue.get(e);if(!i)return;await u.syncQueue.update(e,{status:"cancelled",lastError:t||"Cancelled by user"}),this.notifyListeners("operationFailed",i,new Error(t||"Operation cancelled")),await this.updateQueueStats()}catch(i){console.error(`Failed to cancel operation ${e}:`,i)}}startProcessing(){this.processingTimer&&clearInterval(this.processingTimer),this.processingTimer=setInterval(async()=>{this.isProcessing||await this.processQueue()},this.config.idleCheckInterval)}async processQueue(){if(!(this.isProcessing||this.currentBatches.size>=this.config.maxConcurrentBatches)){this.isProcessing=!0;try{const e=await this.getPendingOperations();if(e.length===0)return;const t=await this.createBatches(e);for(const i of t){const s=crypto.randomUUID(),r=this.processBatch(i,s);this.currentBatches.set(s,r),r.catch(n=>{console.error(`Batch ${s} failed:`,n)}).finally(()=>{this.currentBatches.delete(s)})}}catch(e){console.error("Error processing queue:",e)}finally{this.isProcessing=!1}}}async createBatches(e){const t=[];let i=[];const s=[...e].sort((r,n)=>{const a={critical:4,high:3,normal:2,low:1};return a[n.priority]-a[r.priority]});for(const r of s)i.length>=this.config.batchSize&&(t.push(i),i=[]),!(this.config.requireWifiForLargeFiles&&r.entityType==="image"&&(await this.getNetworkInfo()).connectionType!=="wifi")&&i.push(r);return i.length>0&&t.push(i),t}async processBatch(e,t){try{await Promise.all(e.map(i=>this.markOperationProcessing(i.id))),e.forEach(i=>{this.notifyListeners("operationStarted",i)}),await this.executeBatchSync(e,t),await Promise.all(e.map(i=>this.markOperationCompleted(i.id))),console.log(`Batch ${t} processed successfully (${e.length} operations)`)}catch(i){console.error(`Batch ${t} failed:`,i),await Promise.all(e.map(s=>this.markOperationFailed(s.id,i)))}}async executeBatchSync(e,t){try{const{unifiedSyncService:i}=await D(async()=>{const{unifiedSyncService:r}=await Promise.resolve().then(()=>T);return{unifiedSyncService:r}},void 0),s=this.groupOperationsByType(e);for(const[r,n]of Object.entries(s))await this.processEntityGroup(r,n,i);console.log(`Batch ${t} sync execution completed`)}catch(i){throw console.error(`Batch ${t} sync execution failed:`,i),i}}groupOperationsByType(e){const t={};for(const i of e)t[i.entityType]||(t[i.entityType]=[]),t[i.entityType].push(i);return t}async processEntityGroup(e,t,i){switch(e){case"card":await this.processCardOperations(t,i);break;case"folder":await this.processFolderOperations(t,i);break;case"tag":await this.processTagOperations(t,i);break;case"image":await this.processImageOperations(t,i);break;default:console.warn(`Unknown entity type: ${e}`)}}async processCardOperations(e,t){for(const i of e)try{switch(i.operationType){case"create":await t.addOperation({type:"create",entity:"card",entityId:i.entityId,data:i.data,priority:i.priority,userId:i.userId});break;case"update":await t.addOperation({type:"update",entity:"card",entityId:i.entityId,data:i.data,priority:i.priority,userId:i.userId});break;case"delete":await t.addOperation({type:"delete",entity:"card",entityId:i.entityId,data:{userId:i.userId},priority:i.priority,userId:i.userId});break}}catch(s){throw console.error(`Failed to process card operation ${i.id}:`,s),s}}async processFolderOperations(e,t){for(const i of e)try{switch(i.operationType){case"create":await t.addOperation({type:"create",entity:"folder",entityId:i.entityId,data:i.data,priority:i.priority,userId:i.userId});break;case"update":await t.addOperation({type:"update",entity:"folder",entityId:i.entityId,data:i.data,priority:i.priority,userId:i.userId});break;case"delete":await t.addOperation({type:"delete",entity:"folder",entityId:i.entityId,data:{userId:i.userId},priority:i.priority,userId:i.userId});break}}catch(s){throw console.error(`Failed to process folder operation ${i.id}:`,s),s}}async processTagOperations(e,t){for(const i of e)try{switch(i.operationType){case"create":await t.addOperation({type:"create",entity:"tag",entityId:i.entityId,data:i.data,priority:i.priority,userId:i.userId});break;case"update":await t.addOperation({type:"update",entity:"tag",entityId:i.entityId,data:i.data,priority:i.priority,userId:i.userId});break;case"delete":await t.addOperation({type:"delete",entity:"tag",entityId:i.entityId,data:{userId:i.userId},priority:i.priority,userId:i.userId});break}}catch(s){throw console.error(`Failed to process tag operation ${i.id}:`,s),s}}async processImageOperations(e,t){for(const i of e)try{switch(i.operationType){case"create":await t.addOperation({type:"create",entity:"image",entityId:i.entityId,data:i.data,priority:i.priority,userId:i.userId});break;case"update":await t.addOperation({type:"update",entity:"image",entityId:i.entityId,data:i.data,priority:i.priority,userId:i.userId});break;case"delete":await t.addOperation({type:"delete",entity:"image",entityId:i.entityId,data:{userId:i.userId},priority:i.priority,userId:i.userId});break}}catch(s){throw console.error(`Failed to process image operation ${i.id}:`,s),s}}startCleanup(){this.cleanupTimer&&clearInterval(this.cleanupTimer),this.cleanupTimer=setInterval(async()=>{await this.cleanupQueue()},this.config.cleanupInterval)}async cleanupQueue(){try{const e=Date.now(),t=new Date(e-this.config.maxAge);await u.syncQueue.where("timestamp").below(t).delete();const i=await u.syncQueue.where("status").equals("completed").orderBy("timestamp").reverse().offset(1e3).toArray();i.length>0&&await u.syncQueue.bulkDelete(i.map(r=>r.id));const s=await u.syncQueue.count();if(s>this.config.maxQueueSize){const r=s-this.config.maxQueueSize,n=await u.syncQueue.orderBy("timestamp").limit(r).toArray();await u.syncQueue.bulkDelete(n.map(a=>a.id))}console.log("Queue cleanup completed")}catch(e){console.error("Queue cleanup failed:",e)}}async getNetworkInfo(){if(!("connection"in navigator))return{online:navigator.onLine,connectionType:"none",effectiveType:"4g"};const e=navigator.connection;return{online:navigator.onLine,connectionType:this.getConnectionType(e),effectiveType:e.effectiveType||"4g",rtt:e.rtt,downlink:e.downlink}}getConnectionType(e){if(!e)return"none";switch(e.type){case"wifi":case"ethernet":return"wifi";case"cellular":case"bluetooth":return"cellular";default:return"none"}}async filterReadyOperations(e){const t=[];for(const i of e){if(!i.dependsOn||i.dependsOn.length===0){t.push(i);continue}(await u.syncQueue.where("id").anyOf(i.dependsOn).toArray()).every(n=>n.status==="completed")&&t.push(i)}return t}async getQueueStats(){try{const e=await u.syncQueue.toArray(),t={totalOperations:e.length,pendingOperations:0,processingOperations:0,failedOperations:0,completedOperations:0,byType:{card:0,folder:0,tag:0,image:0},byPriority:{critical:0,high:0,normal:0,low:0},byStatus:{pending:0,processing:0,completed:0,failed:0,cancelled:0},averageProcessingTime:0,failureRate:0,oldestPendingAge:0,averageRetryCount:0};for(const n of e){if(t.byType[n.entityType]++,t.byPriority[n.priority]++,t.byStatus[n.status]++,n.status==="completed"&&n.processingStartedAt){const a=n.timestamp.getTime()-n.processingStartedAt.getTime();t.averageProcessingTime+=a}t.averageRetryCount+=n.retryCount}t.pendingOperations=t.byStatus.pending,t.processingOperations=t.byStatus.processing,t.failedOperations=t.byStatus.failed,t.completedOperations=t.byStatus.completed;const i=t.byStatus.completed;i>0&&(t.averageProcessingTime/=i),e.length>0&&(t.averageRetryCount/=e.length);const s=e.filter(n=>["completed","failed"].includes(n.status)).length;s>0&&(t.failureRate=t.failedOperations/s);const r=e.filter(n=>n.status==="pending");if(r.length>0){const n=r.reduce((o,c)=>{const l=typeof o.timestamp=="string"?new Date(o.timestamp).getTime():o.timestamp.getTime();return(typeof c.timestamp=="string"?new Date(c.timestamp).getTime():c.timestamp.getTime())<l?c:o}),a=typeof n.timestamp=="string"?new Date(n.timestamp).getTime():n.timestamp.getTime();t.oldestPendingAge=Date.now()-a}return t}catch(e){return console.error("Failed to get queue stats:",e),this.getEmptyStats()}}getEmptyStats(){return{totalOperations:0,pendingOperations:0,processingOperations:0,failedOperations:0,completedOperations:0,byType:{card:0,folder:0,tag:0,image:0},byPriority:{critical:0,high:0,normal:0,low:0},byStatus:{pending:0,processing:0,completed:0,failed:0,cancelled:0},averageProcessingTime:0,failureRate:0,oldestPendingAge:0,averageRetryCount:0}}async updateQueueStats(){try{const e=await this.getQueueStats();this.notifyListeners("queueStatsChanged",e)}catch(e){console.error("Failed to update queue stats:",e)}}addEventListener(e,t){this.listeners[e]=t}removeEventListener(e){delete this.listeners[e]}notifyListeners(e,...t){const i=this.listeners[e];if(i)try{i(...t)}catch(s){console.error(`Error in ${e} listener:`,s)}}async clearQueue(){try{await u.syncQueue.clear(),await this.updateQueueStats(),console.log("Queue cleared successfully")}catch(e){console.error("Failed to clear queue:",e)}}async getOperation(e){try{return await u.syncQueue.get(e)}catch(t){console.error(`Failed to get operation ${e}:`,t);return}}async removeOperation(e){try{await u.syncQueue.delete(e),await this.updateQueueStats()}catch(t){throw console.error(`Failed to remove operation ${e}:`,t),t}}async retryFailedOperations(){try{const e=await u.syncQueue.where("status").equals("failed").toArray();for(const t of e)await u.syncQueue.update(t.id,{status:"pending",retryCount:0,retryDelay:this.config.initialRetryDelay,lastError:void 0});return await this.updateQueueStats(),console.log(`Retried ${e.length} failed operations`),e.length}catch(e){return console.error("Failed to retry failed operations:",e),0}}async clearCompletedOperations(){try{const e=await u.syncQueue.where("status").equals("completed").toArray(),i=e.slice(0,-100);for(const s of i)await u.syncQueue.delete(s.id);return await this.updateQueueStats(),console.log(`Cleared ${i.length} completed operations, kept ${e.length-i.length} recent ones`),i.length}catch(e){return console.error("Failed to clear completed operations:",e),0}}updateConfig(e){if(e.maxRetries!==void 0&&e.maxRetries<0)throw new Error("maxRetries must be non-negative");if(e.batchSize!==void 0&&e.batchSize<=0)throw new Error("batchSize must be positive");if(e.maxQueueSize!==void 0&&e.maxQueueSize<0)throw new Error("maxQueueSize must be non-negative");if(e.processingTimeout!==void 0&&e.processingTimeout<=0)throw new Error("processingTimeout must be positive");if(e.idleCheckInterval!==void 0&&e.idleCheckInterval<=0)throw new Error("idleCheckInterval must be positive");this.config={...this.config,...e},e.idleCheckInterval!==void 0&&this.startProcessing(),e.cleanupInterval!==void 0&&this.startCleanup(),console.log("LocalOperationService config updated")}destroy(){this.processingTimer&&clearInterval(this.processingTimer),this.cleanupTimer&&clearInterval(this.cleanupTimer),Promise.all(this.currentBatches.values()).then(()=>{console.log("LocalOperationService destroyed")})}}const I=new H,j={checkInterval:5e3,qualityCheckInterval:3e4,healthCheckInterval:6e4,qualityThresholds:{excellent:{rtt:100,downlink:10},good:{rtt:200,downlink:5},fair:{rtt:500,downlink:1},poor:{rtt:1e3,downlink:.1}},healthCheck:{enabled:!0,endpoints:["https://www.google.com","https://www.cloudflare.com","https://www.github.com"],timeout:5e3,successThreshold:2},eventFilter:{minQualityChange:.1,debounceTime:1e3},adaptiveSync:{enabled:!0,qualityThreshold:.4,maxBatchSize:50,minBatchSize:1,stabilityWindow:5*60*1e3},circuitBreaker:{enabled:!0,failureThreshold:5,recoveryTimeout:6e4,halfOpenTimeout:3e4},performance:{enablePrediction:!0,predictionWindow:30*60*1e3,enableCompression:!0,enableCaching:!0,cacheSize:1e3}};class O{static instance=null;config;currentStatus;previousStatus=null;listeners=new Set;eventQueue=[];debounceTimer=null;baseDetector=null;healthChecker=null;checkTimer=null;qualityTimer=null;healthTimer=null;predictionTimer=null;stats;eventHistory=[];qualityHistory=[];circuitBreakers=new Map;currentStrategy;statusCache=new Map;isInitialized=!1;isMonitoring=!1;isDestroyed=!1;constructor(e={}){this.config={...j,...e},this.currentStatus=this.getInitialStatus(),this.stats=this.getInitialStats(),this.currentStrategy=this.calculateOptimalStrategy(this.currentStatus),this.initialize()}static getInstance(e){return(!O.instance||O.instance.isDestroyed)&&(O.instance=new O(e)),O.instance}initialize(){if(!this.isInitialized)try{this.initializeBaseDetector(),this.initializeHealthChecker(),this.setupEventListeners(),this.initializeCircuitBreakers(),this.initializeCache(),this.isInitialized=!0,console.log("NetworkManager initialized successfully")}catch(e){throw console.error("Failed to initialize NetworkManager:",e),e}}initializeBaseDetector(){typeof navigator<"u"&&(window.addEventListener("online",this.handleBrowserOnline.bind(this)),window.addEventListener("offline",this.handleBrowserOffline.bind(this)),"connection"in navigator&&navigator.connection.addEventListener("change",this.handleConnectionChange.bind(this)))}initializeHealthChecker(){}setupEventListeners(){}initializeCircuitBreakers(){["sync","upload","download","health-check"].forEach(t=>{this.circuitBreakers.set(t,{state:"closed",failureCount:0,lastFailureTime:null,nextAttemptTime:null,config:this.config.circuitBreaker})})}initializeCache(){this.statusCache.clear()}getInitialStatus(){const e=new Date;return{isOnline:typeof navigator<"u"?navigator.onLine:!0,isReliable:!1,connectionType:"unknown",effectiveType:"unknown",quality:"offline",qualityScore:0,canSync:!1,syncStrategy:this.getDefaultStrategy(),estimatedSyncTime:0,lastUpdated:e,features:this.getNetworkFeatures(),recommendations:[]}}getDefaultStrategy(){return{batchSize:10,batchDelay:1e3,connectTimeout:5e3,requestTimeout:3e4,totalTimeout:12e4,maxRetries:3,retryDelay:1e3,retryBackoffMultiplier:2,compressionEnabled:!0,prioritySyncEnabled:!0,backgroundSyncEnabled:!0,circuitBreakerEnabled:!0,failureThreshold:5,recoveryTimeout:6e4}}getInitialStats(){return{connectionChanges:0,onlineTime:0,offlineTime:0,avgOnlineDuration:0,averageQuality:0,qualityHistory:[],averageRtt:0,averageDownlink:0,averageJitter:0,totalSyncOperations:0,successfulSyncs:0,failedSyncs:0,averageSyncTime:0,errorCount:0,circuitBreakerTrips:0,averageRecoveryTime:0}}getNetworkFeatures(){return{connectionInfo:!!navigator.connection,saveData:!!navigator.connection?.saveData,backgroundSync:"serviceWorker"in navigator&&"SyncManager"in window,serviceWorker:"serviceWorker"in navigator,indexedDB:"indexedDB"in window,onlineEvents:typeof window<"u"}}startMonitoring(){this.isMonitoring||this.isDestroyed||(this.isMonitoring=!0,this.startPeriodicChecks(),this.checkNetworkStatus().catch(console.error),console.log("Network monitoring started"),this.emitEvent({type:"connection-change",timestamp:new Date,currentState:this.currentStatus,details:{action:"monitoring_started"}}))}stopMonitoring(){!this.isMonitoring||this.isDestroyed||(this.isMonitoring=!1,this.stopPeriodicChecks(),console.log("Network monitoring stopped"),this.emitEvent({type:"connection-change",timestamp:new Date,currentState:this.currentStatus,details:{action:"monitoring_stopped"}}))}getCurrentStatus(){return{...this.currentStatus}}getSyncStrategy(){return{...this.currentStrategy}}getStats(){return{...this.stats}}async checkNetworkStatus(){if(this.isDestroyed)return this.currentStatus;try{const e=await this.performNetworkCheck();return await this.updateNetworkStatus(e),e}catch(e){return console.error("Network status check failed:",e),this.recordError("check_failed",e),this.currentStatus}}async waitForOnline(e=6e4){return this.currentStatus.isOnline?!0:new Promise(t=>{const i=setTimeout(()=>{r(),t(!1)},e),s={onNetworkStateChanged:n=>{n.isOnline&&(r(),t(!0))}},r=()=>{clearTimeout(i),this.removeListener(s)};this.addListener(s)})}async getNetworkPrediction(){return this.config.performance.enablePrediction?this.performNetworkPrediction():{isStable:this.currentStatus.isOnline,confidence:.5,predictedDuration:300,predictedQuality:this.currentStatus.quality,recommendations:["预测功能未启用"],riskFactors:[]}}addListener(e){this.isDestroyed||this.listeners.add(e)}removeListener(e){this.listeners.delete(e)}async performNetworkCheck(){const e=Date.now();try{const t=navigator.onLine,i=this.getNetworkInfo();let s=t;this.config.healthCheck.enabled&&t&&(s=await this.performHealthCheck());const r=await this.assessNetworkQuality(),n={isOnline:t&&s,isReliable:this.calculateReliability(i,r),connectionType:i.connectionType,effectiveType:i.effectiveType,quality:r.quality,qualityScore:r.score,downlink:i.downlink,rtt:i.rtt,jitter:r.jitter,packetLoss:r.packetLoss,saveData:i.saveData,deviceMemory:i.deviceMemory,hardwareConcurrency:i.hardwareConcurrency,canSync:this.canPerformSync(t&&s,r),syncStrategy:this.calculateOptimalStrategy({...this.currentStatus,...r}),estimatedSyncTime:this.estimateSyncTime(i,r),lastUpdated:new Date,lastStableTime:t&&s?new Date:this.currentStatus.lastStableTime,features:this.getNetworkFeatures(),recommendations:this.generateRecommendations(r,i)},a=Date.now()-e;return this.recordPerformanceMetrics(a),n}catch(t){return console.error("Network check failed:",t),{...this.currentStatus,isOnline:!1,isReliable:!1,quality:"offline",qualityScore:0,canSync:!1,lastUpdated:new Date,recommendations:["网络检测失败，使用保守策略"]}}}getNetworkInfo(){const e=navigator.connection;return{connectionType:e?.type||"unknown",effectiveType:e?.effectiveType||"unknown",downlink:e?.downlink,rtt:e?.rtt,saveData:e?.saveData,deviceMemory:navigator.deviceMemory,hardwareConcurrency:navigator.hardwareConcurrency}}async assessNetworkQuality(){try{let e=.5;const t=navigator.connection?.rtt;t!==void 0&&(t<=100?e+=.3:t<=200?e+=.2:t<=500&&(e+=.1));const i=navigator.connection?.downlink;i!==void 0&&(i>=10?e+=.3:i>=5?e+=.2:i>=1&&(e+=.1));const s=navigator.connection?.type;(s==="wifi"||s==="ethernet")&&(e+=.1),navigator.connection?.saveData&&(e-=.1),e=Math.max(0,Math.min(1,e));let r;e>=.8?r="excellent":e>=.6?r="good":e>=.4?r="fair":e>=.2?r="poor":r="offline";let n,a;if(this.config.performance.enablePrediction&&e>.3){const o=await this.performAdvancedQualityCheck();n=o.jitter,a=o.packetLoss,n>100&&(e-=.1),a>.1&&(e-=.2)}return{quality:r,score:Math.max(0,Math.min(1,e)),jitter:n,packetLoss:a}}catch(e){return console.warn("Quality assessment failed:",e),{quality:"fair",score:.5}}}async performAdvancedQualityCheck(){return{}}async performHealthCheck(){if(!this.config.healthCheck.enabled||this.config.healthCheck.endpoints.length===0)return!0;try{const e=this.config.healthCheck.endpoints.map(s=>this.pingEndpoint(s,this.config.healthCheck.timeout));return(await Promise.allSettled(e)).filter(s=>s.status==="fulfilled"&&s.value).length>=this.config.healthCheck.successThreshold}catch(e){return console.warn("Health check failed:",e),!1}}async pingEndpoint(e,t){try{const i=new AbortController,s=setTimeout(()=>i.abort(),t),r=await fetch(`${e}/favicon.ico`,{method:"HEAD",signal:i.signal,mode:"no-cors",headers:{"Cache-Control":"no-cache",Pragma:"no-cache"}});return clearTimeout(s),!0}catch{return!1}}async updateNetworkStatus(e){this.previousStatus={...this.currentStatus},this.currentStatus=e,this.updateStats(),this.hasSignificantChange(this.previousStatus,e)&&(await this.handleStatusChange(),this.updateSyncStrategy(),e.canSync&&this.config.adaptiveSync.enabled&&this.emitEvent({type:"sync-ready",timestamp:new Date,currentState:e,severity:"info"}))}hasSignificantChange(e,t){return e.isOnline!==t.isOnline||e.isReliable!==t.isReliable||e.quality!==t.quality||Math.abs(e.qualityScore-t.qualityScore)>=this.config.eventFilter.minQualityChange||e.canSync!==t.canSync}async handleStatusChange(){const t={type:this.determineEventType(),timestamp:new Date,previousState:this.previousStatus||void 0,currentState:this.currentStatus,details:this.getEventDetails(),severity:this.determineEventSeverity()};this.eventHistory.push(t),this.eventHistory.length>1e3&&(this.eventHistory=this.eventHistory.slice(-500)),this.debouncedEmitEvent(t),await this.notifyStatusChange(),this.currentStatus.isOnline&&this.previousStatus?.isOnline===!1&&this.resetAllCircuitBreakers()}determineEventType(){return this.previousStatus?this.previousStatus.isOnline!==this.currentStatus.isOnline?this.currentStatus.isOnline?"online":"offline":this.previousStatus.quality!==this.currentStatus.quality?"quality-change":"connection-change":"connection-change"}getEventDetails(){const e={};return this.previousStatus&&(e.qualityChange=this.currentStatus.qualityScore-this.previousStatus.qualityScore,e.rttChange=(this.currentStatus.rtt||0)-(this.previousStatus.rtt||0),e.downlinkChange=(this.currentStatus.downlink||0)-(this.previousStatus.downlink||0)),e}determineEventSeverity(){return this.currentStatus.isOnline?!this.currentStatus.isReliable||this.currentStatus.quality==="poor"?"warning":"info":"error"}debouncedEmitEvent(e){this.config.eventFilter.debounceTime>0?(this.debounceTimer&&clearTimeout(this.debounceTimer),this.debounceTimer=setTimeout(()=>{this.emitEvent(e)},this.config.eventFilter.debounceTime)):this.emitEvent(e)}emitEvent(e){this.listeners.forEach(t=>{try{t.onNetworkEvent&&t.onNetworkEvent(e)}catch(i){console.error("Error in network event listener:",i)}})}async notifyStatusChange(){const e=this.getCurrentStatus();this.listeners.forEach(t=>{try{t.onNetworkStateChanged&&t.onNetworkStateChanged(e)}catch(i){console.error("Error in network state listener:",i)}})}calculateOptimalStrategy(e){const t=this.getDefaultStrategy();switch(e.quality){case"excellent":return{...t,batchSize:Math.min(this.config.adaptiveSync.maxBatchSize,50),batchDelay:500,requestTimeout:1e4,retryDelay:500,compressionEnabled:!1,maxRetries:2};case"good":return{...t,batchSize:25,batchDelay:1e3,requestTimeout:2e4,retryDelay:1e3,compressionEnabled:!1};case"fair":return{...t,batchSize:10,batchDelay:2e3,requestTimeout:3e4,compressionEnabled:!0,maxRetries:4};case"poor":return{...t,batchSize:Math.max(this.config.adaptiveSync.minBatchSize,5),batchDelay:5e3,requestTimeout:6e4,retryDelay:2e3,compressionEnabled:!0,maxRetries:6,circuitBreakerEnabled:!0};default:return{...t,batchSize:1,batchDelay:1e4,requestTimeout:12e4,retryDelay:5e3,compressionEnabled:!0,maxRetries:10}}}updateSyncStrategy(){const e=this.calculateOptimalStrategy(this.currentStatus);this.hasStrategyChanged(this.currentStrategy,e)&&(this.currentStrategy=e,this.currentStatus.syncStrategy=e,this.listeners.forEach(t=>{try{t.onSyncReady&&t.onSyncReady(e)}catch(i){console.error("Error in sync strategy listener:",i)}}))}hasStrategyChanged(e,t){return e.batchSize!==t.batchSize||e.batchDelay!==t.batchDelay||e.requestTimeout!==t.requestTimeout||e.compressionEnabled!==t.compressionEnabled||e.maxRetries!==t.maxRetries}calculateReliability(e,t){if(!this.currentStatus.isOnline)return!1;const i=this.calculateReliabilityFactors(e,t);return this.calculateOverallReliabilityScore(i)>=.6}calculateReliabilityFactors(e,t){const i=this.currentStatus.isOnline?1:0,s=t.score;let r=1;e.rtt&&(e.rtt<=100?r=1:e.rtt<=300?r=.8:e.rtt<=1e3?r=.6:r=.3);const n=this.calculateNetworkStability();let a=1;return t.packetLoss!==void 0&&(a=Math.max(0,1-t.packetLoss*10)),{connectivity:i,quality:s,latency:r,stability:n,packetLoss:a}}calculateOverallReliabilityScore(e){const t={connectivity:.35,quality:.25,latency:.2,stability:.15,packetLoss:.05};return e.connectivity*t.connectivity+e.quality*t.quality+e.latency*t.latency+e.stability*t.stability+e.packetLoss*t.packetLoss}calculateNetworkStability(){const e=Date.now(),t=this.config.adaptiveSync.stabilityWindow,i=this.eventHistory.filter(s=>e-s.timestamp.getTime()<t&&["online","offline","quality-change"].includes(s.type)).length;return i===0?1:i<=2?.8:i<=5?.6:i<=10?.4:.2}canPerformSync(e,t){if(!e||t.score<this.config.adaptiveSync.qualityThreshold)return!1;const i=this.circuitBreakers.get("sync");return!(i&&i.state==="open")}estimateSyncTime(e,t){if(!this.currentStatus.isOnline)return 1/0;const i=1e3,s=e.rtt?Math.max(1,e.rtt/100):1,r=e.downlink?Math.max(.5,5/e.downlink):2,n=Math.max(.5,2-t.score);return i*s*r*n}checkCircuitBreaker(e){const t=this.circuitBreakers.get(e);if(!t||!this.config.circuitBreaker.enabled)return!0;const i=t;return i.state==="open"?Date.now()>=(i.nextAttemptTime||0)?(i.state="half_open",console.log(`Circuit breaker for ${e} moved to half-open state`),!0):!1:i.state!=="open"}recordSuccess(e){const t=this.circuitBreakers.get(e);t&&(t.failureCount=0,t.state="closed",t.lastFailureTime=null,t.nextAttemptTime=null)}recordFailure(e,t){const i=this.circuitBreakers.get(e);!i||!this.config.circuitBreaker.enabled||(i.failureCount++,i.lastFailureTime=new Date,i.failureCount>=this.config.circuitBreaker.failureThreshold&&(i.state="open",i.nextAttemptTime=new Date(Date.now()+this.config.circuitBreaker.recoveryTimeout),this.stats.circuitBreakerTrips++,console.log(`Circuit breaker for ${e} tripped: ${i.failureCount} failures`),setTimeout(()=>{i.state==="open"&&(i.state="half_open",console.log(`Circuit breaker for ${e} moved to half-open state`))},this.config.circuitBreaker.halfOpenTimeout)))}resetCircuitBreaker(e){const t=this.circuitBreakers.get(e);t&&(t.failureCount=0,t.state="closed",t.lastFailureTime=null,t.nextAttemptTime=null)}resetAllCircuitBreakers(){this.circuitBreakers.forEach((e,t)=>{this.resetCircuitBreaker(t)})}async performNetworkPrediction(){const e=Date.now(),t=this.config.performance.predictionWindow,i=this.eventHistory.filter(c=>e-c.timestamp.getTime()<=t);if(i.length<5)return{isStable:this.currentStatus.isOnline,confidence:.3,predictedDuration:300,predictedQuality:this.currentStatus.quality,recommendations:["数据不足，建议监控网络状态"],riskFactors:["历史数据不足"]};const s=this.analyzeNetworkStability(i),r=this.analyzeQualityTrend(),n=this.generatePrediction(s,r),a=this.generateSmartRecommendations(n,i),o=this.identifyRiskFactors(i);return{...n,recommendations:a,riskFactors:o}}analyzeNetworkStability(e){const t=e.filter(l=>l.type==="online"),i=e.filter(l=>l.type==="offline"),s=this.calculateOnlineDurations(e),r=s.length>0?s.reduce((l,y)=>l+y,0)/s.length:0,n=t.length+i.length,a=e.length>0?e[e.length-1].timestamp.getTime()-e[0].timestamp.getTime():0,o=a>0?n/a*6e4:0;let c=1;return o>2&&(c-=.3),r<5*60*1e3&&(c-=.2),i.length>t.length&&(c-=.4),{stabilityScore:Math.max(0,c),avgOnlineDuration:r,changeFrequency:o}}calculateOnlineDurations(e){const t=[];let i=null;for(const s of e)s.type==="online"&&i===null?i=s.timestamp.getTime():s.type==="offline"&&i!==null&&(t.push(s.timestamp.getTime()-i),i=null);return i!==null&&t.push(Date.now()-i),t}analyzeQualityTrend(){if(this.qualityHistory.length<3)return"stable";const e=this.qualityHistory.slice(-3).map(n=>n.score),t=this.qualityHistory.slice(-6,-3).map(n=>n.score);if(t.length===0)return"stable";const i=e.reduce((n,a)=>n+a,0)/e.length,s=t.reduce((n,a)=>n+a,0)/t.length,r=i-s;return r>.1?"improving":r<-.1?"degrading":"stable"}generatePrediction(e,t){const i=e.stabilityScore>=.7&&t!=="degrading",s=Math.min(e.stabilityScore,.9);let r;i?e.avgOnlineDuration>30*60*1e3?r=30*60*1e3:r=e.avgOnlineDuration*.8:r=5*60*1e3;let n=this.currentStatus.quality;return t==="improving"?this.currentStatus.quality==="poor"?n="fair":this.currentStatus.quality==="fair"&&(n="good"):t==="degrading"&&(this.currentStatus.quality==="good"?n="fair":this.currentStatus.quality==="fair"&&(n="poor")),{isStable:i,confidence:s,predictedDuration:r,predictedQuality:n}}generateSmartRecommendations(e,t){const i=[];return e.isStable||(i.push("网络连接不稳定，建议切换到更稳定的网络"),i.push("建议启用离线模式和数据压缩")),e.predictedQuality==="poor"&&(i.push("网络质量较差，建议减少同步频率"),i.push("建议使用较小的批处理大小")),e.isStable&&e.predictedQuality==="excellent"&&(i.push("网络状态优秀，适合进行大规模数据同步"),i.push("可以考虑禁用数据压缩以提高性能")),t.filter(r=>r.type==="error").length>3&&i.push("最近网络错误较多，建议检查网络连接"),i}identifyRiskFactors(e){const t=[];e.filter(a=>["online","offline"].includes(a.type)).length>5&&t.push("网络连接频繁变化");const s=e.filter(a=>a.type==="quality-change");return s.filter(a=>a.details?.qualityChange<0).length>s.length*.6&&t.push("网络质量呈下降趋势"),e.filter(a=>a.type==="error").length>2&&t.push("网络错误频率较高"),t}updateStats(){if(!this.previousStatus)return;this.previousStatus.isOnline!==this.currentStatus.isOnline&&(this.stats.connectionChanges++,this.currentStatus.isOnline?(this.stats.lastOfflineTime&&(this.stats.offlineTime+=Date.now()-this.stats.lastOfflineTime,this.stats.lastOfflineTime=void 0),this.stats.lastOnlineTime=Date.now()):(this.stats.lastOnlineTime&&(this.stats.onlineTime+=Date.now()-this.stats.lastOnlineTime,this.stats.lastOnlineTime=void 0),this.stats.lastOfflineTime=Date.now())),this.qualityHistory.push({timestamp:new Date,quality:this.currentStatus.quality,score:this.currentStatus.qualityScore}),this.qualityHistory.length>100&&(this.qualityHistory=this.qualityHistory.slice(-50));const e=this.qualityHistory.slice(-20);e.length>0&&(this.stats.averageQuality=e.reduce((t,i)=>t+i.score,0)/e.length),this.currentStatus.rtt!==void 0&&(this.stats.averageRtt===0?this.stats.averageRtt=this.currentStatus.rtt:this.stats.averageRtt=this.stats.averageRtt*.8+this.currentStatus.rtt*.2),this.currentStatus.downlink!==void 0&&(this.stats.averageDownlink===0?this.stats.averageDownlink=this.currentStatus.downlink:this.stats.averageDownlink=this.stats.averageDownlink*.8+this.currentStatus.downlink*.2),this.currentStatus.jitter!==void 0&&(this.stats.averageJitter===0?this.stats.averageJitter=this.currentStatus.jitter:this.stats.averageJitter=this.stats.averageJitter*.8+this.currentStatus.jitter*.2),this.currentStatus.packetLoss!==void 0&&(this.stats.packetLoss=this.currentStatus.packetLoss)}recordPerformanceMetrics(e){}recordError(e,t){this.stats.errorCount++;const i={type:"network_slow",message:`Network error: ${e}`,timestamp:new Date,severity:"medium",details:t instanceof Error?t.message:String(t)};this.stats.lastError=i,this.listeners.forEach(s=>{try{s.onNetworkError&&s.onNetworkError(i)}catch(r){console.error("Error in network error listener:",r)}})}startPeriodicChecks(){this.checkTimer=setInterval(async()=>{this.isMonitoring&&await this.checkNetworkStatus()},this.config.checkInterval),this.qualityTimer=setInterval(async()=>{this.isMonitoring&&await this.performQualityCheck()},this.config.qualityCheckInterval),this.healthTimer=setInterval(async()=>{this.isMonitoring&&this.config.healthCheck.enabled&&await this.performHealthCheck()},this.config.healthCheckInterval),this.config.performance.enablePrediction&&(this.predictionTimer=setInterval(async()=>{if(this.isMonitoring){const e=await this.getNetworkPrediction();this.listeners.forEach(t=>{try{t.onNetworkPrediction&&t.onNetworkPrediction(e)}catch(i){console.error("Error in network prediction listener:",i)}})}},5*60*1e3))}stopPeriodicChecks(){this.checkTimer&&(clearInterval(this.checkTimer),this.checkTimer=null),this.qualityTimer&&(clearInterval(this.qualityTimer),this.qualityTimer=null),this.healthTimer&&(clearInterval(this.healthTimer),this.healthTimer=null),this.predictionTimer&&(clearInterval(this.predictionTimer),this.predictionTimer=null)}async performQualityCheck(){try{const e=await this.assessNetworkQuality();Math.abs(e.score-this.currentStatus.qualityScore)>=this.config.eventFilter.minQualityChange&&await this.checkNetworkStatus()}catch(e){console.warn("Quality check failed:",e),this.recordError("quality_check_failed",e)}}handleBrowserOnline(){console.log("Browser online event detected"),this.checkNetworkStatus().catch(console.error)}handleBrowserOffline(){console.log("Browser offline event detected"),this.checkNetworkStatus().catch(console.error)}handleConnectionChange(){console.log("Connection API change detected"),this.checkNetworkStatus().catch(console.error)}generateRecommendations(e,t){const i=[];return e.score<.3?(i.push("网络质量较差，建议启用数据压缩"),i.push("建议使用较小的批处理大小"),i.push("建议切换到更稳定的网络连接")):e.score<.6&&(i.push("网络质量一般，建议优化数据传输"),i.push("建议启用重试机制")),e.jitter&&e.jitter>100&&(i.push("网络抖动较高，建议减少实时同步"),i.push("建议增加超时时间")),e.packetLoss&&e.packetLoss>.05&&(i.push("存在网络丢包，建议启用数据校验"),i.push("建议减少批处理大小")),t.connectionType==="cellular"&&(i.push("移动网络连接，建议注意流量使用"),i.push("建议启用数据压缩")),this.currentStatus.features.backgroundSync||i.push("建议启用后台同步以改善离线体验"),this.currentStatus.features.connectionInfo||i.push("浏览器不支持详细网络信息，使用基本检测策略"),i}setCache(e,t,i=6e4){this.config.performance.enableCaching&&(this.statusCache.set(e,{data:t,timestamp:Date.now()}),setTimeout(()=>{this.statusCache.delete(e)},i))}getCache(e){if(!this.config.performance.enableCaching)return null;const t=this.statusCache.get(e);return t?Date.now()-t.timestamp>6e4?(this.statusCache.delete(e),null):t.data:null}clearCache(){this.statusCache.clear()}destroy(){if(!this.isDestroyed){if(this.isDestroyed=!0,this.isMonitoring=!1,this.isInitialized=!1,this.stopPeriodicChecks(),this.debounceTimer&&(clearTimeout(this.debounceTimer),this.debounceTimer=null),typeof window<"u"){window.removeEventListener("online",this.handleBrowserOnline.bind(this)),window.removeEventListener("offline",this.handleBrowserOffline.bind(this));const e=navigator.connection;e&&e.removeEventListener("change",this.handleConnectionChange.bind(this))}this.listeners.clear(),this.clearCache(),this.circuitBreakers.clear(),this.eventHistory.length=0,this.qualityHistory.length=0,O.instance===this&&(O.instance=null),console.log("NetworkManager destroyed")}}}const C=O.getInstance();typeof window<"u"&&(window.NetworkManager=O,window.networkManager=C);class J extends A{cards;folders;tags;images;syncQueue;settings;sessions;offlineSnapshots;offlineBackups;constructor(){super("CardAllUnifiedDatabase"),this.version(4).stores({cards:"++id, userId, folderId, createdAt, updatedAt, syncVersion, pendingSync, [userId+folderId], searchVector",folders:"++id, userId, parentId, createdAt, updatedAt, syncVersion, pendingSync, [userId+parentId], fullPath, depth",tags:"++id, userId, name, createdAt, syncVersion, pendingSync, [userId+name]",images:"++id, cardId, userId, createdAt, updatedAt, syncVersion, pendingSync, storageMode, [cardId+userId]",syncQueue:"++id, type, entity, entityId, userId, timestamp, retryCount, priority, [userId+priority]",settings:"++id, key, updatedAt, scope, [key+scope]",sessions:"++id, userId, deviceId, lastActivity, isActive, [userId+deviceId]",offlineSnapshots:"++id, timestamp, userId, version, dataHash, dataSize, [userId+timestamp]",offlineBackups:"++id, snapshotId, createdAt, compression, encrypted, size, [snapshotId+createdAt]"}),this.upgradeDatabase()}async upgradeDatabase(){this.version(2).upgrade(async e=>{console.log("Upgrading to version 2: Adding user support...");const t=new W;try{await t.open(),console.log("Found old database, migrating data...");const s=(await t.cards.toArray()).map(c=>({...c,userId:"default",updatedAt:new Date}));await this.cards.bulkAdd(s);const n=(await t.folders.toArray()).map(c=>({...c,userId:"default",updatedAt:new Date}));await this.folders.bulkAdd(n);const o=(await t.tags.toArray()).map(c=>({...c,userId:"default",updatedAt:new Date}));await this.tags.bulkAdd(o),console.log("Migration completed successfully")}catch(i){console.log("No old database found or migration failed:",i)}}),this.version(3).upgrade(async e=>{console.log("Upgrading to version 3: Optimizing indexes and adding new features..."),await this.initializeDefaultSettings(),await this.rebuildSearchIndexes()}),this.version(4).upgrade(async e=>{console.log("Upgrading to version 4: Adding offline data persistence features..."),await this.initializeOfflinePersistence(),await this.createInitialOfflineSnapshot()})}async initializeDefaultSettings(){const e=[{key:"storageMode",value:"hybrid",scope:"global",updatedAt:new Date},{key:"syncEnabled",value:!0,scope:"global",updatedAt:new Date},{key:"imageCompression",value:{enabled:!0,quality:.8,maxWidth:1920,maxHeight:1080,format:"webp"},scope:"global",updatedAt:new Date},{key:"databaseVersion",value:"3.0.0",scope:"global",updatedAt:new Date}];for(const t of e)await this.settings.where("key").equals(t.key).first()||await this.settings.add(t)}async rebuildSearchIndexes(){console.log("Rebuilding search indexes...")}async initializeOfflinePersistence(){console.log("Initializing offline persistence...");const e=[{key:"offlineAutoBackup",value:{enabled:!0,interval:30*60*1e3,maxBackups:10,compression:!0},scope:"global",updatedAt:new Date},{key:"offlineCompression",value:{enabled:!0,algorithm:"lz-string",threshold:1024,quality:.8},scope:"global",updatedAt:new Date},{key:"offlineDataRetention",value:{days:30,maxSize:100},scope:"global",updatedAt:new Date}];for(const t of e)await this.settings.where("key").equals(t.key).first()||await this.settings.add(t)}async createInitialOfflineSnapshot(){try{const e=await this.createOfflineSnapshot({includeCards:!0,includeFolders:!0,includeTags:!0,includeSettings:!0,includeImages:!1});console.log("Initial offline snapshot created:",e.id)}catch(e){console.error("Failed to create initial offline snapshot:",e)}}async createOfflineSnapshot(e={}){const{includeCards:t=!0,includeFolders:i=!0,includeTags:s=!0,includeImages:r=!1,includeSettings:n=!0,userId:a}=e,o=crypto.randomUUID(),c=new Date,l={};let y=0;t&&(l.cards=await this.cards.toArray(),y+=JSON.stringify(l.cards).length),i&&(l.folders=await this.folders.toArray(),y+=JSON.stringify(l.folders).length),s&&(l.tags=await this.tags.toArray(),y+=JSON.stringify(l.tags).length),r&&(l.images=await this.images.toArray(),y+=JSON.stringify(l.images).length),n&&(l.settings=await this.settings.toArray(),y+=JSON.stringify(l.settings).length);const g=await this.calculateDataHash(l),f=await this.getDeviceInfo(),k=await this.getStorageQuota(),x={id:o,timestamp:c,version:"4.0.0",userId:a,dataHash:g,dataSize:y,compressedSize:y,includes:{cards:t,folders:i,tags:s,images:r,settings:n},metadata:{deviceInfo:f,networkStatus:navigator.onLine?"online":"offline",batteryLevel:(navigator.getBattery?.(),void 0),storageQuota:k}};return await this.offlineSnapshots.add(x),x}async calculateDataHash(e){const t=JSON.stringify(e),s=new TextEncoder().encode(t),r=await crypto.subtle.digest("SHA-256",s);return Array.from(new Uint8Array(r)).map(a=>a.toString(16).padStart(2,"0")).join("")}async getDeviceInfo(){const e={userAgent:navigator.userAgent,platform:navigator.platform,language:navigator.language,deviceMemory:navigator.deviceMemory,hardwareConcurrency:navigator.hardwareConcurrency,screenResolution:`${screen.width}x${screen.height}`,timestamp:new Date().toISOString()};return JSON.stringify(e)}async getStorageQuota(){try{if("storage"in navigator&&"estimate"in navigator.storage){const e=await navigator.storage.estimate();return{used:e.usage||0,total:e.quota||0}}}catch(e){console.warn("Failed to get storage quota:",e)}return{used:0,total:0}}async restoreOfflineSnapshot(e){try{const t=await this.offlineSnapshots.get(e);if(!t)throw new Error("Snapshot not found");if(await this.getCurrentDataHash()===t.dataHash)return console.log("Data already matches snapshot, no restore needed"),!0;if(t.includes.cards){const s=await this.cards.toArray();await this.cards.clear()}if(t.includes.folders){const s=await this.folders.toArray();await this.folders.clear()}if(t.includes.tags){const s=await this.tags.toArray();await this.tags.clear()}if(t.includes.settings){const s=await this.settings.toArray();await this.settings.clear()}return console.log("Offline snapshot restored successfully:",e),!0}catch(t){return console.error("Failed to restore offline snapshot:",t),!1}}async getCurrentDataHash(){const e={cards:await this.cards.toArray(),folders:await this.folders.toArray(),tags:await this.tags.toArray(),settings:await this.settings.toArray()};return await this.calculateDataHash(e)}async cleanupOfflineData(){const e=new Date;let t=0,i=0,s=0;try{const r=await this.getSetting("offlineDataRetention"),n=r?.days||30,a=r?.maxSize||100,o=new Date(e.getTime()-n*24*60*60*1e3),c=await this.offlineSnapshots.where("timestamp").below(o).toArray();for(const f of c)s+=f.dataSize,await this.offlineSnapshots.delete(f.id),t++;const l=await this.offlineBackups.where("createdAt").below(o).toArray();for(const f of l)s+=f.size,await this.offlineBackups.delete(f.id),i++;const y=await this.offlineSnapshots.orderBy("timestamp").reverse().toArray();let g=y.reduce((f,k)=>f+k.dataSize,0);for(;g>a*1024*1024&&y.length>5;){const f=y.pop();f&&(s+=f.dataSize,await this.offlineSnapshots.delete(f.id),t++,g-=f.dataSize)}return console.log(`Offline data cleanup completed: ${t} snapshots, ${i} backups, ${s} bytes freed`),{cleanedSnapshots:t,cleanedBackups:i,freedSpace:s}}catch(r){return console.error("Failed to cleanup offline data:",r),{cleanedSnapshots:0,cleanedBackups:0,freedSpace:0}}}async autoBackupOfflineData(){try{const e=await this.getSetting("offlineAutoBackup");if(!e?.enabled)return!1;const t=await this.offlineSnapshots.orderBy("timestamp").reverse().first();if(t&&new Date().getTime()-t.timestamp.getTime()<e.interval)return!1;const s=await this.createOfflineSnapshot({includeCards:!0,includeFolders:!0,includeTags:!0,includeImages:!1,includeSettings:!0}),r=e.maxBackups||10,n=await this.offlineSnapshots.orderBy("timestamp").reverse().toArray();if(n.length>r){const a=n.slice(r);for(const o of a)await this.offlineSnapshots.delete(o.id)}return console.log("Auto backup completed:",s.id),!0}catch(e){return console.error("Auto backup failed:",e),!1}}async getOfflineDataStats(){const e=await this.offlineSnapshots.toArray(),t=await this.offlineBackups.toArray(),i=e.reduce((n,a)=>n+a.dataSize,0)+t.reduce((n,a)=>n+a.size,0),s=e.length>0?e.reduce((n,a)=>a.timestamp>n.timestamp?a:n,e[0]).timestamp:void 0,r=e.length>0?e.reduce((n,a)=>a.timestamp<n.timestamp?a:n,e[0]).timestamp:void 0;return{snapshots:e.length,backups:t.length,totalSize:i,lastBackup:s,oldestBackup:r}}async getSetting(e,t){if(t){const s=await this.settings.where("[key+scope]").equals([e,"user"]).first();if(s)return s.value}return(await this.settings.where("[key+scope]").equals([e,"global"]).first())?.value}async updateSetting(e,t,i="global",s){const r={value:t,updatedAt:new Date};s&&(r.userId=s),await this.settings.where("[key+scope]").equals([e,i]).modify(r)}async getStats(){const[e,t,i,s,r]=await Promise.all([this.cards.count(),this.folders.count(),this.tags.count(),this.images.count(),this.syncQueue.count()]),n=await this.calculateTotalSize();return{cards:e,folders:t,tags:i,images:s,pendingSync:r,totalSize:n,version:"3.0.0"}}async calculateTotalSize(){return(await this.images.toArray()).reduce((t,i)=>t+i.metadata.size,0)}async createCard(e,t){const i=crypto.randomUUID(),s=new Date;return await this.cards.add({...e,id:i,userId:t,syncVersion:1,pendingSync:!0,updatedAt:s}),i}async updateCard(e,t){return await this.cards.update(e,{...t,syncVersion:t.syncVersion?t.syncVersion+1:void 0,pendingSync:!0,updatedAt:new Date})}async deleteCard(e){await this.transaction("rw",[this.cards,this.images],async()=>{await this.images.where("cardId").equals(e).delete(),await this.cards.delete(e)})}async bulkCreateCards(e,t){const i=new Date,s=e.map(r=>({...r,id:crypto.randomUUID(),userId:t,syncVersion:1,pendingSync:!0,updatedAt:i}));return await this.cards.bulkAdd(s),s.map(r=>r.id)}async getCardsByFolder(e,t){return await this.cards.where("[userId+folderId]").equals([t||"default",e]).toArray()}async searchCards(e,t){const i=e.toLowerCase();return await this.cards.filter(s=>s.searchVector?.includes(i)||s.frontContent.title.toLowerCase().includes(i)||s.frontContent.text.toLowerCase().includes(i)||s.backContent.title.toLowerCase().includes(i)||s.backContent.text.toLowerCase().includes(i)).toArray()}async cleanup(){await this.transaction("rw",[this.cards,this.folders,this.tags,this.images,this.syncQueue],async()=>{const e=new Date(Date.now()-6048e5);await this.syncQueue.where("timestamp").below(e).delete();const t=await this.cards.toCollection().primaryKeys();await this.images.where("cardId").noneOf(t).delete(),console.log("Database cleanup completed")})}async healthCheck(){const e=[];try{await this.cards.count();const t=await this.getStats();return t.pendingSync>1e3&&e.push(`High number of pending sync operations: ${t.pendingSync}`),t.totalSize>500*1024*1024&&e.push(`Database size is large: ${(t.totalSize/1024/1024).toFixed(2)} MB`),{isHealthy:e.length===0,issues:e,stats:t}}catch(t){return{isHealthy:!1,issues:[`Database connection failed: ${t}`],stats:{cards:0,folders:0,tags:0,images:0,pendingSync:0,totalSize:0,version:"3.0.0"}}}}async clearAll(){await this.transaction("rw",[this.cards,this.folders,this.tags,this.images,this.syncQueue,this.settings,this.sessions],async()=>{await this.cards.clear(),await this.folders.clear(),await this.tags.clear(),await this.images.clear(),await this.syncQueue.clear(),await this.sessions.clear()})}async getSettingLegacy(e){return await this.getSetting(e)}async updateSettingLegacy(e,t){await this.updateSetting(e,t)}async clearAllLegacy(){await this.transaction("rw",[this.cards,this.folders,this.tags,this.images,this.syncQueue],async()=>{await this.cards.clear(),await this.folders.clear(),await this.tags.clear(),await this.images.clear(),await this.syncQueue.clear()})}async getStatsLegacy(){const e=await this.getStats();return{cards:e.cards,folders:e.folders,tags:e.tags,images:e.images,pendingSync:e.pendingSync}}}class W extends A{cards;folders;tags;images;syncQueue;settings;constructor(){super("CardAllDatabase"),this.version(1).stores({cards:"++id, folderId, createdAt, updatedAt, syncVersion, pendingSync",folders:"++id, parentId, createdAt, updatedAt, syncVersion, pendingSync",tags:"++id, name, createdAt, syncVersion, pendingSync",images:"++id, cardId, filePath, createdAt, syncVersion, pendingSync",syncQueue:"++id, type, entity, entityId, timestamp, retryCount",settings:"++id, key, updatedAt"})}}const d=new J;d.on("versionchange",p=>{console.warn("Database version changed:",p)});d.on("blocked",()=>{console.warn("Database operation blocked")});d.on("versionchange",()=>{console.warn("Database version changed, reloading page..."),window.location.reload()});d.on("ready",()=>{console.log("Database is ready")});const M=new Map,P=5*60*1e3;setInterval(()=>{const p=Date.now();M.forEach((e,t)=>{p-e.timestamp>P&&M.delete(t)})},P);class K{available;waiting=[];constructor(e){this.available=e}async acquire(){if(this.available>0){this.available--;return}return new Promise(e=>{this.waiting.push(e)})}release(){if(this.available++,this.waiting.length>0&&this.available>0){const e=this.waiting.shift();e&&(this.available--,e())}}}class G{isOffline=!navigator.onLine;networkInfo={status:navigator.onLine?"online":"offline",lastChanged:new Date};offlineOperations=[];conflicts=[];offlineStartTime;syncTimer;reconnectAttempts=0;maxReconnectAttempts=10;listeners={};constructor(){this.initializeOfflineManager()}getNetworkStatus(){return{...this.networkInfo}}isCurrentlyOffline(){return this.isOffline}async getOfflineStats(){const e=await this.getPendingOfflineOperations(),t=await this.getCompletedOfflineOperations(),i=await this.getFailedOfflineOperations();return{isOffline:this.isOffline,offlineDuration:this.calculateOfflineDuration(),pendingOperations:e.length,completedOfflineOperations:t.length,failedOperations:i.length,averageResponseTime:this.calculateAverageResponseTime(),dataSyncedOnResume:this.calculateDataSyncedOnResume(),lastSyncTime:await this.getLastSyncTime(),estimatedBandwidthSaved:this.calculateEstimatedBandwidthSaved(e)}}async executeOfflineOperation(e){const t={...e,id:crypto.randomUUID(),timestamp:new Date,retryCount:0};try{e.dependencies&&e.dependencies.length>0&&await this.validateDependencies(e.dependencies);const i=await this.performLocalOperation(t);return await this.storeOfflineOperation(t),this.listeners.onOfflineOperation&&this.listeners.onOfflineOperation(t),{success:!0,data:i,operationId:t.id}}catch(i){return console.error("Offline operation failed:",i),t.priority="high",await this.storeOfflineOperation(t),{success:!1,error:i instanceof Error?i.message:String(i),operationId:t.id}}}async executeBatchOfflineOperations(e){const t=crypto.randomUUID(),i=[];try{const s=e.filter(n=>n.dependencies&&n.dependencies.length>0).flatMap(n=>n.dependencies);s.length>0&&await this.validateDependencies(s);const r=this.sortOperationsByPriority(e);for(const n of r){const a=await this.executeOfflineOperation(n);i.push(a)}return{success:i.every(n=>n.success),results:i,batchId:t}}catch(s){return console.error("Batch offline operations failed:",s),{success:!1,results:i.map(r=>({...r,success:!1,error:s instanceof Error?s.message:String(s)})),batchId:t}}}async getPendingOfflineOperations(){return await d.transaction("r",[d.syncQueue],async()=>(await d.syncQueue.where("status").equals("pending").toArray()).map(t=>this.convertSyncOperationToOfflineOperation(t)))}async retryFailedOperations(){const e=await this.getFailedOfflineOperations();let t=0;for(const i of e)try{await this.retryOperation(i),t++}catch(s){console.warn(`Failed to retry operation ${i.id}:`,s)}return t}async handleNetworkRecovery(){console.log("Network recovered, analyzing sync strategy...");const e=performance.now(),t=await this.getOfflineStats();try{const i=await this.assessNetworkQuality(),s=await this.determineSyncStrategy(t,i);console.log(`Using sync strategy: ${s.strategy}`),this.notifySyncProgress(0,t.pendingOperations);const r=await this.executeSmartSync(s,t);r.conflicts.length>0&&await this.handleConflicts(r.conflicts),await this.performPostSyncOptimizations(r,i);const n=await this.getOfflineStats();this.notifySyncComplete(n),console.log(`Smart offline sync completed in ${(performance.now()-e).toFixed(2)}ms`),console.log(`Sync results: ${r.syncedOperations} operations, ${r.conflicts.length} conflicts`)}catch(i){console.error("Smart offline sync failed:",i),await this.handleSyncError(i,t),this.listeners.onError&&this.listeners.onError(i instanceof Error?i:new Error(String(i)))}}async assessNetworkQuality(){const e=navigator.connection,t={isStable:!0,bandwidth:"good",latency:"low",reliability:.9,recommendedStrategy:"immediate"};e&&(e.downlink&&(e.downlink>=20?(t.bandwidth="excellent",t.recommendedStrategy="immediate"):e.downlink>=10?(t.bandwidth="good",t.recommendedStrategy="immediate"):e.downlink>=3?(t.bandwidth="fair",t.recommendedStrategy="batched"):e.downlink>=1?(t.bandwidth="poor",t.recommendedStrategy="conservative"):(t.bandwidth="poor",t.recommendedStrategy="prioritized")),e.rtt&&(e.rtt<=50?t.latency="low":e.rtt<=150?(t.latency="medium",t.recommendedStrategy="batched"):e.rtt<=500?(t.latency="high",t.recommendedStrategy="conservative"):(t.latency="high",t.recommendedStrategy="prioritized")),e.type==="cellular"?(t.reliability=.7,(e.effectiveType==="slow-2g"||e.effectiveType==="2g")&&(t.recommendedStrategy="conservative")):e.type==="wifi"?t.reliability=.9:e.type==="ethernet"&&(t.reliability=.95));const i=await this.testConnectionStability();t.isStable=i.isStable,t.reliability*=i.stabilityFactor,t.isStable||(t.recommendedStrategy="conservative");const s=await this.calculateHistoricalReliability();return t.reliability*=s,t}async testConnectionStability(){const e=["https://www.google.com/favicon.ico","https://www.cloudflare.com/favicon.ico"],s=(await Promise.allSettled(e.map(n=>fetch(n,{method:"HEAD",mode:"no-cors"})))).filter(n=>n.status==="fulfilled").length/e.length;return{isStable:s>=.8,stabilityFactor:s}}determineRecommendedStrategy(e){return e.isStable&&e.bandwidth==="excellent"&&e.latency==="low"?"immediate":e.reliability>=.8&&e.bandwidth!=="poor"?"batched":e.reliability>=.6?"prioritized":"conservative"}async determineSyncStrategy(e,t){return{strategy:t.recommendedStrategy,batchSize:this.calculateOptimalBatchSize(e,t),delayBetweenBatches:this.calculateBatchDelay(t),priorityFilter:this.determinePriorityFilter(e,t),maxConcurrentOperations:this.calculateMaxConcurrent(t),timeout:this.calculateOperationTimeout(t),retryStrategy:this.determineRetryStrategy(t)}}calculateOptimalBatchSize(e,t){let i=10;switch(t.bandwidth){case"excellent":i=50;break;case"good":i=30;break;case"fair":i=15;break;case"poor":i=5;break}return e.pendingOperations>100&&(i=Math.min(i,20)),i}calculateBatchDelay(e){switch(e.bandwidth){case"excellent":return 100;case"good":return 300;case"fair":return 500;case"poor":return 1e3;default:return 500}}determinePriorityFilter(e,t){return t.reliability<.7?["critical","high"]:e.pendingOperations>50?["critical","high","normal"]:["critical","high","normal","low"]}calculateMaxConcurrent(e){switch(e.latency){case"low":return e.bandwidth==="excellent"?5:3;case"medium":return 2;case"high":return 1;default:return 2}}calculateOperationTimeout(e){let t=1e4;switch(e.latency){case"high":t*=2;break;case"medium":t*=1.5;break}switch(e.bandwidth){case"poor":t*=1.5;break;case"fair":t*=1.2;break}return t}determineRetryStrategy(e){return e.isStable&&e.reliability>=.8?{maxRetries:3,initialDelay:1e3,maxDelay:5e3,backoffMultiplier:2}:{maxRetries:5,initialDelay:2e3,maxDelay:15e3,backoffMultiplier:2.5}}async executeSmartSync(e,t){const s=(await this.getPendingOfflineOperations()).filter(c=>e.priorityFilter.includes(c.priority)),r=this.createOptimalBatches(s,e.batchSize),n={success:!0,syncedOperations:0,conflicts:[],errors:[]},a=new K(e.maxConcurrentOperations),o=r.map(async(c,l)=>{await a.acquire();try{l>0&&await new Promise(g=>setTimeout(g,e.delayBetweenBatches));const y=await this.executeBatchWithRetry(c,e.retryStrategy,e.timeout);n.syncedOperations+=y.syncedCount,n.conflicts.push(...y.conflicts),n.errors.push(...y.errors),this.notifySyncProgress(n.syncedOperations,s.length)}catch(y){n.errors.push(`Batch ${l} failed: ${y}`)}finally{a.release()}});return await Promise.all(o),n.success=n.errors.length===0,n}createOptimalBatches(e,t){const i=[],s={critical:4,high:3,normal:2,low:1},r=[...e].sort((n,a)=>s[a.priority]-s[n.priority]);for(let n=0;n<r.length;n+=t)i.push(r.slice(n,n+t));return i}async executeBatchWithRetry(e,t,i){let s=null;for(let r=1;r<=t.maxRetries;r++)try{return await this.executeBatchWithTimeout(e,i)}catch(n){if(s=n instanceof Error?n:new Error(String(n)),r===t.maxRetries)break;const a=Math.min(t.initialDelay*Math.pow(t.backoffMultiplier,r-1),t.maxDelay);console.log(`Retry ${r}/${t.maxRetries} after ${a}ms`),await new Promise(o=>setTimeout(o,a))}return{syncedCount:0,conflicts:[],errors:[s?.message||"Batch execution failed after all retries"]}}async executeBatchWithTimeout(e,t){const i=new Promise((r,n)=>{setTimeout(()=>n(new Error("Operation timeout")),t)}),s=this.executeBatchOperations(e);try{return await Promise.race([s,i])}catch(r){throw r instanceof Error&&r.message==="Operation timeout"?new Error(`Batch operation timed out after ${t}ms`):r}}async executeBatchOperations(e){let t=0;const i=[],s=[];for(const r of e)try{const n=await this.syncOperation(r);n.success?t++:n.conflict?i.push(n.conflict):s.push(n.error||`Operation ${r.id} failed`)}catch(n){s.push(`Operation ${r.id} error: ${n}`)}return{syncedCount:t,conflicts:i,errors:s}}async performPostSyncOptimizations(e,t){e.success&&e.errors.length===0&&await this.cleanupOldSyncState(),t.bandwidth==="excellent"&&t.isStable&&await this.preloadRemoteData(),await this.updateNetworkHistory(t)}async handleSyncError(e,t){console.error("Sync error occurred, attempting recovery...",e),e.message?.includes("timeout")?await this.scheduleReducedSync():e.message?.includes("network")?await this.scheduleDelayedSync():await this.scheduleRetrySync()}async scheduleReducedSync(){setTimeout(async()=>{(await this.getOfflineStats()).pendingOperations>0&&(console.log("Executing reduced sync..."),await this.syncCriticalOperationsOnly())},5e3)}async scheduleDelayedSync(){setTimeout(async()=>{(await this.getOfflineStats()).pendingOperations>0&&(console.log("Executing delayed sync..."),await this.handleNetworkRecovery())},3e4)}async scheduleRetrySync(){setTimeout(async()=>{(await this.getOfflineStats()).pendingOperations>0&&(console.log("Retrying sync..."),await this.handleNetworkRecovery())},1e4)}async syncCriticalOperationsOnly(){const t=(await this.getPendingOfflineOperations()).filter(i=>i.priority==="critical");if(t.length>0){const i=await this.executeBatchOperations(t);console.log(`Critical sync completed: ${i.syncedCount}/${t.length}`)}}async cleanupOldSyncState(){try{const e=Object.keys(localStorage).filter(t=>t.startsWith("offlineBackup_")).sort();if(e.length>3&&e.slice(0,e.length-3).forEach(i=>localStorage.removeItem(i)),d.offlineState){const t=await d.offlineState.orderBy("timestamp").reverse().offset(5).toArray();for(const i of t)await d.offlineState.delete(i.id)}}catch(e){console.warn("Failed to cleanup old sync state:",e)}}async preloadRemoteData(){try{console.log("Preloading remote data...")}catch(e){console.warn("Failed to preload remote data:",e)}}async updateNetworkHistory(e){try{const t="networkQualityHistory",i=JSON.parse(localStorage.getItem(t)||"[]");i.push({timestamp:new Date().toISOString(),...e}),i.length>100&&i.splice(0,i.length-100),localStorage.setItem(t,JSON.stringify(i))}catch(t){console.warn("Failed to update network history:",t)}}async performOfflineSync(){const e=await this.getPendingOfflineOperations(),t=[],i=[],s=[],r=e.filter(l=>l.priority==="critical"),n=e.filter(l=>l.priority==="high"),a=e.filter(l=>l.priority==="normal"),o=e.filter(l=>l.priority==="low"),c=[...r,...n,...a,...o];for(let l=0;l<c.length;l++){const y=c[l];try{if(!navigator.onLine)throw new Error("Network lost during sync");const g=await this.syncOperation(y);g.success?t.push(y.id):g.conflict?i.push(g.conflict):s.push(g.error||`Sync failed for operation ${y.id}`),this.notifySyncProgress(l+1,c.length),l%10===0&&await new Promise(f=>setTimeout(f,100))}catch(g){const f=g instanceof Error?g.message:String(g);if(s.push(`Operation ${y.id} failed: ${f}`),f.includes("network")||f.includes("Network")){console.warn("Network error during sync, pausing...");break}}}return{success:s.length===0,syncedOperations:t.length,conflicts:i,errors:s}}async detectConflicts(e,t){if(!t)return null;const i=await this.getLocalDataForEntity(e.entity,e.entityId);if(!i)return null;const s=new Date(e.timestamp),r=new Date(t.updatedAt||t.createdAt);return s>r?{id:crypto.randomUUID(),entityType:e.entity,entityId:e.entityId||"",localData:i,remoteData:t,conflictType:this.determineConflictType(e,i,t),timestamp:new Date,resolution:"pending"}:null}async handleConflicts(e){for(const t of e)try{const i=await this.resolveConflict(t);i==="manual"?(this.conflicts.push(t),this.listeners.onConflict&&this.listeners.onConflict(t)):await this.applyConflictResolution(t,i)}catch(i){console.error(`Failed to resolve conflict ${t.id}:`,i),t.resolution="manual",this.conflicts.push(t)}}async resolveConflict(e){switch(e.conflictType){case"simultaneous_edit":return await this.attemptSmartMerge(e);case"delete_conflict":return"manual";case"structure_conflict":return"local";default:return"manual"}}async attemptSmartMerge(e){const t=this.extractContentForMerge(e.localData),i=this.extractContentForMerge(e.remoteData);if(this.calculateContentSimilarity(t,i)>.8){const s=new Date(e.localData.updatedAt||e.localData.createdAt),r=new Date(e.remoteData.updatedAt||e.remoteData.createdAt);return s>r?"local":"remote"}return"manual"}setEventListeners(e){this.listeners={...this.listeners,...e}}notifyNetworkChange(e){this.listeners.onNetworkChange&&this.listeners.onNetworkChange(e)}notifySyncProgress(e,t){this.listeners.onSyncProgress&&this.listeners.onSyncProgress({completed:e,total:t})}notifySyncComplete(e){this.listeners.onSyncComplete&&this.listeners.onSyncComplete(e)}initializeOfflineManager(){this.setupNetworkListeners(),this.setupConnectionMonitoring(),this.loadOfflineState(),this.startPeriodicSync()}setupNetworkListeners(){window.addEventListener("online",()=>{this.handleNetworkChange(!0)}),window.addEventListener("offline",()=>{this.handleNetworkChange(!1)})}setupConnectionMonitoring(){if("connection"in navigator){const e=navigator.connection;e.addEventListener("change",()=>{this.updateConnectionInfo(e)}),this.updateConnectionInfo(e)}}startPeriodicSync(){this.syncTimer=setInterval(async()=>{navigator.onLine&&(await this.getOfflineStats()).pendingOperations>0&&await this.handleNetworkRecovery()},30*1e3)}cleanup(){this.syncTimer&&clearInterval(this.syncTimer),window.removeEventListener("online",this.handleNetworkChange),window.removeEventListener("offline",this.handleNetworkChange)}async handleNetworkChange(e){const t=this.networkInfo.status,i=e?"online":"offline";this.isOffline=!e,this.networkInfo={...this.networkInfo,status:i,lastChanged:new Date},t==="offline"&&i==="online"?(this.reconnectAttempts=0,await this.handleNetworkRecovery()):t==="online"&&i==="offline"&&(this.offlineStartTime=new Date),this.notifyNetworkChange(this.networkInfo)}updateConnectionInfo(e){this.networkInfo={...this.networkInfo,effectiveType:e.effectiveType,downlink:e.downlink,rtt:e.rtt,saveData:e.saveData,connectionType:this.determineConnectionType(e)}}determineConnectionType(e){if(e.type)switch(e.type){case"wifi":return"wifi";case"cellular":return"cellular";case"ethernet":return"ethernet";default:return"unknown"}return e.effectiveType&&["4g","5g"].includes(e.effectiveType)?e.effectiveType==="5g"?"wifi":"cellular":"unknown"}async validateDependencies(e){const i=(await this.getPendingOfflineOperations()).map(r=>r.id),s=e.filter(r=>!i.includes(r));if(s.length>0)throw new Error(`Dependencies not found: ${s.join(", ")}`)}async performLocalOperation(e){switch(e.type){case"create":return I.createCard(e.data,e.userId);case"update":return I.updateCard(e.entityId,e.data,e.userId);case"delete":return I.deleteCard(e.entityId,e.userId);default:throw new Error(`Unsupported operation type: ${e.type}`)}}async storeOfflineOperation(e){try{await d.syncQueue.add({id:e.id,type:e.type,entity:e.entity,entityId:e.entityId,userId:e.userId,data:e.data,priority:e.priority,timestamp:e.timestamp,retryCount:e.retryCount,maxRetries:e.maxRetries,error:void 0})}catch(t){throw console.error("Failed to store offline operation:",t),t}}async syncOperation(e){try{const t=await this.fetchRemoteData(e.entity,e.entityId),i=await this.detectConflicts(e,t);return i?{success:!1,conflict:i}:(await new Promise(s=>setTimeout(s,100)),await d.syncQueue.where("id").equals(e.id).modify({status:"completed"}),{success:!0})}catch(t){return{success:!1,error:t instanceof Error?t.message:String(t)}}}async fetchRemoteData(e,t){return null}async getLocalDataForEntity(e,t){switch(e){case"card":return t?d.cards.get(t):null;case"folder":return t?d.folders.get(t):null;case"tag":return t?d.tags.get(t):null;default:return null}}determineConflictType(e,t,i){return e.type==="delete"?"delete_conflict":this.hasStructureChanged(t,i)?"structure_conflict":"simultaneous_edit"}hasStructureChanged(e,t){const i=new Set(Object.keys(e)),s=new Set(Object.keys(t));return i.size!==s.size||![...i].every(r=>s.has(r))}extractContentForMerge(e){return e.frontContent&&e.backContent?JSON.stringify({front:e.frontContent,back:e.backContent}):JSON.stringify(e)}calculateContentSimilarity(e,t){const i=this.calculateLevenshteinDistance(e,t),s=Math.max(e.length,t.length);return s>0?1-i/s:1}calculateLevenshteinDistance(e,t){const i=Array(t.length+1).fill(null).map(()=>Array(e.length+1).fill(null));for(let s=0;s<=e.length;s++)i[0][s]=s;for(let s=0;s<=t.length;s++)i[s][0]=s;for(let s=1;s<=t.length;s++)for(let r=1;r<=e.length;r++){const n=e[r-1]===t[s-1]?0:1;i[s][r]=Math.min(i[s][r-1]+1,i[s-1][r]+1,i[s-1][r-1]+n)}return i[t.length][e.length]}async applyConflictResolution(e,t){e.resolution=t}async loadOfflineState(){try{const e=await this.loadFromIndexedDB();if(e){await this.restoreOfflineState(e);return}const t=localStorage.getItem("offlineManagerState");if(t){const i=JSON.parse(t);await this.restoreOfflineState(i),await this.saveToIndexedDB(i),localStorage.removeItem("offlineManagerState")}}catch(e){console.warn("Failed to load offline state:",e)}}async saveOfflineState(){try{const e=await this.createOfflineStateSnapshot();await this.saveToIndexedDB(e),await this.saveToLocalStorage(e),await this.createIncrementalBackup(e)}catch(e){console.warn("Failed to save offline state:",e),await this.saveToLocalStorageFallback()}}async createOfflineStateSnapshot(){const e=await this.getPendingOfflineOperations(),t=this.conflicts,i=await this.getOfflineStats();return{version:this.getCurrentStateVersion(),timestamp:new Date().toISOString(),offlineStartTime:this.offlineStartTime?.toISOString(),reconnectAttempts:this.reconnectAttempts,networkInfo:this.networkInfo,pendingOperations:e.map(s=>this.serializeOfflineOperation(s)),conflicts:t.map(s=>this.serializeConflict(s)),stats:this.serializeStats(i),checksum:await this.calculateStateChecksum(e,t)}}async saveToIndexedDB(e){try{await d.transaction("rw",[d.syncQueue],async()=>{d.offlineState||await d.version(d.ver+1).stores({offlineState:"++id,version,timestamp,checksum"}),await d.offlineState?.clear(),await d.offlineState?.add({version:e.version,timestamp:new Date(e.timestamp),data:JSON.stringify(e),checksum:e.checksum,compressed:!0})})}catch(t){throw console.warn("Failed to save to IndexedDB:",t),t}}async loadFromIndexedDB(){try{if(!d.offlineState)return null;const e=await d.offlineState.orderBy("timestamp").reverse().first();if(!e)return null;if(e.compressed){const t=this.decompressData(e.data),i=JSON.parse(t);if(await this.verifyStateChecksum(i))return i}return null}catch(e){return console.warn("Failed to load from IndexedDB:",e),null}}async saveToLocalStorage(e){try{const t=this.compressData(JSON.stringify(e));localStorage.setItem("offlineManagerState",t)}catch(t){console.warn("Failed to save to localStorage:",t)}}async saveToLocalStorageFallback(){try{const e={offlineStartTime:this.offlineStartTime?.toISOString(),reconnectAttempts:this.reconnectAttempts,timestamp:new Date().toISOString()};localStorage.setItem("offlineManagerState",JSON.stringify(e))}catch(e){console.warn("Fallback save failed:",e)}}async createIncrementalBackup(e){try{const t=`offlineBackup_${Date.now()}`,i={timestamp:e.timestamp,version:e.version,pendingCount:e.pendingOperations.length,conflictsCount:e.conflicts.length,compressed:!0},s=Object.keys(localStorage).filter(r=>r.startsWith("offlineBackup_")).sort();s.length>=10&&s.slice(0,s.length-9).forEach(n=>localStorage.removeItem(n)),localStorage.setItem(t,JSON.stringify(i))}catch(t){console.warn("Failed to create incremental backup:",t)}}compressData(e){try{return btoa(encodeURIComponent(e))}catch{return e}}decompressData(e){try{return decodeURIComponent(atob(e))}catch{return e}}getCurrentStateVersion(){return`1.0.${Date.now()}`}async calculateStateChecksum(e,t){const i=JSON.stringify({operations:e.length,conflicts:t.length,timestamp:Date.now()});let s=0;for(let r=0;r<i.length;r++){const n=i.charCodeAt(r);s=(s<<5)-s+n,s=s&s}return Math.abs(s).toString(16)}async verifyStateChecksum(e){try{const t=e.pendingOperations.map(r=>this.deserializeOfflineOperation(r)),i=e.conflicts.map(r=>this.deserializeConflict(r));return await this.calculateStateChecksum(t,i)===e.checksum}catch{return!1}}async restoreOfflineState(e){if(this.offlineStartTime=e.offlineStartTime?new Date(e.offlineStartTime):void 0,this.reconnectAttempts=e.reconnectAttempts||0,e.networkInfo&&(this.networkInfo={...this.networkInfo,...e.networkInfo,lastChanged:new Date(e.networkInfo.lastChanged||Date.now())}),e.pendingOperations)try{const t=e.pendingOperations.map(i=>this.deserializeOfflineOperation(i));await this.validateAndRestoreOperations(t)}catch(t){console.warn("Failed to restore pending operations:",t)}e.conflicts&&(this.conflicts=e.conflicts.map(t=>this.deserializeConflict(t)))}serializeOfflineOperation(e){return{...e,timestamp:e.timestamp.toISOString()}}deserializeOfflineOperation(e){return{...e,timestamp:new Date(e.timestamp)}}serializeConflict(e){return{...e,timestamp:e.timestamp.toISOString()}}deserializeConflict(e){return{...e,timestamp:new Date(e.timestamp)}}serializeStats(e){return{...e,lastSyncTime:e.lastSyncTime?.toISOString()}}async validateAndRestoreOperations(e){const t=e.filter(i=>i.id&&i.type&&i.entity&&i.timestamp);for(const i of t)try{await this.storeOfflineOperation(i)}catch(s){console.warn(`Failed to restore operation ${i.id}:`,s)}}calculateOfflineDuration(){return this.offlineStartTime?Date.now()-this.offlineStartTime.getTime():0}calculateAverageResponseTime(){return 50}calculateDataSyncedOnResume(){return 0}calculateEstimatedBandwidthSaved(e){return e.length*1024}async getLastSyncTime(){try{const e=await d.syncQueue.where("status").equals("completed").orderBy("timestamp").reverse().first();return e?new Date(e.timestamp):void 0}catch{return}}async getCompletedOfflineOperations(){try{return(await d.syncQueue.where("status").equals("completed").toArray()).map(t=>this.convertSyncOperationToOfflineOperation(t))}catch{return[]}}async getFailedOfflineOperations(){try{return(await d.syncQueue.where("status").equals("failed").toArray()).map(t=>this.convertSyncOperationToOfflineOperation(t))}catch{return[]}}convertSyncOperationToOfflineOperation(e){return{id:e.id,type:e.type,entity:e.entity,entityId:e.entityId,userId:e.userId,data:e.data,priority:e.priority,timestamp:new Date(e.timestamp),retryCount:e.retryCount,maxRetries:e.maxRetries,status:e.status}}sortOperationsByPriority(e){const t={critical:4,high:3,normal:2,low:1};return[...e].sort((i,s)=>t[s.priority]-t[i.priority])}async retryOperation(e){await d.syncQueue.where("id").equals(e.id).modify({status:"pending",retryCount:e.retryCount+1})}async calculateHistoricalReliability(){try{const e=new Date(Date.now()-36e5),t=await d.syncQueue.where("timestamp").above(e).toArray();return t.length===0?1:t.filter(s=>s.status==="completed").length/t.length}catch{return .9}}async predictAndPreventConflicts(e){const t=[];for(const i of e)if(i.entityId){const s=await this.checkPotentialConflict(i);s&&t.push(s)}return t}async checkPotentialConflict(e){try{const t=await d.syncQueue.where("entity").equals(e.entity).and(r=>r.entityId===e.entityId).reverse().limit(5).toArray();if(t.length===0)return null;const i=new Date(Date.now()-5*60*1e3),s=t.filter(r=>new Date(r.timestamp)>i&&r.id!==e.id);return s.length>0?{id:crypto.randomUUID(),entityType:e.entity,entityId:e.entityId,localData:e.data,remoteData:s[0].data,conflictType:"simultaneous_edit",timestamp:new Date,resolution:"pending"}:null}catch{return null}}async generatePerformanceOptimization(){const e=await this.getOfflineStats(),t=[],i=[];return e.averageResponseTime>100&&(t.push("建议启用操作批处理以减少响应时间"),i.push(.3)),e.pendingOperations>50&&(t.push("建议增加同步频率或优化队列管理"),i.push(.4)),e.failedOperations>e.completedOfflineOperations*.1&&(t.push("建议检查网络连接并优化重试策略"),i.push(.5)),{recommendations:t,predictedImprovements:i}}async compressOfflineData(e){const t=[];let i=0,s=0;for(const r of e)if(i+=JSON.stringify(r.data).length,JSON.stringify(r.data).length>1024){const n={...r,data:await this.compressData(r.data)};t.push(n),s+=JSON.stringify(n.data).length}else t.push(r),s+=JSON.stringify(r.data).length;return{compressed:t,compressionRatio:i>0?s/i:1}}}const B=new G;class X{syncInProgress=!1;isInitialized=!1;authService=null;lastSyncTime=null;syncVersionMap=new Map;listeners=new Set;conflictListeners=new Set;progressListeners=new Set;syncStrategies=new Map;conflictStrategies=[];batchConfig={maxBatchSize:50,maxBatchPayload:5*1024*1024,timeout:3e4,retryStrategy:"adaptive",compressionEnabled:!0,deduplicationEnabled:!0};performanceStats={totalSyncs:0,successfulSyncs:0,failedSyncs:0,averageSyncTime:0,bandwidthSaved:0,incrementalSyncEfficiency:0,lastSyncMetrics:null};constructor(){this.initialize()}async initialize(){if(!this.isInitialized)try{await this.initializeNetworkIntegration(),await this.initializeOfflineIntegration(),this.initializeSyncStrategies(),this.startBackgroundSync(),this.isInitialized=!0,console.log("Unified Cloud Sync Service initialized successfully")}catch(e){throw console.error("Failed to initialize Unified Cloud Sync Service:",e),e}}async initializeNetworkIntegration(){C.addListener({onNetworkStateChanged:this.handleNetworkStateChange.bind(this),onNetworkEvent:this.handleNetworkEvent.bind(this),onSyncReady:this.handleSyncReady.bind(this)}),C.startMonitoring()}async initializeOfflineIntegration(){B.setEventListeners({onNetworkChange:this.handleOfflineNetworkChange.bind(this),onOfflineOperation:this.handleOfflineOperation.bind(this),onSyncProgress:this.handleOfflineSyncProgress.bind(this),onConflict:this.handleOfflineConflict.bind(this),onSyncComplete:this.handleOfflineSyncComplete.bind(this),onError:this.handleOfflineError.bind(this)})}initializeSyncStrategies(){this.syncStrategies.set("excellent",{batchSize:50,syncInterval:3e4,retryDelay:1e3,compressionEnabled:!1,realTimeSync:!0,priorityFilter:["critical","high","normal","low"]}),this.syncStrategies.set("good",{batchSize:25,syncInterval:6e4,retryDelay:2e3,compressionEnabled:!1,realTimeSync:!0,priorityFilter:["critical","high","normal"]}),this.syncStrategies.set("fair",{batchSize:10,syncInterval:12e4,retryDelay:5e3,compressionEnabled:!0,realTimeSync:!1,priorityFilter:["critical","high"]}),this.syncStrategies.set("poor",{batchSize:5,syncInterval:3e5,retryDelay:1e4,compressionEnabled:!0,realTimeSync:!1,priorityFilter:["critical"]}),this.initializeConflictStrategies()}initializeConflictStrategies(){this.conflictStrategies=[{type:"auto",priority:100,conditions:{conflictType:"delete"},resolution:"local"},{type:"auto",priority:90,conditions:{conflictType:"version"},resolution:"merge",mergeFunction:this.mergeByVersion.bind(this)},{type:"auto",priority:80,conditions:{conflictType:"field"},resolution:"field-specific",mergeFunction:this.mergeFields.bind(this)},{type:"manual",priority:70,conditions:{conflictType:"structure"},resolution:"manual"}]}startBackgroundSync(){setInterval(()=>{this.shouldPerformBackgroundSync()&&this.performIncrementalSync("auto").catch(console.error)},this.getAdaptiveSyncInterval())}setAuthService(e){this.authService=e}onStatusChange(e){return this.listeners.add(e),e(this.getCurrentStatus()),()=>{this.listeners.delete(e)}}getCurrentStatus(){return{isOnline:C.getCurrentStatus().isOnline,lastSyncTime:this.lastSyncTime,pendingOperations:this.getPendingOperationsCount(),syncInProgress:this.syncInProgress,hasConflicts:this.conflictStrategies.length>0}}async queueOperation(e){const t={id:crypto.randomUUID(),type:e.table.slice(0,-1),operation:e.type,version:Date.now(),timestamp:new Date,data:e.data,hash:await this.calculateDataHash(e.data),priority:this.mapOperationPriority(e.data)};await I.addOperation({id:t.id,operationType:e.type,entityType:t.type,entityId:e.localId,data:e.data,timestamp:t.timestamp,priority:t.priority,localVersion:t.version})}async performFullSync(){this.syncVersionMap.clear();const e=await this.getCurrentUserId();await this.performIncrementalSync(e)}getConflicts(){return[]}async resolveConflict(e,t){await this.forceSync()}async persistSyncQueue(){}async restoreSyncQueue(){}async clearSyncQueue(){await I.clearCompletedOperations()}async performIncrementalSync(e){if(this.syncInProgress)throw new Error("Sync already in progress");this.syncInProgress=!0;const t=performance.now();try{this.notifyStatusChange(),this.notifyProgress(0);const i=await this.getSyncContext(e),s=this.syncStrategies.get(i.networkQuality),r=await this.getIncrementalDeltas(e);console.log(`Detected ${r.length} incremental changes`);const n=await this.detectConflicts(r),a=await this.resolveConflicts(n),o=await this.executeBatchSync(r,s,i),c=await this.syncFromCloud(e,s);await this.updateSyncVersionInfo(e,r,c);const l=performance.now()-t,y=await this.calculateEfficiencyMetrics(r,o,l);this.updatePerformanceStats(!0,l,y);const g={syncedEntities:{cards:o.successCount,folders:c.folders||0,tags:c.tags||0,images:c.images||0},conflicts:a,syncTime:l,networkStats:{bandwidthUsed:o.bandwidthUsed,requestsMade:Math.ceil(r.length/s.batchSize),averageLatency:i.networkInfo.rtt||0},efficiency:y};return this.lastSyncTime=new Date,this.performanceStats.lastSyncMetrics=g,this.notifyProgress(100),this.notifyStatusChange(),console.log(`Incremental sync completed in ${l}ms with ${y.syncSpeedImprovement}% efficiency improvement`),g}catch(i){throw console.error("Incremental sync failed:",i),this.updatePerformanceStats(!1,performance.now()-t),i}finally{this.syncInProgress=!1,this.notifyStatusChange()}}async getIncrementalDeltas(e){try{const t=await this.getLastSyncVersion(e),i=await I.getPendingOperationsSinceVersion(t),s=[];for(const r of i){const n={id:r.id,type:r.entityType,operation:r.operationType,version:r.localVersion,timestamp:r.timestamp,data:r.data,hash:await this.calculateDataHash(r.data),priority:r.priority};s.push(n)}return this.sortDeltasByPriority(s)}catch(t){return console.error("Failed to get incremental deltas:",t),[]}}async detectConflicts(e){const t=[];for(const i of e)try{const s=await this.getCloudEntity(i.type,i.entityId);if(!s)continue;const r=s.sync_version||0,n=i.version;if(r>n){const a=await this.calculateContentSimilarity(i.data,s),o={id:crypto.randomUUID(),entityType:i.type,entityId:i.entityId,conflictType:a>.8?"field":"version",localData:i.data,cloudData:s,detectedAt:new Date,confidence:a},c=await this.detectFieldConflicts(i.data,s);c.length>0&&(o.conflictFields=c.map(l=>l.fieldName)),t.push(o)}}catch(s){console.error(`Conflict detection failed for ${i.entityId}:`,s)}return t}async resolveConflicts(e){const t=[];for(const i of e)try{const s=this.selectConflictStrategy(i);switch(s.resolution){case"local":await this.applyLocalResolution(i),i.resolution="local",i.autoResolved=!0;break;case"cloud":await this.applyCloudResolution(i),i.resolution="cloud",i.autoResolved=!0;break;case"merge":if(s.mergeFunction){const r=s.mergeFunction(i.localData,i.cloudData);await this.applyMergedResolution(i,r),i.resolution="merge",i.autoResolved=!0}else i.resolution="manual",i.autoResolved=!1;break;case"manual":i.resolution="manual",i.autoResolved=!1;break}this.notifyConflictListeners(i),t.push(i)}catch(s){console.error(`Failed to resolve conflict ${i.id}:`,s),i.resolution="manual",i.autoResolved=!1,t.push(i)}return t}async executeBatchSync(e,t,i){const s=this.createOptimalBatches(e,t,i);let r=0,n=0,a=0;const o=s.map(async c=>{try{const l=await this.processBatch(c,t,i);r+=l.successCount,n+=l.failureCount,a+=l.bandwidthUsed;const y=(r+n)/e.length*100;return this.notifyProgress(y),l}catch(l){return console.error(`Batch ${c.id} failed:`,l),n+=c.operations.length,{successCount:0,failureCount:c.operations.length,bandwidthUsed:0}}});return await Promise.all(o),{successCount:r,failureCount:n,bandwidthUsed:a,compressionRatio:this.calculateCompressionRatio(s)}}createOptimalBatches(e,t,i){const s=[];let r=[],n=0;const a=this.sortDeltasForBatching(e,i);for(const o of a){const c=this.estimateEntitySize(o);(r.length>=t.batchSize||n+c>this.batchConfig.maxBatchPayload||this.shouldCreateNewBatch(r,o,i))&&(r.length>0&&s.push({id:crypto.randomUUID(),operations:r,estimatedSize:n,priority:this.getBatchPriority(r),networkRequirements:this.getBatchNetworkRequirements(r)}),r=[],n=0),r.push(o),n+=c}return r.length>0&&s.push({id:crypto.randomUUID(),operations:r,estimatedSize:n,priority:this.getBatchPriority(r),networkRequirements:this.getBatchNetworkRequirements(r)}),s}async processBatch(e,t,i){const s=performance.now();let r=0;const n=3;for(;r<=n;)try{const a=await this.prepareBatchRequest(e,t),o=await this.executeBatchRequest(a,t.timeout),c=await this.processBatchResponse(o,e.operations);return await this.markOperationsCompleted(e.operations),{batchId:e.id,successCount:c.successCount,failureCount:c.failureCount,bandwidthUsed:a.size,executionTime:performance.now()-s,retryCount:r}}catch(a){if(r++,r>n)return console.error(`Batch ${e.id} failed after ${n} retries:`,a),await this.markOperationsFailed(e.operations,a),{batchId:e.id,successCount:0,failureCount:e.operations.length,bandwidthUsed:0,executionTime:performance.now()-s,retryCount:r};const o=Math.min(1e3*Math.pow(2,r),3e4);await new Promise(c=>setTimeout(c,o))}throw new Error("Unexpected error in batch processing")}async calculateEfficiencyMetrics(e,t,i){const s=this.performanceStats.averageSyncTime||2e3,r=Math.max(0,(s-i)/s*100),n=e.reduce((l,y)=>l+JSON.stringify(y).length,0),a=t.bandwidthUsed,o=(n-a)/n*100,c=n>0?a/n:1;return{syncSpeedImprovement:Math.min(100,r),bandwidthReduction:Math.min(100,o),compressionRatio:c}}updatePerformanceStats(e,t,i){this.performanceStats.totalSyncs++,e?this.performanceStats.successfulSyncs++:this.performanceStats.failedSyncs++;const s=this.performanceStats.averageSyncTime*(this.performanceStats.totalSyncs-1)+t;this.performanceStats.averageSyncTime=s/this.performanceStats.totalSyncs,i&&(this.performanceStats.incrementalSyncEfficiency=i.syncSpeedImprovement,this.performanceStats.bandwidthSaved+=i.bandwidthReduction)}handleNetworkStateChange(e){const t=this.isOnline;this.isOnline=e.isOnline,!t&&this.isOnline&&this.performIncrementalSync("network-recovery").catch(console.error),this.notifyStatusChange()}handleNetworkEvent(e){console.log("Network event:",e)}handleSyncReady(){this.syncInProgress||this.performIncrementalSync("sync-ready").catch(console.error)}handleOfflineNetworkChange(e){this.isOnline=e.status==="online",this.notifyStatusChange()}handleOfflineOperation(e){console.log("Offline operation:",e)}handleOfflineSyncProgress(e){this.notifyProgress(e.completed/e.total*100)}handleOfflineConflict(e){console.log("Offline conflict:",e)}handleOfflineSyncComplete(e){console.log("Offline sync complete:",e),this.notifyStatusChange()}handleOfflineError(e){console.error("Offline error:",e)}async getSyncContext(e){const t=C.getCurrentStatus();return{userId:e,isOnline:t.isOnline,networkQuality:t.quality,networkInfo:t,devicePerformance:this.getDevicePerformance(),timestamp:new Date}}shouldPerformBackgroundSync(){return this.isOnline&&!this.syncInProgress&&this.hasPendingOperations()&&this.isWithinSyncWindow()}getAdaptiveSyncInterval(){switch(C.getCurrentStatus().quality){case"excellent":return 3e4;case"good":return 6e4;case"fair":return 12e4;case"poor":return 3e5;default:return 6e4}}hasPendingOperations(){return!0}getPendingOperationsCount(){return 0}isWithinSyncWindow(){const e=new Date().getHours();return e>=6&&e<=22}async getCurrentUserId(){return"current-user"}async getLastSyncVersion(e){return this.syncVersionMap.get(e)?.localVersion||0}async calculateDataHash(e){const t=JSON.stringify(e),s=new TextEncoder().encode(t),r=await crypto.subtle.digest("SHA-256",s);return Array.from(new Uint8Array(r)).map(a=>a.toString(16).padStart(2,"0")).join("")}async calculateContentSimilarity(e,t){const i=JSON.stringify(e),s=JSON.stringify(t),r=i.length>s.length?i:s,n=i.length>s.length?s:i;if(r.length===0)return 1;const a=this.calculateEditDistance(r,n);return(r.length-a)/r.length}calculateEditDistance(e,t){const i=Array(t.length+1).fill(null).map(()=>Array(e.length+1).fill(null));for(let s=0;s<=e.length;s++)i[0][s]=s;for(let s=0;s<=t.length;s++)i[s][0]=s;for(let s=1;s<=t.length;s++)for(let r=1;r<=e.length;r++){const n=e[r-1]===t[s-1]?0:1;i[s][r]=Math.min(i[s][r-1]+1,i[s-1][r]+1,i[s-1][r-1]+n)}return i[t.length][e.length]}mapOperationPriority(e){return e.priority==="critical"?"critical":e.type==="delete"?"high":"normal"}sortDeltasByPriority(e){const t={critical:4,high:3,normal:2,low:1};return[...e].sort((i,s)=>t[s.priority]-t[i.priority])}sortDeltasForBatching(e,t){return this.sortDeltasByPriority(e)}estimateEntitySize(e){return JSON.stringify(e).length}shouldCreateNewBatch(e,t,i){return!1}getBatchPriority(e){const t=e.map(i=>i.priority);return t.includes("critical")?"critical":t.includes("high")?"high":"normal"}getBatchNetworkRequirements(e){return"any"}async prepareBatchRequest(e,t){const i=e.operations;let s=JSON.stringify(i).length;return t.compressionEnabled&&s>1024&&(s=Math.floor(s*.7)),{operations:i,size:s,compressed:t.compressionEnabled}}async executeBatchRequest(e,t){return await new Promise(i=>setTimeout(i,100)),{success:!0,processed:e.operations.length}}async processBatchResponse(e,t){return{successCount:t.length,failureCount:0,conflicts:[]}}calculateCompressionRatio(e){const t=e.reduce((s,r)=>s+r.estimatedSize,0),i=e.reduce((s,r)=>s+r.estimatedSize*.7,0);return t>0?i/t:1}async markOperationsCompleted(e){}async markOperationsFailed(e,t){}notifyStatusChange(){const e=this.getCurrentStatus();this.listeners.forEach(t=>{try{t(e)}catch(i){console.error("Error in sync status listener:",i)}})}notifyConflictListeners(e){this.conflictListeners.forEach(t=>{try{t(e)}catch(i){console.error("Error in conflict listener:",i)}})}notifyProgress(e){this.progressListeners.forEach(t=>{try{t(e)}catch(i){console.error("Error in progress listener:",i)}})}getDevicePerformance(){return"medium"}mergeByVersion(e,t){const i=e.sync_version||0;return(t.sync_version||0)>i?t:e}mergeFields(e,t){const i={...e};return Object.keys(t).forEach(s=>{e[s]===void 0&&(i[s]=t[s])}),i}selectConflictStrategy(e){return this.conflictStrategies.find(t=>t.conditions.conflictType===e.conflictType)||this.conflictStrategies[this.conflictStrategies.length-1]}async getCloudEntity(e,t){return null}async applyLocalResolution(e){}async applyCloudResolution(e){}async applyMergedResolution(e,t){}async syncFromCloud(e,t){return{}}async updateSyncVersionInfo(e,t,i){}async detectFieldConflicts(e,t){return[]}async forceSync(){}}const v=new X,ce={setAuthService:p=>v.setAuthService(p),onStatusChange:p=>v.onStatusChange(p),getCurrentStatus:()=>v.getCurrentStatus(),queueOperation:p=>v.queueOperation(p),performFullSync:()=>v.performFullSync(),getConflicts:()=>v.getConflicts(),resolveConflict:(p,e)=>v.resolveConflict(p,e),persistSyncQueue:()=>v.persistSyncQueue(),restoreSyncQueue:()=>v.restoreSyncQueue(),clearSyncQueue:()=>v.clearSyncQueue(),get isOnline(){return v.getCurrentStatus().isOnline}};class Z{detectionRules=new Map;resolutionStrategies=new Map;mergeStrategies=new Map;conflictPatterns=new Map;conflictHistory=[];resolutionStats=new Map;conflictPredictionModel;constructor(){this.initializeDetectionRules(),this.initializeResolutionStrategies(),this.initializeMergeStrategies(),this.initializeConflictPatterns(),this.initializeMLModel()}async detectAllConflicts(e,t,i,s,r){const n=[];for(const o of this.detectionRules.values())if(o.enabled&&!(o.entityType!=="all"&&o.entityType!==i))try{const c=await o.detectionFunction(e,t,r);n.push(...c)}catch(c){console.error(`Conflict detection rule ${o.id} failed:`,c)}const a=this.optimizeConflicts(n);return this.recordConflictDetection(a,r),a}async resolveConflicts(e,t){const i=[];for(const s of e)try{const r=await this.resolveSingleConflict(s,t);i.push(r)}catch(r){console.error(`Failed to resolve conflict ${s.id}:`,r),s.resolution="manual",s.autoResolved=!1,i.push(s)}return i}async resolveSingleConflict(e,t){const i=await this.predictResolutionStrategy(e,t),s=this.resolutionStrategies.get(i)||this.selectFallbackStrategy(e),r=await this.applyResolutionStrategy(e,s,t);return this.recordResolutionResult(e,s,r.success),r.conflict}initializeDetectionRules(){this.detectionRules.set("version-conflict",{id:"version-conflict",name:"Version Conflict Detection",description:"检测基于版本号的冲突",entityType:"all",priority:100,enabled:!0,detectionFunction:(e,t,i)=>this.detectVersionConflicts(e,t,i)}),this.detectionRules.set("field-conflict",{id:"field-conflict",name:"Field-Level Conflict Detection",description:"检测字段级别的冲突",entityType:"all",priority:90,enabled:!0,detectionFunction:(e,t,i)=>this.detectFieldConflicts(e,t,i)}),this.detectionRules.set("structure-conflict",{id:"structure-conflict",name:"Structure Conflict Detection",description:"检测数据结构冲突",entityType:"all",priority:80,enabled:!0,detectionFunction:(e,t,i)=>this.detectStructureConflicts(e,t,i)}),this.detectionRules.set("reference-conflict",{id:"reference-conflict",name:"Reference Integrity Conflict Detection",description:"检测引用完整性冲突",entityType:"all",priority:70,enabled:!0,detectionFunction:(e,t,i)=>this.detectReferenceConflicts(e,t,i)}),this.detectionRules.set("business-logic-conflict",{id:"business-logic-conflict",name:"Business Logic Conflict Detection",description:"检测业务逻辑冲突",entityType:"all",priority:60,enabled:!0,detectionFunction:(e,t,i)=>this.detectBusinessLogicConflicts(e,t,i)})}detectVersionConflicts(e,t,i){const s=[],r=e.sync_version||e.localVersion||0,n=t.sync_version||t.cloudVersion||0;return r!==n&&s.push({id:crypto.randomUUID(),entityType:this.inferEntityType(e),entityId:e.id||t.id,conflictType:"version",localData:e,cloudData:t,detectedAt:new Date}),s}detectFieldConflicts(e,t,i){const s=[],r=[],n=this.getComparableFields(e,t);for(const a of n){const o=this.getNestedValue(e,a),c=this.getNestedValue(t,a);this.valuesEqual(o,c)||r.push(a)}return r.length>0&&s.push({id:crypto.randomUUID(),entityType:this.inferEntityType(e),entityId:e.id||t.id,conflictType:"field",localData:e,cloudData:t,conflictFields:r,detectedAt:new Date}),s}detectStructureConflicts(e,t,i){const s=[],r=new Set(Object.keys(e)),n=new Set(Object.keys(t)),a=[...n].filter(c=>!r.has(c)),o=[...r].filter(c=>!n.has(c));return(a.length>0||o.length>0)&&s.push({id:crypto.randomUUID(),entityType:this.inferEntityType(e),entityId:e.id||t.id,conflictType:"structure",localData:e,cloudData:t,conflictFields:[...a,...o],detectedAt:new Date}),s}detectReferenceConflicts(e,t,i){const s=[];if((e.folderId!==void 0||t.folderId!==void 0)&&e.folderId!==t.folderId&&s.push({id:crypto.randomUUID(),entityType:"card",entityId:e.id||t.id,conflictType:"field",localData:e,cloudData:t,conflictFields:["folderId"],detectedAt:new Date}),e.tags!==void 0||t.tags!==void 0){const r=new Set(e.tags||[]),n=new Set(t.tags||[]);this.setsEqual(r,n)||s.push({id:crypto.randomUUID(),entityType:this.inferEntityType(e),entityId:e.id||t.id,conflictType:"field",localData:e,cloudData:t,conflictFields:["tags"],detectedAt:new Date})}return s}detectBusinessLogicConflicts(e,t,i){const s=[];if(e.frontContent||t.frontContent){const r=this.detectContentConflicts(e,t);r&&s.push(r)}if(e.style||t.style){const r=this.detectStyleConflicts(e,t);r&&s.push(r)}return s}initializeResolutionStrategies(){this.resolutionStrategies.set("timestamp-priority",{type:"auto",priority:1,conditions:{conflictType:"version"},resolution:"cloud",mergeFunction:(e,t)=>t.updatedAt&&e.updatedAt&&t.updatedAt>e.updatedAt?t:e}),this.resolutionStrategies.set("local-priority",{type:"auto",priority:2,conditions:{conflictType:"field"},resolution:"local",mergeFunction:(e,t)=>e}),this.resolutionStrategies.set("cloud-priority",{type:"auto",priority:3,conditions:{conflictType:"field"},resolution:"cloud",mergeFunction:(e,t)=>t}),this.resolutionStrategies.set("smart-merge",{type:"auto",priority:4,conditions:{conflictType:"field",canMerge:!0},resolution:"merge",mergeFunction:(e,t)=>{const i={...e};return Object.keys(t).forEach(s=>{(!e[s]||t.updatedAt&&e.updatedAt&&t.updatedAt>e.updatedAt)&&(i[s]=t[s])}),i}})}initializeMergeStrategies(){this.mergeStrategies.set("smart-text-merge",{id:"smart-text-merge",name:"Smart Text Merge",description:"智能合并文本内容，保留两边的修改",applicableTypes:["card"],mergeFunction:(e,t,i)=>this.smartTextMerge(e,t),confidence:.8}),this.mergeStrategies.set("timestamp-priority",{id:"timestamp-priority",name:"Timestamp Priority",description:"使用最新的时间戳决定优先级",applicableTypes:["all"],mergeFunction:(e,t,i)=>this.timestampPriorityMerge(e,t),confidence:.9}),this.mergeStrategies.set("field-smart-merge",{id:"field-smart-merge",name:"Field Smart Merge",description:"按字段类型智能选择最佳合并策略",applicableTypes:["all"],mergeFunction:(e,t,i)=>this.fieldSmartMerge(e,t),confidence:.85}),this.mergeStrategies.set("user-preference-merge",{id:"user-preference-merge",name:"User Preference Merge",description:"基于用户历史偏好进行合并",applicableTypes:["all"],mergeFunction:(e,t,i)=>this.userPreferenceMerge(e,t,i),confidence:.75}),this.mergeStrategies.set("ml-merge",{id:"ml-merge",name:"Machine Learning Merge",description:"使用机器学习模型预测最佳合并策略",applicableTypes:["all"],mergeFunction:(e,t,i)=>this.mlMerge(e,t,i),confidence:.7})}smartTextMerge(e,t){const i={...e};return e.frontContent&&t.frontContent&&(i.frontContent=this.mergeContent(e.frontContent,t.frontContent)),e.backContent&&t.backContent&&(i.backContent=this.mergeContent(e.backContent,t.backContent)),i}timestampPriorityMerge(e,t){const i=new Date(e.updatedAt||e.timestamp).getTime();return new Date(t.updatedAt||t.timestamp).getTime()>i?{...t}:{...e}}fieldSmartMerge(e,t){const i={...e};return Object.keys(t).forEach(s=>{e[s]===void 0?i[s]=t[s]:this.valuesEqual(e[s],t[s])||(i[s]=this.mergeFieldByType(s,e[s],t[s]))}),i}userPreferenceMerge(e,t,i){switch(this.analyzeUserPreference(i.userId)){case"local-first":return{...e};case"cloud-first":return{...t};case"smart-merge":return this.fieldSmartMerge(e,t);default:return this.timestampPriorityMerge(e,t)}}mlMerge(e,t,i){const s=this.extractFeatures(e,t,i);switch(this.predictMergeStrategy(s).strategy){case"local":return{...e};case"cloud":return{...t};case"merge":return this.fieldSmartMerge(e,t);default:return this.timestampPriorityMerge(e,t)}}initializeMLModel(){this.conflictPredictionModel={patterns:new Map,confidenceThreshold:.7},this.conflictPredictionModel.patterns.set("version-conflict-local",.8),this.conflictPredictionModel.patterns.set("field-conflict-merge",.6),this.conflictPredictionModel.patterns.set("structure-conflict-manual",.9)}async predictResolutionStrategy(e,t){const i=this.extractConflictFeatures(e,t),s=this.findSimilarConflicts(i);return s.length>0?this.getMostSuccessfulStrategy(s):this.heuristicStrategySelection(e,t)}extractConflictFeatures(e,t){return{conflictType:e.conflictType,entityType:e.entityType,fieldCount:e.conflictFields?.length||0,timeOfDay:t.timestamp.getHours(),dayOfWeek:t.timestamp.getDay(),networkQuality:t.networkInfo.effectiveType,deviceType:t.deviceInfo.deviceType,userHistoryLength:t.syncHistory.length,isWeekend:t.timestamp.getDay()===0||t.timestamp.getDay()===6}}findSimilarConflicts(e){const t=[];for(const i of this.conflictHistory)this.calculateSimilarity(e,i)>.7&&t.push(i);return t}calculateSimilarity(e,t){let i=0;e.conflictType===t.conflictType&&(i+=.3),e.entityType===t.entityType&&(i+=.2);const s=Math.abs(e.fieldCount-(t.conflictFields?.length||0));return i+=Math.max(0,.2-s*.05),i}getComparableFields(e,t){const i=new Set;return i.add("id"),i.add("sync_version"),i.add("updatedAt"),i.add("createdAt"),(e.frontContent||t.frontContent)&&(i.add("frontContent.title"),i.add("frontContent.text"),i.add("frontContent.tags")),(e.backContent||t.backContent)&&(i.add("backContent.title"),i.add("backContent.text"),i.add("backContent.tags")),(e.style||t.style)&&(i.add("style.type"),i.add("style.backgroundColor"),i.add("style.textColor")),(e.folderId!==void 0||t.folderId!==void 0)&&i.add("folderId"),Array.from(i)}getNestedValue(e,t){return t.split(".").reduce((i,s)=>i?.[s],e)}valuesEqual(e,t){return e===t?!0:e==null||t==null||typeof e!=typeof t?!1:typeof e=="object"?JSON.stringify(e)===JSON.stringify(t):!1}setsEqual(e,t){if(e.size!==t.size)return!1;for(const i of e)if(!t.has(i))return!1;return!0}inferEntityType(e){return e.frontContent||e.backContent?"card":e.name&&e.color?"tag":e.name&&e.cardIds?"folder":e.fileName&&e.filePath?"image":"unknown"}mergeContent(e,t){const i={...e};if(e.title!==t.title&&(i.title=this.mergeTextFields(e.title,t.title)),e.text!==t.text&&(i.text=this.mergeTextFields(e.text,t.text)),e.tags||t.tags){const s=new Set(e.tags||[]),r=new Set(t.tags||[]);i.tags=Array.from(new Set([...s,...r]))}return i}mergeTextFields(e,t){return e.length>t.length?e:t}mergeFieldByType(e,t,i){if(e.includes("time")||e.includes("date")){const s=new Date(t).getTime();return new Date(i).getTime()>s?i:t}return e.includes("version")?Math.max(t,i):typeof t=="string"&&typeof i=="string"?this.mergeTextFields(t,i):t}analyzeUserPreference(e){const t=this.resolutionStats.get(e);return!t||t.success>t.failure*2?"smart-merge":"timestamp-priority"}optimizeConflicts(e){const t=new Map;for(const i of e){const s=`${i.entityType}-${i.entityId}-${i.conflictType}`;(!t.has(s)||(t.get(s).priority||0)<(i.priority||0))&&t.set(s,i)}return Array.from(t.values())}recordConflictDetection(e,t){this.conflictHistory.push(...e),this.conflictHistory.length>1e3&&(this.conflictHistory=this.conflictHistory.slice(-500))}recordResolutionResult(e,t,i){const s=`${e.entityType}-${t}`,r=this.resolutionStats.get(s)||{success:0,failure:0};i?r.success++:r.failure++,this.resolutionStats.set(s,r)}initializeConflictPatterns(){this.conflictPatterns.set("simultaneous-edit",{id:"simultaneous-edit",pattern:"同时编辑",description:"多设备同时编辑同一内容",severity:"high",autoResolution:!1,resolutionStrategy:"manual"}),this.conflictPatterns.set("network-partition",{id:"network-partition",pattern:"网络分区",description:"网络分区导致的冲突",severity:"medium",autoResolution:!0,resolutionStrategy:"timestamp-priority"})}detectContentConflicts(e,t){return null}detectStyleConflicts(e,t){return null}selectFallbackStrategy(e){return{type:"manual",priority:0,conditions:{},resolution:"manual"}}async applyResolutionStrategy(e,t,i){return{conflict:e,success:!0}}getMostSuccessfulStrategy(e){return"timestamp-priority"}heuristicStrategySelection(e,t){return"timestamp-priority"}extractFeatures(e,t,i){return{}}predictMergeStrategy(e){return{strategy:"merge",confidence:.7}}}const z=new Z;class Y{isProcessing=!1;processingInterval;retryDelays=[1e3,2e3,5e3,1e4,3e4];batchSize=10;maxConcurrentBatches=3;currentBatches=0;listeners={};constructor(){this.initializeQueue(),this.startQueueProcessor()}async enqueueOperation(e){const t={...e,id:crypto.randomUUID(),status:"pending",timestamp:new Date};try{return e.dependencies&&e.dependencies.length>0&&await this.validateDependencies(e.dependencies),await d.syncQueue.add({id:t.id,type:e.type,entity:e.entity,entityId:e.entityId,userId:e.userId,data:e.data,priority:e.priority,timestamp:t.timestamp,retryCount:e.retryCount,maxRetries:e.maxRetries,error:e.error}),this.notifyStatusChange(),e.priority==="high"&&!this.isProcessing&&this.processNextBatch(),t.id}catch(i){throw console.error("Failed to enqueue operation:",i),i}}async enqueueBatch(e){const t=e.map(i=>({...i,id:crypto.randomUUID(),status:"pending",timestamp:new Date}));try{const i=t.filter(r=>r.dependencies&&r.dependencies.length>0).flatMap(r=>r.dependencies);i.length>0&&await this.validateDependencies(i);const s=t.map(r=>({id:r.id,type:r.type,entity:r.entity,entityId:r.entityId,userId:r.userId,data:r.data,priority:r.priority,timestamp:r.timestamp,retryCount:r.retryCount,maxRetries:r.maxRetries,error:r.error}));return await d.syncQueue.bulkAdd(s),this.notifyStatusChange(),t.map(r=>r.id)}catch(i){throw console.error("Failed to enqueue batch operations:",i),i}}async dequeueOperation(e){try{const t=await d.syncQueue.where("id").equals(e).delete();return this.notifyStatusChange(),t>0}catch(t){return console.error("Failed to dequeue operation:",t),!1}}async updateOperationStatus(e,t,i){try{await d.syncQueue.where("id").equals(e).modify({status:t,error:i,...t==="processing"?{retryCount:Dexie.currentTransaction?.table("syncQueue").get(e).then(r=>(r?.retryCount||0)+1)}:{}}),this.notifyStatusChange();const s=await d.syncQueue.get(e);s&&this.listeners.onOperationComplete&&this.listeners.onOperationComplete(this.convertSyncOperationToQueueOperation(s),t==="completed")}catch(s){console.error("Failed to update operation status:",s)}}async processNextBatch(){if(!(this.isProcessing||this.currentBatches>=this.maxConcurrentBatches)){this.isProcessing=!0,this.currentBatches++;try{const e=await this.getNextBatch();if(e.length===0){this.isProcessing=!1,this.currentBatches--;return}const t=e.map(s=>s.id);await this.markOperationsProcessing(t);const i=await this.processBatch(e);this.listeners.onBatchComplete&&this.listeners.onBatchComplete(i)}catch(e){console.error("Error processing batch:",e),this.listeners.onQueueError&&this.listeners.onQueueError(e instanceof Error?e:new Error(String(e)))}finally{this.isProcessing=!1,this.currentBatches--,setTimeout(()=>this.processNextBatch(),100)}}}async getNextBatch(){try{return await d.syncQueue.where("status").equals("pending").orderBy("priority").reverse().offset(0).limit(this.batchSize).toArray()}catch(e){return console.error("Failed to get next batch:",e),[]}}async markOperationsProcessing(e){await d.syncQueue.where("id").anyOf(e).modify({status:"processing"})}async processBatch(e){const t=crypto.randomUUID(),i=performance.now(),s=[],r=[],n=[];try{for(const o of e)try{await this.executeSyncOperation(o)?(s.push(o.id),await this.updateOperationStatus(o.id,"completed")):(r.push(o.id),n.push(`Sync failed for operation ${o.id}`),await this.handleOperationFailure(o,"Sync execution failed"))}catch(c){r.push(o.id);const l=c instanceof Error?c.message:String(c);n.push(l),await this.handleOperationFailure(o,l)}const a=performance.now()-i;return{batchId:t,operations:e.length,successful:s.length,failed:r.length,errors:n,executionTime:a,timestamp:new Date}}catch(a){const o=performance.now()-i,c=a instanceof Error?a.message:String(a);for(const l of e)await this.handleOperationFailure(l,c);return{batchId:t,operations:e.length,successful:0,failed:e.length,errors:[c],executionTime:o,timestamp:new Date}}}async executeSyncOperation(e){try{const t=await this.analyzeOperationConflicts(e);return t.highRisk>0?(console.warn(`High conflict risk detected for operation ${e.id}, applying conflict resolution`),await this.executeWithConflictResolution(e,t)):await this.performSyncOperation(e)}catch(t){return console.error(`Sync operation failed for ${e.id}:`,t),!1}}async analyzeOperationConflicts(e){try{const t=await d.syncQueue.where("entityId").equals(e.entityId).filter(l=>Math.abs(l.timestamp.getTime()-e.timestamp.getTime())<3e5&&l.id!==e.id).toArray();let i=0,s=0,r=0;const n=[];t.length>2&&(i++,n.push("Multiple concurrent operations on same entity")),(await d.syncQueue.where("userId").equals(e.userId).filter(l=>Date.now()-l.timestamp.getTime()<60*1e3).toArray()).length>10&&(i++,n.push("User operating too frequently"));const c=(await d.syncQueue.where("entity").equals(e.entity).filter(l=>l.status==="failed").toArray()).length/Math.max(1,await d.syncQueue.count());return c>.3&&(s++,n.push(`High failure rate (${(c*100).toFixed(1)}%) for entity type`)),e.type==="delete"&&(s++,n.push("Delete operations require extra caution")),{highRisk:i,mediumRisk:s,lowRisk:r,recommendations:n}}catch(t){return console.error("Failed to analyze operation conflicts:",t),{highRisk:0,mediumRisk:1,lowRisk:0,recommendations:["Unable to analyze conflicts"]}}}async executeWithConflictResolution(e,t){try{const i={userId:e.userId||"",timestamp:new Date,networkInfo:{effectiveType:"4g"},deviceInfo:{deviceType:"unknown"},userPreferences:{},syncHistory:[]},s=await this.fetchCloudData(e),r=await this.fetchLocalData(e),n=await z.detectAllConflicts(r,s,e.entity,e.entityId,i);if(n.length>0){console.log(`Detected ${n.length} conflicts for operation ${e.id}`);const a=await z.resolveConflicts(n,i),o=a.filter(l=>l.resolution==="manual");if(o.length>0)return console.warn(`Unable to auto-resolve ${o.length} conflicts for operation ${e.id}`),!1;const c=this.extractResolvedData(a,r,s);return await this.performSyncOperation({...e,data:c})}return await this.performSyncOperation(e)}catch(i){return console.error(`Conflict resolution failed for operation ${e.id}:`,i),!1}}async performSyncOperation(e){switch(await new Promise(t=>setTimeout(t,Math.random()*200+100)),e.type){case"create":return await this.performCreateOperation(e);case"update":return await this.performUpdateOperation(e);case"delete":return await this.performDeleteOperation(e);default:return console.warn(`Unknown operation type: ${e.type}`),!1}}async fetchCloudData(e){return{id:e.entityId,updatedAt:new Date().toISOString(),version:Math.floor(Math.random()*100)}}async fetchLocalData(e){return{id:e.entityId,updatedAt:new Date().toISOString(),version:Math.floor(Math.random()*100),...e.data}}extractResolvedData(e,t,i){return{...t,resolvedAt:new Date().toISOString(),conflictCount:e.length}}async performCreateOperation(e){const t=e.priority==="high"?.95:.85;return Math.random()<t}async performUpdateOperation(e){const t=e.priority==="high"?.9:.8;return Math.random()<t}async performDeleteOperation(e){const t=e.priority==="high"?.85:.75;return Math.random()<t}async handleOperationFailure(e,t){const i=e.retryCount+1;if(i>=e.maxRetries)await this.updateOperationStatus(e.id,"failed",t);else{const s=this.retryDelays[Math.min(i-1,this.retryDelays.length-1)];await d.syncQueue.where("id").equals(e.id).modify({retryCount:i,status:"retrying",error:t}),setTimeout(async()=>{await d.syncQueue.where("id").equals(e.id).modify({status:"pending"}),this.notifyStatusChange()},s)}}async validateDependencies(e){const t=await d.syncQueue.where("id").anyOf(e).and(i=>i.status==="pending"||i.status==="processing").count();if(t>0)throw new Error(`Cannot enqueue operation: ${t} dependencies are still pending`)}async canExecuteOperation(e){return!e.dependencies||e.dependencies.length===0?!0:(await d.syncQueue.where("id").anyOf(e.dependencies).toArray()).every(i=>i.status==="completed")}async getQueueStats(){const e=await d.syncQueue.toArray(),t={totalOperations:e.length,byStatus:{pending:0,processing:0,completed:0,failed:0,retrying:0},byPriority:{high:0,normal:0,low:0},byEntity:{card:0,folder:0,tag:0,image:0},averageWaitTime:0};e.forEach(r=>{t.byStatus[r.status]++,t.byPriority[r.priority]++,t.byEntity[r.entity]++});const i=e.filter(r=>r.status==="pending"||r.status==="retrying");if(i.length>0){const r=Date.now(),n=i.reduce((a,o)=>a+(r-new Date(o.timestamp).getTime()),0);t.averageWaitTime=n/i.length}const s=e.filter(r=>r.status==="pending").sort((r,n)=>new Date(r.timestamp).getTime()-new Date(n.timestamp).getTime())[0];return s&&(t.oldestOperation=new Date(s.timestamp)),t}async cleanupCompletedOperations(e=24*60*60*1e3){const t=new Date(Date.now()-e),i=await d.syncQueue.where("status").equals("completed").and(s=>new Date(s.timestamp)<t).delete();return this.notifyStatusChange(),i}async retryFailedOperations(){const e=await d.syncQueue.where("status").equals("failed").modify({status:"pending",retryCount:0,error:void 0});return this.notifyStatusChange(),e>0&&this.processNextBatch(),e}async getOperations(e){let t=d.syncQueue.toCollection();return e?.status&&(t=t.where("status").equals(e.status)),e?.priority&&(t=t.where("priority").equals(e.priority)),e?.entity&&(t=t.where("entity").equals(e.entity)),e?.userId&&(t=t.where("userId").equals(e.userId)),e?.offset&&(t=t.offset(e.offset)),e?.limit&&(t=t.limit(e.limit)),(await t.toArray()).map(s=>this.convertSyncOperationToQueueOperation(s))}setEventListeners(e){this.listeners={...this.listeners,...e}}notifyStatusChange(){this.listeners.onStatusChange&&this.getQueueStats().then(e=>{this.listeners.onStatusChange(e)}).catch(console.error)}initializeQueue(){this.checkRetryOperations()}startQueueProcessor(){this.processingInterval=setInterval(()=>{this.isProcessing||this.processNextBatch()},5e3),setInterval(()=>{this.optimizeQueueProcessing().catch(console.error)},12e4),typeof window<"u"&&window.addEventListener&&window.addEventListener("online",()=>{this.isProcessing||this.processNextBatch()})}async checkRetryOperations(){try{const e=await d.syncQueue.where("status").equals("retrying").toArray();for(const t of e)await d.syncQueue.where("id").equals(t.id).modify({status:"pending"});e.length>0&&(this.notifyStatusChange(),this.processNextBatch())}catch(e){console.error("Failed to check retry operations:",e)}}stop(){this.processingInterval&&(clearInterval(this.processingInterval),this.processingInterval=void 0)}pause(){this.isProcessing=!0}resume(){this.isProcessing=!1,this.processNextBatch()}convertSyncOperationToQueueOperation(e){return{id:e.id,type:e.type,entity:e.entity,entityId:e.entityId,userId:e.userId,data:e.data,priority:e.priority,timestamp:new Date(e.timestamp),retryCount:e.retryCount,maxRetries:e.maxRetries,status:e.status,error:e.error}}async optimizeQueueProcessing(){try{const e=await this.getQueueStats();this.adjustProcessingStrategy(e),this.adjustBatchSize(e),await this.rebalancePriorities(e),await this.cleanupExpiredOperations()}catch(e){console.error("Failed to optimize queue processing:",e)}}adjustProcessingStrategy(e){const{totalOperations:t,byStatus:i,byPriority:s}=e;t>1e3?(this.batchSize=5,this.maxConcurrentBatches=2,console.log("Queue under high load, adjusting strategy: batch=5, concurrent=2")):t>500?(this.batchSize=8,this.maxConcurrentBatches=3,console.log("Queue under medium load, adjusting strategy: batch=8, concurrent=3")):(this.batchSize=15,this.maxConcurrentBatches=5,console.log("Queue under normal load, adjusting strategy: batch=15, concurrent=5"));const r=i.failed/t;r>.3?(this.retryDelays=[2e3,5e3,15e3,3e4,6e4],console.log("High failure rate detected, increased retry delays")):r<.1&&(this.retryDelays=[1e3,2e3,5e3,1e4,3e4],console.log("Normal failure rate, restored retry delays"))}adjustBatchSize(e){const{byPriority:t,totalOperations:i}=e,s=t.high/i;s>.3&&(this.batchSize=Math.max(3,Math.floor(this.batchSize*.7)),console.log(`High priority ratio (${(s*100).toFixed(1)}%), reduced batch size to ${this.batchSize}`));const r=byEntity.card/i;r>.7&&(this.batchSize=Math.min(20,Math.floor(this.batchSize*1.2)),console.log(`Card operation ratio (${(r*100).toFixed(1)}%), increased batch size to ${this.batchSize}`))}async rebalancePriorities(e){const{byStatus:t,byPriority:i}=e,s=await d.syncQueue.where("priority").equals("high").filter(n=>Date.now()-n.timestamp.getTime()>5*60*1e3).toArray();s.length>0&&(await d.syncQueue.where("id").anyOf(s.map(n=>n.id)).modify({priority:"high"}),console.log(`Escalated ${s.length} old high-priority operations`));const r=await d.syncQueue.where("priority").equals("normal").filter(n=>Date.now()-n.timestamp.getTime()>10*60*1e3).toArray();r.length>0&&(await d.syncQueue.where("id").anyOf(r.map(n=>n.id)).modify({priority:"high"}),console.log(`Escalated ${r.length} old normal-priority operations`))}async cleanupExpiredOperations(){const e=Date.now()-864e5,t=await d.syncQueue.where("timestamp").below(e).filter(i=>i.status==="failed").toArray();if(t.length>0){for(const i of t)await d.syncQueue.delete(i.id);console.log(`Cleaned up ${t.length} expired failed operations`)}}async predictAndPreventConflicts(e){const t=[],i=[],s={highRisk:0,mediumRisk:0,lowRisk:0};for(const r of e){const n=await this.assessConflictRisk(r);n==="high"?(i.push(r),s.highRisk++):n==="medium"?(i.push(r),s.mediumRisk++):(t.push(r),s.lowRisk++)}return{safeOperations:t,riskyOperations:i,conflictPrediction:s}}async assessConflictRisk(e){try{return(await d.syncQueue.where("entityId").equals(e.entityId).filter(n=>Math.abs(n.timestamp.getTime()-e.timestamp.getTime())<3e5&&n.id!==e.id).toArray()).length>2||(await d.syncQueue.where("userId").equals(e.userId).filter(n=>Date.now()-n.timestamp.getTime()<60*1e3).toArray()).length>10?"high":(await d.syncQueue.where("entity").equals(e.entity).filter(n=>n.status==="failed").toArray()).length/Math.max(1,await d.syncQueue.count())>.3?"medium":"low"}catch(t){return console.error("Failed to assess conflict risk:",t),"medium"}}async getQueuePerformanceMetrics(){try{const e=await this.getQueueStats(),t=await d.syncQueue.where("status").equals("completed").filter(f=>Date.now()-f.timestamp.getTime()<60*1e3).toArray(),i=t.length,s=await Promise.all(t.map(async f=>(await d.syncQueue.get(f.id))?.processingTime||0)),r=s.length>0?s.reduce((f,k)=>f+k,0)/s.length:0,n=await d.syncQueue.filter(f=>Date.now()-f.timestamp.getTime()<60*1e3).toArray(),a=n.length>0?t.length/n.length:1,o=this.calculateQueueEfficiency(e,i),c=await this.calculateConflictResolutionRate(),l=this.calculateResourceUtilization(e,i),y=this.analyzeBottlenecks(e,i,r),g=await this.generatePredictiveInsights(e,i);return{throughput:i,averageProcessingTime:r,successRate:a,queueEfficiency:o,bottleneckAnalysis:y,conflictResolutionRate:c,resourceUtilization:l,predictiveInsights:g}}catch(e){return console.error("Failed to get queue performance metrics:",e),{throughput:0,averageProcessingTime:0,successRate:0,queueEfficiency:0,bottleneckAnalysis:["Unable to analyze performance"],conflictResolutionRate:0,resourceUtilization:0,predictiveInsights:{predictedLoad:0,recommendedActions:["Enable performance monitoring"],riskAssessment:"medium"}}}}async calculateConflictResolutionRate(){try{const e=await d.syncQueue.filter(i=>Date.now()-i.timestamp.getTime()<18e5).toArray();return e.length===0?1:e.filter(i=>i.status==="completed"&&i.error===null).length/e.length}catch(e){return console.error("Failed to calculate conflict resolution rate:",e),0}}calculateResourceUtilization(e,t){let i=.3;return e.totalOperations>500?i+=.4:e.totalOperations>200?i+=.2:e.totalOperations>50&&(i+=.1),t>15?i+=.2:t>8&&(i+=.1),e.byStatus.failed/Math.max(1,e.totalOperations)>.2&&(i-=.1),Math.max(0,Math.min(1,i))}async generatePredictiveInsights(e,t){const i=[];let s="low";const r=await this.predictFutureLoad(e,t);return r>1e3?(i.push("Consider increasing batch size and concurrency"),s="high"):r>500&&(i.push("Monitor queue growth closely"),i.push("Consider enabling aggressive cleanup"),s="medium"),t<5&&(i.push("Investigate low throughput causes"),i.push("Check network connectivity")),e.byStatus.failed/Math.max(1,e.totalOperations)>.15&&(i.push("Review and optimize conflict resolution strategies"),i.push("Consider reducing retry delays for failed operations")),e.oldestOperation&&Date.now()-e.oldestOperation.getTime()>30*60*1e3&&(i.push("Process aged operations urgently"),i.push("Consider priority escalation")),{predictedLoad:r,recommendedActions:i,riskAssessment:s}}async predictFutureLoad(e,t){try{const i=new Date(Date.now()-36e5),s=await d.syncQueue.where("timestamp").above(i).toArray();if(s.length===0)return t*2;const r=this.calculateGrowthRate(s),n=e.totalOperations*(1+r);return Math.max(t*2,n)}catch(i){return console.error("Failed to predict future load:",i),t*2}}calculateGrowthRate(e){if(e.length<2)return .1;const t=new Map;e.forEach(o=>{const c=Math.floor(o.timestamp.getTime()/6e5);t.set(c,(t.get(c)||0)+1)});const i=Array.from(t.keys()).sort();if(i.length<2)return .1;const s=i.slice(0,Math.floor(i.length/2)),r=i.slice(Math.floor(i.length/2)),n=s.reduce((o,c)=>o+(t.get(c)||0),0)/s.length,a=r.reduce((o,c)=>o+(t.get(c)||0),0)/r.length;return n===0?.1:Math.max(-.5,Math.min(2,(a-n)/n))}calculateQueueEfficiency(e,t){const{totalOperations:i,byStatus:s}=e;let r=.5;i<100?r+=.3:i<500?r+=.2:i<1e3&&(r+=.1);const n=s.failed/Math.max(1,i);return r-=n*.5,t>20?r+=.2:t>10&&(r+=.1),Math.max(0,Math.min(1,r))}analyzeBottlenecks(e,t,i){const s=[];return e.totalOperations>1e3&&s.push("Queue backlog too large"),t<5&&s.push("Low throughput detected"),i>5e3&&s.push("High processing time"),e.byStatus.failed/Math.max(1,e.totalOperations)>.2&&s.push("High failure rate"),s.length===0&&s.push("No significant bottlenecks detected"),s}}const w=new Y;class ee{static cachedUserId=null;static getCurrentUserId(){if(!this.cachedUserId){const e=U.getCurrentUser();this.cachedUserId=e?.id||null}return this.cachedUserId}static clearUserIdCache(){this.cachedUserId=null}static toDbCard(e,t){const i=new Date,s=t||this.getCurrentUserId();return{id:e.id||crypto.randomUUID(),folderId:e.folderId,frontContent:e.frontContent||{title:"",text:"",tags:[],images:[],lastModified:i},backContent:e.backContent||{title:"",text:"",tags:[],images:[],lastModified:i},isFlipped:e.isFlipped||!1,style:e.style||{type:"solid",backgroundColor:"#ffffff",textColor:"#000000"},userId:s,syncVersion:e.syncVersion||1,lastSyncAt:e.lastSyncAt,pendingSync:e.pendingSync??!0,updatedAt:e.updatedAt||i,searchVector:this.generateSearchVector(e),thumbnailUrl:e.thumbnailUrl}}static fromDbCard(e){const{userId:t,syncVersion:i,lastSyncAt:s,pendingSync:r,searchVector:n,thumbnailUrl:a,...o}=e;return{...o,id:o.id||"",createdAt:new Date(o.createdAt),updatedAt:new Date(o.updatedAt),frontContent:{...o.frontContent,lastModified:new Date(o.frontContent.lastModified)},backContent:{...o.backContent,lastModified:new Date(o.backContent.lastModified)}}}static fromDbCards(e){return e.map(t=>this.fromDbCard(t))}static toDbFolder(e,t){const i=new Date,s=t||this.getCurrentUserId();return{id:e.id||crypto.randomUUID(),name:e.name||"",parentId:e.parentId,description:e.description||"",color:e.color||"#6366f1",icon:e.icon||"folder",order:e.order||0,isExpanded:e.isExpanded??!0,createdAt:e.createdAt||i,userId:s,syncVersion:e.syncVersion||1,lastSyncAt:e.lastSyncAt,pendingSync:e.pendingSync??!0,updatedAt:e.updatedAt||i,fullPath:this.generateFullPath(e),depth:this.calculateFolderDepth(e)}}static fromDbFolder(e){const{userId:t,syncVersion:i,lastSyncAt:s,pendingSync:r,fullPath:n,depth:a,...o}=e;return{...o,id:o.id||"",createdAt:new Date(o.createdAt),updatedAt:new Date(o.updatedAt)}}static toDbTag(e,t){const i=new Date,s=t||this.getCurrentUserId();return{id:e.id||crypto.randomUUID(),name:e.name||"",color:e.color||"#6366f1",description:e.description||"",count:e.count||0,createdAt:e.createdAt||i,userId:s,syncVersion:e.syncVersion||1,lastSyncAt:e.lastSyncAt,pendingSync:e.pendingSync??!0,updatedAt:e.updatedAt||i}}static fromDbTag(e){const{userId:t,syncVersion:i,lastSyncAt:s,pendingSync:r,count:n,...a}=e;return{...a,id:a.id||"",createdAt:new Date(a.createdAt),updatedAt:new Date(a.updatedAt)}}static toDbImage(e,t,i){const s=new Date,r=i||this.getCurrentUserId();return{id:e.id||crypto.randomUUID(),cardId:t,userId:r,fileName:e.fileName||"",filePath:e.url||"",cloudUrl:e.cloudUrl,thumbnailPath:e.thumbnailUrl,metadata:{originalName:e.fileName||e.alt||"",size:e.size||0,width:e.width||0,height:e.height||0,format:e.format||"jpg",compressed:e.compressed??!1,quality:e.quality},storageMode:e.storageMode||"indexeddb",createdAt:e.createdAt||s,updatedAt:e.updatedAt||s,syncVersion:e.syncVersion||1,lastSyncAt:e.lastSyncAt,pendingSync:e.pendingSync??!0}}static fromDbImage(e){const{userId:t,syncVersion:i,lastSyncAt:s,pendingSync:r,fileName:n,filePath:a,thumbnailPath:o,storageMode:c,metadata:l,...y}=e;return{...y,id:y.id||"",url:a,thumbnailUrl:o,alt:l.originalName,width:l.width,height:l.height,aspectRatio:l.width>0&&l.height>0?l.width/l.height:1,size:l.size,format:l.format,compressed:l.compressed,quality:l.quality,storageMode:c,createdAt:new Date(y.createdAt),updatedAt:new Date(y.updatedAt)}}static fromLegacySyncOperation(e){return{id:e.id,type:e.type,entity:e.table.replace("s",""),entityId:e.localId,data:e.data,timestamp:e.timestamp,retryCount:e.retryCount,maxRetries:e.maxRetries,error:e.error,priority:"normal"}}static toLegacySyncOperation(e){return{id:e.id,type:e.type,table:e.entity+"s",data:e.data,localId:e.entityId,timestamp:e.timestamp,retryCount:e.retryCount,maxRetries:e.maxRetries,error:e.error}}static generateSearchVector(e){return[e.frontContent?.title||"",e.frontContent?.text||"",e.backContent?.title||"",e.backContent?.text||"",...e.frontContent?.tags||[],...e.backContent?.tags||[]].join(" ").toLowerCase().replace(/[^\w\s\u4e00-\u9fff]/g," ").replace(/\s+/g," ").trim()}static generateFullPath(e){return e.name||""}static calculateFolderDepth(e){return e.parentId?1:0}static fromCloudCard(e){return{id:e.id,folderId:e.folder_id,frontContent:{title:e.front_content?.title||"",text:e.front_content?.text||"",tags:e.front_content?.tags||[],images:e.front_content?.images||[],lastModified:new Date(e.updated_at)},backContent:{title:e.back_content?.title||"",text:e.back_content?.text||"",tags:e.back_content?.tags||[],images:e.back_content?.images||[],lastModified:new Date(e.updated_at)},isFlipped:!1,style:e.style||{type:"solid",backgroundColor:"#ffffff",textColor:"#000000"},userId:e.user_id,syncVersion:e.sync_version||1,lastSyncAt:new Date(e.updated_at),pendingSync:!1,createdAt:new Date(e.created_at),updatedAt:new Date(e.updated_at),searchVector:this.generateSearchVectorFromCloud(e),thumbnailUrl:e.thumbnail_url}}static fromCloudFolder(e){return{id:e.id,name:e.name,parentId:e.parent_id,description:e.description||"",color:e.color||"#6366f1",icon:e.icon||"folder",order:e.order||0,isExpanded:!0,cardIds:e.card_ids||[],userId:e.user_id,syncVersion:e.sync_version||1,lastSyncAt:new Date(e.updated_at),pendingSync:!1,createdAt:new Date(e.created_at),updatedAt:new Date(e.updated_at),fullPath:e.full_path||e.name,depth:e.depth||0}}static fromCloudTag(e){return{id:e.id,name:e.name,color:e.color||"#6366f1",description:e.description||"",count:e.count||0,userId:e.user_id,syncVersion:e.sync_version||1,lastSyncAt:new Date(e.updated_at),pendingSync:!1,createdAt:new Date(e.created_at),updatedAt:new Date(e.updated_at)}}static toCloudCard(e){return{id:e.id,folder_id:e.folderId,front_content:{title:e.frontContent.title,text:e.frontContent.text,tags:e.frontContent.tags,images:e.frontContent.images},back_content:{title:e.backContent.title,text:e.backContent.text,tags:e.backContent.tags,images:e.backContent.images},style:e.style,user_id:e.userId,sync_version:e.syncVersion,updated_at:e.updatedAt.toISOString(),created_at:e.createdAt.toISOString(),thumbnail_url:e.thumbnailUrl}}static toCloudFolder(e){return{id:e.id,name:e.name,parent_id:e.parentId,description:e.description,color:e.color,icon:e.icon,order:e.order,card_ids:e.cardIds,user_id:e.userId,sync_version:e.syncVersion,updated_at:e.updatedAt.toISOString(),created_at:e.createdAt.toISOString(),full_path:e.fullPath,depth:e.depth}}static toCloudTag(e){return{id:e.id,name:e.name,color:e.color,description:e.description,count:e.count,user_id:e.userId,sync_version:e.syncVersion,updated_at:e.updatedAt.toISOString(),created_at:e.createdAt.toISOString()}}static generateSearchVectorFromCloud(e){return[e.front_content?.title||"",e.front_content?.text||"",e.back_content?.title||"",e.back_content?.text||"",...e.front_content?.tags||[],...e.back_content?.tags||[]].join(" ").toLowerCase().replace(/[^\w\s\u4e00-\u9fff]/g," ").replace(/\s+/g," ").trim()}static validateCardData(e){const t=[];e.frontContent?.title?.trim()||t.push("卡片正面标题不能为空"),e.backContent?.title?.trim()||t.push("卡片背面标题不能为空"),e.style&&!["solid","gradient","glass"].includes(e.style.type)&&t.push("无效的卡片样式类型");const i=s=>{s.forEach((r,n)=>{r.url||t.push(`第${n+1}张图片URL不能为空`),(r.width<=0||r.height<=0)&&t.push(`第${n+1}张图片尺寸无效`)})};return e.frontContent?.images&&i(e.frontContent.images),e.backContent?.images&&i(e.backContent.images),{isValid:t.length===0,errors:t}}static validateFolderData(e){const t=[];return e.name?.trim()||t.push("文件夹名称不能为空"),e.name&&e.name.length>50&&t.push("文件夹名称不能超过50个字符"),e.color&&!/^#[0-9A-Fa-f]{6}$/.test(e.color)&&t.push("文件夹颜色格式无效"),{isValid:t.length===0,errors:t}}static validateTagData(e){const t=[];return e.name?.trim()||t.push("标签名称不能为空"),e.name&&e.name.length>30&&t.push("标签名称不能超过30个字符"),e.color&&!/^#[0-9A-Fa-f]{6}$/.test(e.color)&&t.push("标签颜色格式无效"),{isValid:t.length===0,errors:t}}static batchToDbCards(e,t){return e.map(i=>this.toDbCard(i,t))}static batchToDbFolders(e,t){return e.map(i=>this.toDbFolder(i,t))}static batchToDbTags(e,t){return e.map(i=>this.toDbTag(i,t))}static sanitizeCardData(e){const t={...e};return t.frontContent&&(t.frontContent={...t.frontContent,title:(t.frontContent.title||"").trim(),text:(t.frontContent.text||"").trim(),tags:(t.frontContent.tags||[]).map(i=>i.trim()).filter(Boolean)}),t.backContent&&(t.backContent={...t.backContent,title:(t.backContent.title||"").trim(),text:(t.backContent.text||"").trim(),tags:(t.backContent.tags||[]).map(i=>i.trim()).filter(Boolean)}),t.style&&(t.style={...t.style,backgroundColor:t.style.backgroundColor||"#ffffff",textColor:t.style.textColor||"#000000"}),t}static optimizeImageData(e){return{...e,format:e.format||"jpg",compressed:e.compressed??!0,quality:Math.min(Math.max(e.quality||.8,.1),1)}}static conversionCache=new Map;static CACHE_TTL=5*60*1e3;static cachedConvert(e,t,i){const s=`${e}:${JSON.stringify(t)}`,r=this.conversionCache.get(s);if(r&&Date.now()-r.timestamp<this.CACHE_TTL)return r.data;const n=i(t);return this.conversionCache.set(s,{data:n,timestamp:Date.now()}),n}static clearConversionCache(){this.conversionCache.clear()}static startCacheCleanup(){setInterval(()=>{const e=Date.now();for(const[t,i]of this.conversionCache.entries())e-i.timestamp>this.CACHE_TTL&&this.conversionCache.delete(t)},this.CACHE_TTL)}}const m=new ee;class te{validationCache=new Map;repairHistory=[];isProcessing=!1;constructor(){this.initializeValidator()}initializeValidator(){setInterval(()=>this.cleanupValidationCache(),60*60*1e3)}async validateConsistency(e="relaxed"){if(this.isProcessing)throw new Error("Validation already in progress");this.isProcessing=!0;const t=performance.now();try{const i=`consistency_${e}_${Date.now()}`,s=this.getRecentValidationReport(e);if(s)return s;console.log(`Starting consistency validation (level: ${e})`);const r={timestamp:new Date,level:e,overallStatus:"valid",summary:{totalChecks:0,passedChecks:0,failedChecks:0,warnings:0,errors:0,critical:0},entityCounts:{local:{cards:0,folders:0,tags:0,images:0},cloud:{cards:0,folders:0,tags:0,images:0}},issues:[],confidence:0,validationTime:0},[n,a]=await Promise.all([this.getLocalStatistics(),this.getCloudStatistics()]);return r.entityCounts.local=n,r.entityCounts.cloud=a,await this.performConsistencyChecks(r,e),this.calculateOverallStatus(r),r.confidence=this.calculateValidationConfidence(r),r.validationTime=performance.now()-t,this.validationCache.set(i,r),console.log(`Consistency validation completed: ${r.summary.passedChecks}/${r.summary.totalChecks} checks passed`),r}catch(i){return console.error("Consistency validation failed:",i),{timestamp:new Date,level:e,overallStatus:"error",summary:{totalChecks:1,passedChecks:0,failedChecks:1,warnings:0,errors:1,critical:0},entityCounts:{local:{cards:0,folders:0,tags:0,images:0},cloud:{cards:0,folders:0,tags:0,images:0}},issues:[{id:crypto.randomUUID(),type:"data_corruption",entity:"system",entityId:"validation",severity:"error",message:`Validation failed: ${i instanceof Error?i.message:"Unknown error"}`,autoFixable:!1,suggestedAction:"Retry validation or check system health"}],confidence:0,validationTime:performance.now()-t}}finally{this.isProcessing=!1}}async quickValidation(){try{const e=[],[t,i]=await Promise.all([u.cards.count(),this.getCloudEntityCount("cards")]);Math.abs(t-i)>5&&e.push({id:crypto.randomUUID(),type:"version_mismatch",entity:"cards",entityId:"count",severity:"warning",message:`Card count mismatch: local=${t}, cloud=${i}`,autoFixable:!0,suggestedAction:"Run full sync to resolve count differences"});const s=await dataSyncService.getMetrics();s.reliability<.8&&e.push({id:crypto.randomUUID(),type:"data_corruption",entity:"sync",entityId:"reliability",severity:"warning",message:`Low sync reliability: ${(s.reliability*100).toFixed(1)}%`,autoFixable:!1,suggestedAction:"Check network connectivity and sync logs"});const r=e.length===0||e.every(a=>a.severity==="warning"),n=r?.9:Math.max(.5,1-e.length*.2);return{isConsistent:r,issues:e,confidence:n}}catch(e){return{isConsistent:!1,issues:[{id:crypto.randomUUID(),type:"data_corruption",entity:"system",entityId:"quick_validation",severity:"error",message:`Quick validation failed: ${e instanceof Error?e.message:"Unknown error"}`,autoFixable:!1,suggestedAction:"Retry validation"}],confidence:0}}}async autoRepairIssues(e,t={}){const i=crypto.randomUUID(),s=performance.now(),r={id:i,success:!0,repairedIssues:0,failedRepairs:0,repairedEntities:[],errors:[],duration:0};try{console.log(`Starting auto-repair for ${e.length} issues`);const n=e.sort((a,o)=>{const c={critical:4,error:3,warning:2,valid:1};return c[o.severity]-c[a.severity]});for(const a of n){if(!a.autoFixable&&!t.force){r.errors.push(`Cannot auto-fix ${a.type} for ${a.entity}:${a.entityId}`),r.failedRepairs++;continue}try{t.dryRun?(console.log(`[DRY RUN] Would repair ${a.type} for ${a.entity}:${a.entityId}`),r.repairedIssues++,r.repairedEntities.push(`${a.entity}:${a.entityId}`)):await this.repairIssue(a)?(r.repairedIssues++,r.repairedEntities.push(`${a.entity}:${a.entityId}`)):(r.errors.push(`Failed to repair ${a.type} for ${a.entity}:${a.entityId}`),r.failedRepairs++)}catch(o){const c=`Repair failed for ${a.entity}:${a.entityId}: ${o instanceof Error?o.message:"Unknown error"}`;r.errors.push(c),r.failedRepairs++}}r.success=r.failedRepairs===0,console.log(`Auto-repair completed: ${r.repairedIssues} repaired, ${r.failedRepairs} failed`)}catch(n){r.success=!1,r.errors.push(`Auto-repair failed: ${n instanceof Error?n.message:"Unknown error"}`)}return r.duration=performance.now()-s,this.repairHistory.push(r),r}async repairIssue(e){switch(console.log(`Repairing issue: ${e.type} for ${e.entity}:${e.entityId}`),e.type){case"missing_local":return await this.repairMissingLocal(e);case"missing_cloud":return await this.repairMissingCloud(e);case"version_mismatch":return await this.repairVersionMismatch(e);case"data_corruption":return await this.repairDataCorruption(e);case"relationship_violation":return await this.repairRelationshipViolation(e);default:return console.warn(`Unknown issue type: ${e.type}`),!1}}async repairMissingLocal(e){try{const t=await this.getCloudEntity(e.entity,e.entityId);if(!t)return!1;switch(e.entity){case"card":const i=m.fromCloudCard(t);await u.cards.add(i);break;case"folder":const s=m.fromCloudFolder(t);await u.folders.add(s);break;case"tag":const r=m.fromCloudTag(t);await u.tags.add(r);break;default:return!1}return!0}catch(t){return console.error(`Failed to repair missing local data for ${e.entity}:${e.entityId}:`,t),!1}}async repairMissingCloud(e){try{const t=await this.getLocalEntity(e.entity,e.entityId);if(!t)return!1;switch(e.entity){case"card":const i=m.toCloudCard(t);await h.from("cards").insert(i);break;case"folder":const s=m.toCloudFolder(t);await h.from("folders").insert(s);break;case"tag":const r=m.toCloudTag(t);await h.from("tags").insert(r);break;default:return!1}return!0}catch(t){return console.error(`Failed to repair missing cloud data for ${e.entity}:${e.entityId}:`,t),!1}}async repairVersionMismatch(e){try{const[t,i]=await Promise.all([this.getLocalEntity(e.entity,e.entityId),this.getCloudEntity(e.entity,e.entityId)]);if(!t||!i)return!1;const s=new Date(t.updatedAt).getTime();return new Date(i.updated_at).getTime()>s?await this.repairMissingLocal(e):await this.repairMissingCloud(e)}catch(t){return console.error(`Failed to repair version mismatch for ${e.entity}:${e.entityId}:`,t),!1}}async repairDataCorruption(e){try{return e.details?.corruptionType==="invalid_structure"&&await this.getCloudEntity(e.entity,e.entityId)?await this.repairMissingLocal(e):(console.warn(`Data corruption detected for ${e.entity}:${e.entityId}, attempting repair`),await this.backupCorruptedData(e.entity,e.entityId),await this.deleteLocalEntity(e.entity,e.entityId),await this.repairMissingLocal(e))}catch(t){return console.error(`Failed to repair data corruption for ${e.entity}:${e.entityId}:`,t),!1}}async repairRelationshipViolation(e){try{if(e.details?.relationshipType==="foreign_key"&&e.entity==="card"){const t=await u.cards.get(e.entityId);if(t&&t.folderId&&!await u.folders.get(t.folderId))return await u.cards.update(e.entityId,{folderId:void 0}),!0}return!1}catch(t){return console.error(`Failed to repair relationship violation for ${e.entity}:${e.entityId}:`,t),!1}}async performConsistencyChecks(e,t){const i=[];i.push(this.checkEntityCounts(e)),i.push(this.checkDataIntegrity(e)),t!=="basic"&&(i.push(this.checkVersionConsistency(e)),i.push(this.checkRelationships(e))),t==="strict"&&(i.push(this.checkDataCorruption(e)),i.push(this.checkTimestampConsistency(e))),await Promise.allSettled(i)}async checkEntityCounts(e){e.summary.totalChecks++;const t=["cards","folders","tags","images"];for(const i of t){const s=e.entityCounts.local[i],r=e.entityCounts.cloud[i],n=Math.abs(s-r),a=level==="strict"?0:5;if(n>a){const o=n>20?"error":"warning";e.issues.push({id:crypto.randomUUID(),type:s<r?"missing_local":"missing_cloud",entity:i,entityId:"count",severity:o,message:`${i} count mismatch: local=${s}, cloud=${r} (diff=${n})`,autoFixable:!0,suggestedAction:"Run sync to resolve count differences"}),o==="error"?e.summary.errors++:e.summary.warnings++}else e.summary.passedChecks++}}async checkDataIntegrity(e){e.summary.totalChecks++;try{const t=await this.checkLocalDataIntegrity(),i=await this.checkCloudDataIntegrity();!t.isValid||!i.isValid?(e.issues.push({id:crypto.randomUUID(),type:"data_corruption",entity:"system",entityId:"integrity",severity:"error",message:`Data integrity check failed: local=${t.isValid}, cloud=${i.isValid}`,details:{localErrors:t.errors,cloudErrors:i.errors},autoFixable:!1,suggestedAction:"Manual data inspection required"}),e.summary.errors++):e.summary.passedChecks++}catch{e.summary.failedChecks++,e.summary.errors++}}async checkVersionConsistency(e){e.summary.totalChecks++;try{const i=await this.checkSampleVersionConsistency(100);if(i.length>0){const s=i.length>10?"error":"warning";e.issues.push(...i.map(r=>({...r,severity:s,autoFixable:!0,suggestedAction:"Sync to resolve version conflicts"}))),s==="error"?e.summary.errors+=i.length:e.summary.warnings+=i.length}else e.summary.passedChecks++}catch{e.summary.failedChecks++}}async checkRelationships(e){e.summary.totalChecks++;try{const t=await this.checkRelationshipIntegrity();if(t.length>0){const i=t.some(s=>s.severity==="error")?"error":"warning";e.issues.push(...t),i==="error"?e.summary.errors+=t.length:e.summary.warnings+=t.length}else e.summary.passedChecks++}catch{e.summary.failedChecks++}}async checkDataCorruption(e){e.summary.totalChecks++;try{const t=await this.detectDataCorruption();if(t.length>0){const i="critical";e.issues.push(...t.map(s=>({...s,severity:i,autoFixable:!1,suggestedAction:"Manual data recovery required"}))),e.summary.critical+=t.length}else e.summary.passedChecks++}catch{e.summary.failedChecks++}}async checkTimestampConsistency(e){e.summary.totalChecks++;try{const t=await this.checkTimestampAlignment();if(t.length>0){const i="warning";e.issues.push(...t.map(s=>({...s,severity:i,autoFixable:!0,suggestedAction:"Update timestamps to align with system time"}))),e.summary.warnings+=t.length}else e.summary.passedChecks++}catch{e.summary.failedChecks++}}async getLocalStatistics(){try{const e=await u.getStats();return{cards:e.cards,folders:e.folders,tags:e.tags,images:e.images}}catch(e){return console.error("Failed to get local statistics:",e),{cards:0,folders:0,tags:0,images:0}}}async getCloudStatistics(){try{const e=h.auth.user();if(!e)return{cards:0,folders:0,tags:0,images:0};const[t,i,s,r]=await Promise.all([h.from("cards").select("id",{count:"exact",head:!0}).eq("user_id",e.id),h.from("folders").select("id",{count:"exact",head:!0}).eq("user_id",e.id),h.from("tags").select("id",{count:"exact",head:!0}).eq("user_id",e.id),h.from("images").select("id",{count:"exact",head:!0}).eq("user_id",e.id)]);return{cards:t.count||0,folders:i.count||0,tags:s.count||0,images:r.count||0}}catch(e){return console.error("Failed to get cloud statistics:",e),{cards:0,folders:0,tags:0,images:0}}}async getLocalEntity(e,t){try{switch(e){case"card":return await u.cards.get(t);case"folder":return await u.folders.get(t);case"tag":return await u.tags.get(t);case"image":return await u.images.get(t);default:return null}}catch(i){return console.error(`Failed to get local ${e} ${t}:`,i),null}}async getCloudEntity(e,t){try{const i=h.auth.user();return i?(await h.from(e+"s").select("*").eq("id",t).eq("user_id",i.id).single()).data:null}catch(i){return console.error(`Failed to get cloud ${e} ${t}:`,i),null}}async getCloudEntityCount(e){try{const t=h.auth.user();return t&&(await h.from(e).select("id",{count:"exact",head:!0}).eq("user_id",t.id)).count||0}catch(t){return console.error(`Failed to get cloud ${e} count:`,t),0}}async checkLocalDataIntegrity(){const e=[];try{const t=await u.healthCheck();t.isHealthy||e.push(...t.issues),await this.checkLocalIndexes(e),await this.checkLocalForeignKeys(e)}catch(t){e.push(`Local integrity check failed: ${t instanceof Error?t.message:"Unknown error"}`)}return{isValid:e.length===0,errors:e}}async checkCloudDataIntegrity(){const e=[];try{const{error:t}=await h.from("cards").select("id",{count:"exact",head:!0}).limit(1);t&&e.push(`Cloud connection failed: ${t.message}`)}catch(t){e.push(`Cloud integrity check failed: ${t instanceof Error?t.message:"Unknown error"}`)}return{isValid:e.length===0,errors:e}}async checkSampleVersionConsistency(e){const t=[];try{const i=await u.cards.limit(e).toArray();for(const s of i){const r=await this.getCloudEntity("card",s.id);if(r){const n=new Date(s.updatedAt).getTime(),a=new Date(r.updated_at).getTime();Math.abs(n-a)>6e4&&t.push({type:"version_mismatch",entity:"card",entityId:s.id,severity:"warning",message:`Timestamp mismatch for card ${s.id}: local=${new Date(n).toISOString()}, cloud=${new Date(a).toISOString()}`,autoFixable:!0,suggestedAction:"Sync to resolve timestamp differences"})}}}catch(i){console.error("Failed to check sample version consistency:",i)}return t}async checkRelationshipIntegrity(){const e=[];try{const t=await u.cards.toArray(),i=await u.folders.toCollection().primaryKeys();for(const s of t)s.folderId&&!i.includes(s.folderId)&&e.push({type:"relationship_violation",entity:"card",entityId:s.id,severity:"warning",message:`Card ${s.id} references non-existent folder ${s.folderId}`,details:{relationshipType:"foreign_key",missingId:s.folderId},autoFixable:!0,suggestedAction:"Remove invalid folder reference or create missing folder"})}catch(t){console.error("Failed to check relationship integrity:",t)}return e}async detectDataCorruption(){const e=[];try{const t=await u.cards.toArray();for(const i of t)(!i.frontContent||!i.backContent)&&e.push({type:"data_corruption",entity:"card",entityId:i.id,severity:"critical",message:`Card ${i.id} has missing content structure`,details:{corruptionType:"invalid_structure"},autoFixable:!1,suggestedAction:"Manual data recovery required"}),i.frontContent&&typeof i.frontContent!="object"&&e.push({type:"data_corruption",entity:"card",entityId:i.id,severity:"critical",message:`Card ${i.id} has invalid content format`,details:{corruptionType:"invalid_format"},autoFixable:!1,suggestedAction:"Manual data recovery required"})}catch(t){console.error("Failed to detect data corruption:",t)}return e}async checkTimestampAlignment(){const e=[];try{const t=Date.now(),i=24*60*60*1e3,s=await u.cards.toArray();for(const r of s){const n=new Date(r.updatedAt).getTime();Math.abs(n-t)>i&&e.push({type:"version_mismatch",entity:"card",entityId:r.id,severity:"warning",message:`Card ${r.id} has timestamp ${new Date(n).toISOString()} which is far from current time`,autoFixable:!0,suggestedAction:"Update timestamp to current time"})}}catch(t){console.error("Failed to check timestamp alignment:",t)}return e}async checkLocalIndexes(e){try{const t=performance.now();await u.cards.limit(1).toArray(),performance.now()-t>100&&e.push("Local database query performance may be degraded")}catch(t){e.push(`Index check failed: ${t instanceof Error?t.message:"Unknown error"}`)}}async checkLocalForeignKeys(e){try{const t=await u.healthCheck();t.isHealthy||e.push(...t.issues)}catch(t){e.push(`Foreign key check failed: ${t instanceof Error?t.message:"Unknown error"}`)}}calculateOverallStatus(e){e.summary.critical>0?e.overallStatus="critical":e.summary.errors>0?e.overallStatus="error":e.summary.warnings>0?e.overallStatus="warning":e.overallStatus="valid"}calculateValidationConfidence(e){let t=1;switch(e.summary.critical>0&&(t-=.5),e.summary.errors>0&&(t-=.3),e.summary.warnings>0&&(t-=.1),e.level){case"basic":t*=.8;break;case"relaxed":t*=.9;break;case"strict":t*=1;break}return Math.max(0,Math.min(1,t))}getRecentValidationReport(e){const t=Date.now()-3e5;for(const[i,s]of this.validationCache.entries())if(s.level===e&&s.timestamp.getTime()>t)return s;return null}cleanupValidationCache(){const e=Date.now()-36e5;for(const[t,i]of this.validationCache.entries())i.timestamp.getTime()<e&&this.validationCache.delete(t)}async backupCorruptedData(e,t){try{const i=await this.getLocalEntity(e,t);if(i){const s=`backup_${e}_${t}_${Date.now()}`,r={entity:e,entityId:t,data:i,timestamp:new Date().toISOString()};localStorage.setItem(s,JSON.stringify(r)),console.log(`Backed up corrupted ${e}:${t}`)}}catch(i){console.error(`Failed to backup ${e}:${t}:`,i)}}async deleteLocalEntity(e,t){try{switch(e){case"card":await u.cards.delete(t);break;case"folder":await u.folders.delete(t);break;case"tag":await u.tags.delete(t);break;case"image":await u.images.delete(t);break}}catch(i){console.error(`Failed to delete ${e}:${t}:`,i)}}}const b=new te;class ie{currentState="idle";currentSession=null;syncHistory=[];metrics=this.getDefaultMetrics();listeners=new Set;consistencyCache=new Map;syncIntervals=new Map;isInitialized=!1;retryCount=0;maxRetries=3;autoRepairEnabled=!0;validationLevel=ConsistencyLevel.RELAXED;lastValidationTime=null;batchOptimization={enabled:!0,dynamicBatchSize:!0,minBatchSize:10,maxBatchSize:200,adaptiveDelay:!0,networkAware:!0};performanceMetrics={avgBatchTime:0,avgBatchSize:0,successRate:1,networkLatency:0,lastBatchTime:0};constructor(){this.initialize()}getDefaultMetrics(){return{totalSessions:0,successfulSessions:0,failedSessions:0,averageSessionTime:0,dataThroughput:0,conflictRate:0,reliability:1}}async initialize(){if(!this.isInitialized)try{this.integrateWithSyncQueue(),this.startBackgroundSync(),this.startHealthCheck(),this.startDataValidation(),this.isInitialized=!0,console.log("DataSyncService initialized successfully")}catch(e){throw console.error("Failed to initialize DataSyncService:",e),e}}integrateWithSyncQueue(){w.setEventListeners({onOperationComplete:this.handleQueueOperationComplete.bind(this),onBatchComplete:this.handleQueueBatchComplete.bind(this),onQueueError:this.handleQueueError.bind(this),onStatusChange:this.handleQueueStatusChange.bind(this)})}startBackgroundSync(){const e=this.getAdaptiveSyncInterval();setInterval(()=>{this.shouldPerformBackgroundSync()&&this.performIncrementalSync().catch(console.error)},e),setInterval(()=>{this.checkDataConsistency().catch(console.error)},60*60*1e3),setInterval(()=>{this.cleanupExpiredSessions()},24*60*60*1e3)}startHealthCheck(){setInterval(()=>{this.performHealthCheck().catch(console.error)},10*60*1e3)}async performFullSync(e="bidirectional"){if(this.currentState!=="idle")throw new Error(`Cannot start sync: current state is ${this.currentState}`);if(!await this.validateBeforeSync())throw new Error("Pre-sync validation failed: data consistency issues detected");const i=this.createSyncSession(e);this.currentState="syncing",this.currentSession=i,this.notifyListeners(i);try{const s=performance.now();switch(e){case"upstream":await this.performUpstreamSync(i);break;case"downstream":await this.performDownstreamSync(i);break;case"bidirectional":await this.performBidirectionalSync(i);break}await this.validateAfterSync(i),await this.quickConsistencyCheck(i),i.endTime=new Date,i.duration=performance.now()-s,i.conflicts>0&&i.state==="syncing"&&(i.state="completed"),this.updateMetrics(i),console.log(`Full sync completed: ${i.processed} operations, ${i.conflicts} conflicts`)}catch(s){await this.handleSyncError(i,s)}finally{this.currentState="idle",this.currentSession=null,this.notifyListeners(i)}return i}async performIncrementalSync(){if(this.currentState!=="idle")return console.log("Sync already in progress, skipping incremental sync"),this.currentSession;const e=this.createSyncSession("bidirectional","incremental");this.currentState="syncing",this.currentSession=e,this.notifyListeners(e);try{await this.processPriorityOperations(e),await this.quickConsistencyCheck(e),e.endTime=new Date,e.state="completed",e.duration=e.endTime.getTime()-e.startTime.getTime(),this.updateMetrics(e)}catch(t){await this.handleSyncError(e,t)}finally{this.currentState="idle",this.currentSession=null,this.notifyListeners(e)}return e}async performUpstreamSync(e){console.log("Starting upstream sync (local to cloud)");const t=await this.getLocalChanges();if(t.length===0){console.log("No local changes to sync upstream");return}console.log(`Syncing ${t.length} local changes to cloud`);const i=await this.syncBatchToCloud(t,e);e.processed+=i.length,e.successful+=i.filter(s=>s.success).length,e.failed+=i.filter(s=>!s.success).length,e.conflicts+=i.filter(s=>s.metadata?.conflicts&&s.metadata.conflicts>0).length,e.dataTransferred=i.reduce((s,r)=>s+(r.metadata?.dataSize||0),0),console.log(`Upstream sync completed: ${e.successful}/${e.processed} operations`)}async performDownstreamSync(e){console.log("Starting downstream sync (cloud to local)");const t=await this.getCloudChanges();if(t.length===0){console.log("No cloud changes to sync downstream");return}console.log(`Syncing ${t.length} cloud changes to local`);const i=await this.syncBatchToLocal(t,e);e.processed+=i.length,e.successful+=i.filter(s=>s.success).length,e.failed+=i.filter(s=>!s.success).length,e.conflicts+=i.filter(s=>s.metadata?.conflicts&&s.metadata.conflicts>0).length,e.dataTransferred=i.reduce((s,r)=>s+(r.metadata?.dataSize||0),0),console.log(`Downstream sync completed: ${e.successful}/${e.processed} operations`)}async performBidirectionalSync(e){console.log("Starting bidirectional sync");const[t,i]=await Promise.allSettled([this.performUpstreamSync(e),this.performDownstreamSync(e)]);t.status==="rejected"&&console.error("Upstream sync failed:",t.reason),i.status==="rejected"&&console.error("Downstream sync failed:",i.reason),console.log("Bidirectional sync completed")}async syncBatchToCloud(e,t){if(!this.batchOptimization.enabled)return await this.syncBatchToCloudLegacy(e,t);const i=[],s=performance.now(),r=this.optimizeOperationGrouping(e);for(const[a,o]of Object.entries(r)){console.log(`Processing ${o.length} ${a} operations with optimization`);const c=await this.getOptimalBatchStrategy(o.length,"cloud"),l=await this.processOptimizedCloudBatch(a,o,c,t);i.push(...l)}const n=performance.now()-s;return this.updateBatchPerformanceMetrics(e.length,n,i),i}async processOptimizedCloudBatch(e,t,i,s){const r=[],{batchSize:n,delay:a,parallel:o}=i;if(o&&t.length>n*2){const l=this.chunkOperations(t,n).map(async(g,f)=>(f>0&&await new Promise(k=>setTimeout(k,f*a/2)),this.processCloudBatch(e,g,s)));(await Promise.allSettled(l)).forEach(g=>{g.status==="fulfilled"&&r.push(...g.value)})}else for(let c=0;c<t.length;c+=n){const l=t.slice(c,c+n),y=await this.processCloudBatch(e,l,s);r.push(...y),c+n<t.length&&a>0&&await this.adaptiveDelay(a)}return r}async syncBatchToLocal(e,t){const s=[],r=this.groupOperationsByEntity(e);for(const[n,a]of Object.entries(r)){console.log(`Processing ${a.length} ${n} operations to local`);for(let o=0;o<a.length;o+=100){const c=a.slice(o,o+100),l=await this.processLocalBatch(n,c,t);s.push(...l)}}return s}async processCloudBatch(e,t,i){const s=[];try{await u.transaction("rw",[u.cards,u.folders,u.tags,u.images],async()=>{for(const r of t){const n=await this.executeCloudOperation(e,r,i);s.push(n),n.success&&await this.updateLocalSyncStatus(e,r.id)}})}catch(r){console.error(`Batch operation failed for ${e}:`,r);for(const n of t)s.push({id:n.id,success:!1,entity:e,entityId:n.id,operation:n.type,duration:0,error:r instanceof Error?r.message:"Unknown error"})}return s}async processLocalBatch(e,t,i){const s=[];try{for(const r of t){const n=await this.executeLocalOperation(e,r,i);s.push(n)}}catch(r){console.error(`Local batch operation failed for ${e}:`,r);for(const n of t)s.push({id:n.id,success:!1,entity:e,entityId:n.id,operation:n.type,duration:0,error:r instanceof Error?r.message:"Unknown error"})}return s}async executeCloudOperation(e,t,i){const s=performance.now();try{switch(e){case"card":return await this.syncCardToCloud(t,i);case"folder":return await this.syncFolderToCloud(t,i);case"tag":return await this.syncTagToCloud(t,i);case"image":return await this.syncImageToCloud(t,i);default:throw new Error(`Unknown entity type: ${e}`)}}catch(r){return{id:t.id,success:!1,entity:e,entityId:t.id,operation:t.type,duration:performance.now()-s,error:r instanceof Error?r.message:"Unknown error"}}}async executeLocalOperation(e,t,i){const s=performance.now();try{switch(e){case"card":return await this.syncCardToLocal(t,i);case"folder":return await this.syncFolderToLocal(t,i);case"tag":return await this.syncTagToLocal(t,i);case"image":return await this.syncImageToLocal(t,i);default:throw new Error(`Unknown entity type: ${e}`)}}catch(r){return{id:t.id,success:!1,entity:e,entityId:t.id,operation:t.type,duration:performance.now()-s,error:r instanceof Error?r.message:"Unknown error"}}}async syncCardToCloud(e,t){const i=performance.now();try{const s=m.toCloudCard(e);let r;if(e.syncVersion===1?r=await h.from("cards").insert(s).select().single():r=await h.from("cards").update(s).eq("id",e.id).select().single(),r.error)throw r.error;return{id:e.id,success:!0,entity:"card",entityId:e.id,operation:e.syncVersion===1?"create":"update",duration:performance.now()-i,metadata:{localVersion:e.syncVersion,cloudVersion:r.data.sync_version,dataSize:JSON.stringify(s).length}}}catch(s){return{id:e.id,success:!1,entity:"card",entityId:e.id,operation:e.syncVersion===1?"create":"update",duration:performance.now()-i,error:s instanceof Error?s.message:"Unknown error"}}}async syncCardToLocal(e,t){const i=performance.now();try{const s=m.fromCloudCard(e),r=await u.cards.get(e.id);return r?await u.cards.update(e.id,s):await u.cards.add(s),{id:e.id,success:!0,entity:"card",entityId:e.id,operation:r?"update":"create",duration:performance.now()-i,metadata:{localVersion:s.syncVersion,cloudVersion:e.sync_version,dataSize:JSON.stringify(e).length}}}catch(s){return{id:e.id,success:!1,entity:"card",entityId:e.id,operation:"sync",duration:performance.now()-i,error:s instanceof Error?s.message:"Unknown error"}}}async syncFolderToCloud(e,t){const i=performance.now();try{const s=m.toCloudFolder(e);let r;if(e.syncVersion===1?r=await h.from("folders").insert(s).select().single():r=await h.from("folders").update(s).eq("id",e.id).select().single(),r.error)throw r.error;return{id:e.id,success:!0,entity:"folder",entityId:e.id,operation:e.syncVersion===1?"create":"update",duration:performance.now()-i,metadata:{localVersion:e.syncVersion,cloudVersion:r.data.sync_version,dataSize:JSON.stringify(s).length}}}catch(s){return{id:e.id,success:!1,entity:"folder",entityId:e.id,operation:e.syncVersion===1?"create":"update",duration:performance.now()-i,error:s instanceof Error?s.message:"Unknown error"}}}async syncFolderToLocal(e,t){const i=performance.now();try{const s=m.fromCloudFolder(e),r=await u.folders.get(e.id);return r?await u.folders.update(e.id,s):await u.folders.add(s),{id:e.id,success:!0,entity:"folder",entityId:e.id,operation:r?"update":"create",duration:performance.now()-i,metadata:{localVersion:s.syncVersion,cloudVersion:e.sync_version,dataSize:JSON.stringify(e).length}}}catch(s){return{id:e.id,success:!1,entity:"folder",entityId:e.id,operation:"sync",duration:performance.now()-i,error:s instanceof Error?s.message:"Unknown error"}}}async syncTagToCloud(e,t){const i=performance.now();try{const s=m.toCloudTag(e);let r;if(e.syncVersion===1?r=await h.from("tags").insert(s).select().single():r=await h.from("tags").update(s).eq("id",e.id).select().single(),r.error)throw r.error;return{id:e.id,success:!0,entity:"tag",entityId:e.id,operation:e.syncVersion===1?"create":"update",duration:performance.now()-i,metadata:{localVersion:e.syncVersion,cloudVersion:r.data.sync_version,dataSize:JSON.stringify(s).length}}}catch(s){return{id:e.id,success:!1,entity:"tag",entityId:e.id,operation:e.syncVersion===1?"create":"update",duration:performance.now()-i,error:s instanceof Error?s.message:"Unknown error"}}}async syncTagToLocal(e,t){const i=performance.now();try{const s=m.fromCloudTag(e),r=await u.tags.get(e.id);return r?await u.tags.update(e.id,s):await u.tags.add(s),{id:e.id,success:!0,entity:"tag",entityId:e.id,operation:r?"update":"create",duration:performance.now()-i,metadata:{localVersion:s.syncVersion,cloudVersion:e.sync_version,dataSize:JSON.stringify(e).length}}}catch(s){return{id:e.id,success:!1,entity:"tag",entityId:e.id,operation:"sync",duration:performance.now()-i,error:s instanceof Error?s.message:"Unknown error"}}}async syncImageToCloud(e,t){const i=performance.now();try{return{id:e.id,success:!0,entity:"image",entityId:e.id,operation:"sync",duration:performance.now()-i,metadata:{localVersion:e.syncVersion,dataSize:e.metadata.size}}}catch(s){return{id:e.id,success:!1,entity:"image",entityId:e.id,operation:"sync",duration:performance.now()-i,error:s instanceof Error?s.message:"Unknown error"}}}async syncImageToLocal(e,t){const i=performance.now();try{return{id:e.id,success:!0,entity:"image",entityId:e.id,operation:"sync",duration:performance.now()-i,metadata:{cloudVersion:e.sync_version,dataSize:e.size||0}}}catch(s){return{id:e.id,success:!1,entity:"image",entityId:e.id,operation:"sync",duration:performance.now()-i,error:s instanceof Error?s.message:"Unknown error"}}}async checkDataConsistency(){const e=`consistency_${Date.now()}`;if(this.consistencyCache.has(e))return this.consistencyCache.get(e);const t={timestamp:new Date,localCount:{cards:0,folders:0,tags:0,images:0},cloudCount:{cards:0,folders:0,tags:0,images:0},inconsistencies:{missingLocal:[],missingCloud:[],versionMismatches:[],dataCorruption:[]},isConsistent:!0,confidence:0};try{const i=await u.getStats();t.localCount={cards:i.cards,folders:i.folders,tags:i.tags,images:i.images};const s=await this.getCloudStats();t.cloudCount=s;const r=await this.analyzeInconsistencies(t.localCount,t.cloudCount);if(t.inconsistencies=r,t.isConsistent=this.calculateConsistency(r),t.confidence=this.calculateConfidence(t),this.consistencyCache.set(e,t),this.consistencyCache.size>10){const n=this.consistencyCache.keys().next().value;this.consistencyCache.delete(n)}}catch(i){console.error("Data consistency check failed:",i),t.isConsistent=!1}return t}async quickConsistencyCheck(e){try{const[t,i]=await Promise.all([u.cards.count(),this.getCloudEntityCount("cards")]);Math.abs(t-i)>5&&(console.warn("Card count inconsistency detected:",t,"vs",i),e.conflicts+=Math.abs(t-i))}catch(t){console.error("Quick consistency check failed:",t)}}async getCloudStats(){try{const e=h.auth.user();if(!e)throw new Error("User not authenticated");const[t,i,s,r]=await Promise.all([h.from("cards").select("id",{count:"exact",head:!0}).eq("user_id",e.id),h.from("folders").select("id",{count:"exact",head:!0}).eq("user_id",e.id),h.from("tags").select("id",{count:"exact",head:!0}).eq("user_id",e.id),h.from("images").select("id",{count:"exact",head:!0}).eq("user_id",e.id)]);return{cards:t.count||0,folders:i.count||0,tags:s.count||0,images:r.count||0}}catch(e){return console.error("Failed to get cloud stats:",e),{cards:0,folders:0,tags:0,images:0}}}async analyzeInconsistencies(e,t){const i={missingLocal:[],missingCloud:[],versionMismatches:[],dataCorruption:[]},s=["cards","folders","tags","images"];for(const r of s){const n=Math.abs(e[r]-t[r]);n>10&&(e[r]<t[r]?i.missingLocal.push(`${r}: missing ${n} items`):i.missingCloud.push(`${r}: missing ${n} items`))}return i}calculateConsistency(e){return e.missingLocal.length+e.missingCloud.length+e.versionMismatches.length+e.dataCorruption.length===0}calculateConfidence(e){let t=1;return e.inconsistencies.dataCorruption.length>0&&(t-=.5),e.inconsistencies.versionMismatches.length>0&&(t-=.3),(e.inconsistencies.missingLocal.length>0||e.inconsistencies.missingCloud.length>0)&&(t-=.2),Math.max(0,t)}createSyncSession(e,t="full"){return{id:crypto.randomUUID(),startTime:new Date,state:"syncing",direction:e,processed:0,successful:0,failed:0,conflicts:0,dataTransferred:0,networkLatency:0,operations:[]}}async handleSyncError(e,t){console.error("Sync error:",t),e.state="error",e.endTime=new Date,this.metrics.failedSessions++,this.metrics.reliability=this.metrics.successfulSessions/Math.max(1,this.metrics.totalSessions),this.retryCount<this.maxRetries?(this.retryCount++,console.log(`Retrying sync (attempt ${this.retryCount}/${this.maxRetries})`),setTimeout(()=>{this.performFullSync(e.direction).catch(console.error)},this.getRetryDelay())):(this.retryCount=0,console.error("Max retries reached, sync failed"))}updateMetrics(e){this.metrics.totalSessions++,e.state==="completed"?this.metrics.successfulSessions++:this.metrics.failedSessions++;const t=e.endTime?e.endTime.getTime()-e.startTime.getTime():0;if(this.metrics.averageSessionTime=(this.metrics.averageSessionTime*(this.metrics.totalSessions-1)+t)/this.metrics.totalSessions,e.duration>0){const i=e.dataTransferred/(e.duration/1e3);this.metrics.dataThroughput=(this.metrics.dataThroughput*(this.metrics.totalSessions-1)+i)/this.metrics.totalSessions}this.metrics.conflictRate=(this.metrics.conflictRate*(this.metrics.totalSessions-1)+e.conflicts/Math.max(1,e.processed))/this.metrics.totalSessions,this.metrics.reliability=this.metrics.successfulSessions/this.metrics.totalSessions,this.metrics.lastSyncTime=e.endTime||e.startTime}async getLocalChanges(){return await u.cards.filter(t=>t.pendingSync).toArray()}async getCloudChanges(){try{const e=h.auth.user();if(!e)return[];const t=this.metrics.lastSyncTime||new Date(0),[i,s,r]=await Promise.all([h.from("cards").select("*").eq("user_id",e.id).gte("updated_at",t.toISOString()),h.from("folders").select("*").eq("user_id",e.id).gte("updated_at",t.toISOString()),h.from("tags").select("*").eq("user_id",e.id).gte("updated_at",t.toISOString())]);return[...(i.data||[]).map(n=>({...n,entity:"card"})),...(s.data||[]).map(n=>({...n,entity:"folder"})),...(r.data||[]).map(n=>({...n,entity:"tag"}))]}catch(e){return console.error("Failed to get cloud changes:",e),[]}}async processPriorityOperations(e){const t=await w.getOperations({priority:"high",limit:20});t.length>0&&(console.log(`Processing ${t.length} high priority operations`),await w.processNextBatch())}groupOperationsByEntity(e){const t={};for(const i of e){const s=i.entity||this.inferEntityType(i);t[s]||(t[s]=[]),t[s].push(i)}return t}inferEntityType(e){return e.frontContent?"card":e.name&&e.parentId!==void 0?"folder":e.name&&e.color?"tag":e.fileName?"image":"unknown"}async updateLocalSyncStatus(e,t){try{let i;switch(e){case"card":i=u.cards;break;case"folder":i=u.folders;break;case"tag":i=u.tags;break;default:return}await i.where("id").equals(t).modify({pendingSync:!1,lastSyncAt:new Date})}catch(i){console.error("Failed to update local sync status:",i)}}async getCloudEntityCount(e){try{const t=h.auth.user();return t&&(await h.from(e).select("id",{count:"exact",head:!0}).eq("user_id",t.id)).count||0}catch(t){return console.error(`Failed to get cloud ${e} count:`,t),0}}getAdaptiveSyncInterval(){const e=this.metrics.reliability;return e<.8?10*60*1e3:e<.95?5*60*1e3:2*60*1e3}getRetryDelay(){return Math.min(1e3*Math.pow(2,this.retryCount),3e4)}shouldPerformBackgroundSync(){return this.currentState==="idle"&&navigator.onLine&&h.auth.user()!==null}cleanupExpiredSessions(){const e=new Date(Date.now()-6048e5);this.syncHistory=this.syncHistory.filter(t=>t.startTime>e),this.syncHistory.length>100&&(this.syncHistory=this.syncHistory.slice(-100))}async performHealthCheck(){try{await u.healthCheck();const{error:e}=await h.from("cards").select("id",{count:"exact",head:!0}).limit(1);if(e)throw e;console.log("DataSyncService health check passed")}catch(e){console.error("DataSyncService health check failed:",e)}}handleQueueOperationComplete(e,t){console.log(`Queue operation ${e.id} completed: ${t}`)}handleQueueBatchComplete(e){console.log("Queue batch completed:",e)}handleQueueError(e){console.error("Queue error:",e)}handleQueueStatusChange(e){console.log("Queue status changed:",e)}notifyListeners(e){this.listeners.forEach(t=>t(e))}onSyncStatusChange(e){return this.listeners.add(e),e(this.currentSession||this.createSyncSession("bidirectional")),()=>{this.listeners.delete(e)}}async getMetrics(){return{...this.metrics}}async getSyncHistory(e){const t=[...this.syncHistory];return this.currentSession&&t.unshift(this.currentSession),e?t.slice(0,e):t}async getConsistencyReport(){return await this.checkDataConsistency()}async forceSync(e="bidirectional"){return await this.performFullSync(e)}pauseSync(){this.currentState="paused",this.currentSession&&(this.currentSession.state="paused")}resumeSync(){this.currentState==="paused"&&(this.currentState="idle",this.currentSession&&(this.currentSession.state="syncing",this.performFullSync(this.currentSession.direction).catch(console.error)))}getCurrentState(){return this.currentState}getCurrentSession(){return this.currentSession}startDataValidation(){setInterval(async()=>{this.currentState!=="syncing"&&await this.performScheduledValidation()},30*60*1e3)}async performScheduledValidation(){try{console.log("Performing scheduled data validation...");const e=await b.validateConsistency(this.validationLevel);this.lastValidationTime=new Date,e.overallStatus==="critical"||e.overallStatus==="error"?(console.error("Data consistency validation failed:",e.summary),this.autoRepairEnabled&&e.issues.length>0&&await this.attemptAutoRepair(e.issues)):console.log("Data validation completed successfully:",e.summary)}catch(e){console.error("Scheduled data validation failed:",e)}}async validateBeforeSync(){try{const e=await b.validateConsistency(ConsistencyLevel.BASIC);return e.overallStatus==="critical"?(console.error("Data consistency check failed before sync:",e.summary),!1):!0}catch(e){return console.error("Pre-sync validation failed:",e),!1}}async validateAfterSync(e){try{const t=await b.validateConsistency(this.validationLevel);t.overallStatus==="critical"||t.overallStatus==="error"?(e.state="error",console.error("Post-sync validation failed:",t.summary),this.autoRepairEnabled&&await this.attemptAutoRepair(t.issues)):console.log("Post-sync validation passed:",t.summary)}catch(t){console.error("Post-sync validation failed:",t),e.state="error"}}async attemptAutoRepair(e){try{console.log("Attempting auto-repair for",e.length,"consistency issues");const t=await b.autoRepairIssues(e,{dryRun:!1,maxRetries:3,repairStrategy:"conservative"});t.success?console.log(`Auto-repair completed: ${t.repairedIssues} issues repaired`):console.error("Auto-repair failed:",t.errors)}catch(t){console.error("Auto-repair attempt failed:",t)}}async getDetailedConsistencyReport(e=ConsistencyLevel.RELAXED){return await b.validateConsistency(e)}async manualValidation(e=ConsistencyLevel.STRICT){return console.log("Manual validation triggered with level:",e),await b.validateConsistency(e)}configureValidation(e){e.level!==void 0&&(this.validationLevel=e.level),e.autoRepair!==void 0&&(this.autoRepairEnabled=e.autoRepair),console.log("Validation configuration updated:",{level:this.validationLevel,autoRepair:this.autoRepairEnabled})}getLastValidationTime(){return this.lastValidationTime}async getOptimalBatchStrategy(e,t){const i=this.getBaseBatchStrategy(t);if(!this.batchOptimization.dynamicBatchSize)return i;const s=this.calculateOptimalBatchSize(e,t),r=await this.calculateOptimalDelay(t),n=e>s*2&&t==="cloud";return{batchSize:s,delay:r,parallel:n,useTransaction:t==="local",priority:e>1e3?"high":"normal"}}getBaseBatchStrategy(e){return e==="cloud"?{batchSize:50,delay:100,parallel:!1,useTransaction:!1,priority:"normal"}:{batchSize:100,delay:10,parallel:!1,useTransaction:!0,priority:"normal"}}calculateOptimalBatchSize(e,t){const{minBatchSize:i,maxBatchSize:s}=this.batchOptimization,r=this.performanceMetrics.successRate>.95?1.2:this.performanceMetrics.successRate>.8?1:.8,n=this.performanceMetrics.avgBatchTime>1e3?.8:1,a=this.performanceMetrics.networkLatency>500?.7:1,c=Math.round((t==="cloud"?50:100)*r*n*a);return Math.max(i,Math.min(s,c))}async calculateOptimalDelay(e){if(!this.batchOptimization.adaptiveDelay)return e==="cloud"?100:10;if(this.batchOptimization.networkAware&&e==="cloud")try{const t=performance.now();await fetch("https://api.supabase.io/health",{method:"HEAD"});const i=performance.now()-t;return this.performanceMetrics.networkLatency=i,i<200?50:i<500?100:i<1e3?200:300}catch{return 500}return e==="cloud"?100:10}async adaptiveDelay(e){if(!this.batchOptimization.adaptiveDelay){await new Promise(s=>setTimeout(s,e));return}const t=navigator.hardwareConcurrency?Math.max(.5,1-(navigator.hardwareConcurrency-4)/8):1,i=Math.round(e*t);await new Promise(s=>setTimeout(s,i))}optimizeOperationGrouping(e){const t=this.groupOperationsByEntity(e),i=["tags","folders","cards","images"],s={};return i.forEach(r=>{t[r]&&(s[r]=t[r])}),Object.keys(t).forEach(r=>{i.includes(r)||(s[r]=t[r])}),s}chunkOperations(e,t){const i=[];for(let s=0;s<e.length;s+=t)i.push(e.slice(s,s+t));return i}updateBatchPerformanceMetrics(e,t,i){const s=i.filter(a=>a.success).length,r=e>0?s/e:1,n=.3;this.performanceMetrics.avgBatchTime=n*t+(1-n)*this.performanceMetrics.avgBatchTime,this.performanceMetrics.avgBatchSize=n*e+(1-n)*this.performanceMetrics.avgBatchSize,this.performanceMetrics.successRate=n*r+(1-n)*this.performanceMetrics.successRate,this.performanceMetrics.lastBatchTime=performance.now()}getBatchPerformanceMetrics(){return{...this.performanceMetrics}}configureBatchOptimization(e){this.batchOptimization={...this.batchOptimization,...e},console.log("Batch optimization configuration updated:",this.batchOptimization)}async syncBatchToCloudLegacy(e,t){const s=[],r=this.groupOperationsByEntity(e);for(const[n,a]of Object.entries(r))for(let o=0;o<a.length;o+=50){const c=a.slice(o,o+50),l=await this.processCloudBatch(n,c,t);s.push(...l),o+50<a.length&&await new Promise(y=>setTimeout(y,100))}return s}}const S=new ie;class F{isInitialized=!1;authService=null;isOnline=!1;syncInProgress=!1;conflicts=[];metrics=this.getDefaultMetrics();listeners=new Set;operationHistory=[];syncCache=new Map;lastFullSync=null;constructor(){this.initialize(),this.setupOfflineIntegration(),this.setupDataSyncIntegration()}getDefaultMetrics(){return{totalOperations:0,successfulOperations:0,failedOperations:0,averageSyncTime:0,lastSyncTime:null,conflictsCount:0,networkQuality:"good",cacheHitRate:0}}initialize(){this.isInitialized||(this.initializeNetworkIntegration(),this.initializeQueueIntegration(),this.initializeDataSyncIntegration(),this.startBackgroundSync(),this.isInitialized=!0,console.log("Unified sync service initialized"))}initializeNetworkIntegration(){C.startMonitoring(),C.addListener({onNetworkStateChanged:this.handleNetworkStateChange.bind(this),onNetworkEvent:this.handleNetworkEvent.bind(this),onNetworkError:this.handleNetworkError.bind(this),onSyncReady:this.handleSyncReady.bind(this),onNetworkPrediction:this.handleNetworkPrediction.bind(this)})}initializeQueueIntegration(){w.setEventListeners({onOperationComplete:this.handleOperationComplete.bind(this),onBatchComplete:this.handleBatchComplete.bind(this),onQueueError:this.handleQueueError.bind(this),onStatusChange:this.handleQueueStatusChange.bind(this)})}setupDataSyncIntegration(){S.onSyncStatusChange(e=>{this.handleDataSyncStatusChange(e)})}initializeDataSyncIntegration(){S.configureValidation({level:ConsistencyLevel.RELAXED,autoRepair:!0,scheduledValidation:!0}),S.configureBatchOptimization({enabled:!0,dynamicBatchSize:!0,adaptiveDelay:!0,networkAware:!0}),console.log("DataSyncService integration initialized")}startBackgroundSync(){setInterval(()=>{this.shouldPerformBackgroundSync()&&this.performIncrementalSync()},this.getAdaptiveSyncInterval()),setInterval(()=>{this.isOnline&&!this.syncInProgress&&this.processLocalSyncQueue().catch(console.error)},3e4)}setupOfflineIntegration(){B.setEventListeners({onNetworkChange:e=>this.handleOfflineNetworkChange(e),onOfflineOperation:e=>this.handleOfflineOperation(e),onSyncProgress:e=>this.handleOfflineSyncProgress(e),onConflict:e=>this.handleOfflineConflict(e),onSyncComplete:e=>this.handleOfflineSyncComplete(e),onError:e=>this.handleOfflineError(e)})}handleOfflineNetworkChange(e){this.isOnline=e.status==="online",this.notifyStatusChange(),this.isOnline&&this.performIncrementalSync().catch(console.error)}handleOfflineOperation(e){const t={id:e.id,type:e.type,entity:e.entity,entityId:e.entityId||"",data:e.data,priority:this.mapOfflinePriorityToSyncPriority(e.priority),timestamp:e.timestamp,userId:e.userId,metadata:{source:"user",conflictResolution:e.metadata?.conflictResolution,retryStrategy:"delayed"}};this.operationHistory.push(t)}handleOfflineSyncProgress(e){this.notifyListeners({status:"syncing",progress:e.completed/e.total*100,message:`离线同步进度: ${e.completed}/${e.total}`})}handleOfflineConflict(e){const t={id:e.id,entity:e.entityType,entityId:e.entityId,localData:e.localData,cloudData:e.remoteData,conflictType:this.mapOfflineConflictType(e.conflictType),resolution:e.resolution,timestamp:e.timestamp};this.conflicts.push(t),this.notifyStatusChange()}handleOfflineSyncComplete(e){this.metrics.totalOperations+=e.completedOfflineOperations,this.metrics.successfulOperations+=e.completedOfflineOperations,this.metrics.failedOperations+=e.failedOperations,this.metrics.lastSyncTime=e.lastSyncTime,this.notifyListeners({status:"completed",progress:100,message:"离线同步完成"})}handleOfflineError(e){console.error("离线管理器错误:",e),this.notifyListeners({status:"error",progress:0,message:`离线操作错误: ${e.message}`})}mapOfflinePriorityToSyncPriority(e){switch(e){case"critical":case"high":return"high";case"normal":return"normal";case"low":return"low";default:return"normal"}}mapOfflineConflictType(e){switch(e){case"simultaneous_edit":return"content";case"delete_conflict":return"version";case"structure_conflict":return"structure";default:return"content"}}async addOperation(e){const t={...e,id:crypto.randomUUID(),timestamp:new Date};try{const i={type:e.type,entity:e.entity,entityId:e.entityId,userId:e.userId,data:e.data,priority:e.priority,retryCount:0,maxRetries:this.getMaxRetries(e.priority),dependencies:this.getOperationDependencies(e)},s=await w.enqueueOperation(i);return this.operationHistory.push(t),this.updateMetrics({totalOperations:this.metrics.totalOperations+1}),this.shouldProcessImmediately()&&this.processNextOperations(),s}catch(i){throw console.error("Failed to add sync operation:",i),i}}async performFullSync(){if(!(this.syncInProgress||!this.canSync())){this.syncInProgress=!0,this.notifyStatusChange();try{const e=performance.now(),t=await S.performFullSync(SyncDirection.BIDIRECTIONAL);t.state==="error"?(console.warn("DataSyncService failed, falling back to legacy sync"),await this.performLegacyFullSync()):console.log(`DataSyncService completed: ${t.processed} operations`);const i=performance.now()-e;this.lastFullSync=new Date,this.updateMetrics({lastSyncTime:this.lastFullSync,averageSyncTime:(this.metrics.averageSyncTime+i)/2}),console.log(`Unified full sync completed in ${i}ms`)}catch(e){throw console.error("Full sync failed:",e),e}finally{this.syncInProgress=!1,this.notifyStatusChange()}}}async performLegacyFullSync(){await this.processLocalSyncQueue(),await this.syncFromCloud(),await this.processSyncQueue(),await this.detectAndResolveConflicts(),await this.verifyDataConsistency()}async performIncrementalSync(){if(!(this.syncInProgress||!this.canSync()))try{await S.performIncrementalSync(),await this.processLocalSyncQueue(),await this.processHighPriorityOperations(),await this.checkCloudUpdates(),this.cleanupCache()}catch(e){console.error("Incremental sync failed:",e)}}async processLocalSyncQueue(){if(this.isOnline)try{const e=await I.getPendingSyncOperations();if(e.length===0)return;console.log(`Processing ${e.length} local sync operations`);const t=await this.processBatchLocalOperations(e);await I.updateOperationStatuses(t),this.metrics.totalOperations+=t.length,this.metrics.successfulOperations+=t.filter(i=>i.success).length,this.metrics.failedOperations+=t.filter(i=>!i.success).length}catch(e){console.error("Failed to process local sync queue:",e)}}async processBatchLocalOperations(e){const t=[],i=this.groupLocalOperationsByType(e);for(const[s,r]of Object.entries(i)){const n=await this.processLocalOperationGroup(s,r);t.push(...n)}return t}groupLocalOperationsByType(e){const t={};for(const i of e){const s=`${i.entityType}_${i.operationType}`;t[s]||(t[s]=[]),t[s].push(i)}return t}async processLocalOperationGroup(e,t){const i=[];try{switch(e){case"card_create":case"card_update":case"card_delete":await this.processCardOperations(t,i);break;case"folder_create":case"folder_update":case"folder_delete":await this.processFolderOperations(t,i);break;case"tag_create":case"tag_update":case"tag_delete":await this.processTagOperations(t,i);break;default:console.warn(`Unknown operation type: ${e}`);for(const s of t)i.push({operationId:s.id,success:!1,error:`Unknown operation type: ${e}`})}}catch(s){console.error(`Failed to process operation group ${e}:`,s);for(const r of t)i.push({operationId:r.id,success:!1,error:s instanceof Error?s.message:"Unknown error"})}return i}async processCardOperations(e,t){for(const i of e)try{switch(i.operationType){case"create":await h.from("cards").insert(i.data).select().single();break;case"update":await h.from("cards").update(i.data).eq("id",i.entityId);break;case"delete":await h.from("cards").delete().eq("id",i.entityId);break}t.push({operationId:i.id,success:!0})}catch(s){t.push({operationId:i.id,success:!1,error:s instanceof Error?s.message:"Unknown error"})}}async processFolderOperations(e,t){for(const i of e)try{switch(i.operationType){case"create":await h.from("folders").insert(i.data).select().single();break;case"update":await h.from("folders").update(i.data).eq("id",i.entityId);break;case"delete":await h.from("folders").delete().eq("id",i.entityId);break}t.push({operationId:i.id,success:!0})}catch(s){t.push({operationId:i.id,success:!1,error:s instanceof Error?s.message:"Unknown error"})}}async processTagOperations(e,t){for(const i of e)try{switch(i.operationType){case"create":await h.from("tags").insert(i.data).select().single();break;case"update":await h.from("tags").update(i.data).eq("id",i.entityId);break;case"delete":await h.from("tags").delete().eq("id",i.entityId);break}t.push({operationId:i.id,success:!0})}catch(s){t.push({operationId:i.id,success:!1,error:s instanceof Error?s.message:"Unknown error"})}}async getLocalSyncOperations(){return await I.getPendingSyncOperations()}async triggerLocalSyncProcessing(){if(this.syncInProgress){console.log("Sync already in progress, skipping local sync processing");return}await this.processLocalSyncQueue()}async syncFromCloud(){if(!this.authService?.isAuthenticated())return;const e=this.authService.getCurrentUser();if(!e)return;const t=this.lastFullSync||new Date(0),[i,s,r]=await Promise.all([this.getCloudData("cards",e.id,t),this.getCloudData("folders",e.id,t),this.getCloudData("tags",e.id,t)]);await Promise.all([this.mergeCloudCards(i),this.mergeCloudFolders(s),this.mergeCloudTags(r)])}async getCloudData(e,t,i){const s=`${e}_${t}_${i.toISOString()}`;if(this.syncCache.has(s))return this.updateCacheHitRate(!0),this.syncCache.get(s);this.updateCacheHitRate(!1);const r=h.from(e).select("*").eq("user_id",t).gte("updated_at",i.toISOString()),{data:n,error:a}=await r;if(a)throw a;return this.syncCache.set(s,n||[]),n||[]}async mergeCloudCards(e){for(const t of e){const i=await u.cards?.get(t.id);i?await this.resolveCardConflict(i,t):await u.cards?.add(m.fromCloudCard(t))}}async mergeCloudFolders(e){for(const t of e){const i=await u.folders?.get(t.id);i?await this.resolveFolderConflict(i,t):await u.folders?.add(m.fromCloudFolder(t))}}async mergeCloudTags(e){for(const t of e){const i=await u.tags?.get(t.id);i?await this.resolveTagConflict(i,t):await u.tags?.add(m.fromCloudTag(t))}}async detectAndResolveConflicts(){const e=await this.detectConflicts();for(const t of e)await this.resolveConflict(t)}async detectConflicts(){const e=[],t=await this.detectCardConflicts();e.push(...t);const i=await this.detectFolderConflicts();e.push(...i);const s=await this.detectTagConflicts();return e.push(...s),e}async resolveCardConflict(e,t){const i=new Date(e.updatedAt).getTime(),s=new Date(t.updated_at).getTime();s>i?await u.cards?.update(t.id,m.fromCloudCard(t)):i>s&&e.pendingSync&&await this.addOperation({type:"update",entity:"card",entityId:e.id,data:e,priority:"normal",userId:e.userId})}async resolveFolderConflict(e,t){const i=new Date(e.updatedAt).getTime(),s=new Date(t.updated_at).getTime();s>i?await u.folders?.update(t.id,m.fromCloudFolder(t)):i>s&&e.pendingSync&&await this.addOperation({type:"update",entity:"folder",entityId:e.id,data:e,priority:"normal",userId:e.userId})}async resolveTagConflict(e,t){const i=new Date(e.updatedAt).getTime(),s=new Date(t.updated_at).getTime();s>i?await u.tags?.update(t.id,m.fromCloudTag(t)):i>s&&e.pendingSync&&await this.addOperation({type:"update",entity:"tag",entityId:e.id,data:e,priority:"normal",userId:e.userId})}async processSyncQueue(){}async processNextOperations(){if(!this.syncInProgress){this.syncInProgress=!0;try{await w.processNextBatch()}finally{this.syncInProgress=!1}}}async processHighPriorityOperations(){(await w.getOperations({priority:"high",limit:5})).length>0&&await this.processNextOperations()}handleNetworkStateChange(e){this.isOnline=e.isOnline,e.isOnline&&e.canSync&&this.performIncrementalSync().catch(console.error),this.metrics.networkQuality=e.quality,this.notifyStatusChange()}handleNetworkEvent(e){switch(console.log("Network event in sync service:",e.type),e.type){case"online":this.handleNetworkRestored();break;case"offline":this.handleNetworkLost();break;case"sync-ready":this.handleSyncReady(e.currentState.syncStrategy);break}}handleSyncReady(e){console.log("Sync ready with strategy:",e),!this.syncInProgress&&this.authService?.isAuthenticated()&&this.performIncrementalSync().catch(console.error)}handleNetworkPrediction(e){console.log("Network prediction:",e),e.isStable?w.setConservativeMode(!1):w.setConservativeMode(!0)}handleNetworkRestored(){console.log("Network restored, resuming sync operations"),w.resume(),this.performIncrementalSync().catch(console.error)}handleNetworkLost(){console.log("Network lost, pausing sync operations"),w.pause()}handleNetworkError(e,t){console.warn("Network error in sync service:",e.message,t),e.type==="connection_lost"&&w.pause()}handleSyncCompleted(e,t){t.success&&(this.metrics.lastSyncTime=new Date)}handleSyncStrategyChanged(e){console.log("Sync strategy changed:",e)}handleOperationComplete(e,t){t?this.updateMetrics({successfulOperations:this.metrics.successfulOperations+1}):this.updateMetrics({failedOperations:this.metrics.failedOperations+1})}handleBatchComplete(e){console.log("Batch sync completed:",e)}handleQueueError(e){console.error("Queue error:",e)}handleQueueStatusChange(e){this.notifyStatusChange()}handleDataSyncStatusChange(e){console.log("DataSyncService status change:",e.state,e.direction),this.syncInProgress=e.state==="syncing",e.state==="completed"&&(this.lastFullSync=e.endTime,this.updateMetricsFromDataSync(e)),e.state==="error"&&(console.error("DataSyncService error:",e),this.handleSyncError(e)),this.notifyStatusChange()}updateMetricsFromDataSync(e){if(this.metrics.totalOperations+=e.processed,this.metrics.successfulOperations+=e.successful,this.metrics.failedOperations+=e.failed,this.metrics.conflictsCount+=e.conflicts,this.metrics.lastSyncTime=e.endTime,e.duration){const t=this.metrics.averageSyncTime*(this.metrics.totalOperations-e.processed)+e.duration;this.metrics.averageSyncTime=t/this.metrics.totalOperations}}handleSyncError(e){this.notifyListeners({status:"error",error:"Data sync failed",details:{processed:e.processed,successful:e.successful,failed:e.failed,conflicts:e.conflicts}})}canSync(){const e=C.getCurrentStatus();return this.isOnline&&this.authService?.isAuthenticated()&&e.canSync}shouldProcessImmediately(){return this.canSync()&&!this.syncInProgress}shouldPerformBackgroundSync(){return C.getCurrentStatus().canSync&&!this.syncInProgress&&this.authService?.isAuthenticated()}getAdaptiveSyncInterval(){switch(C.getCurrentStatus().quality){case"excellent":return 60*1e3;case"good":return 2*60*1e3;case"fair":return 5*60*1e3;case"poor":return 10*60*1e3;default:return 5*60*1e3}}getMaxRetries(e){switch(e){case"high":return 5;case"normal":return 3;case"low":return 1}}getOperationDependencies(e){const t=[];return e.entity==="card"&&e.data.folderId&&t.push(`folder_${e.data.folderId}`),t}updateCacheHitRate(e){const t=this.metrics.totalOperations||1,i=e?this.metrics.cacheHitRate*t+1:this.metrics.cacheHitRate*t;this.updateMetrics({cacheHitRate:i/(t+1)})}updateMetrics(e){this.metrics={...this.metrics,...e}}cleanupCache(){const e=Date.now(),t=5*60*1e3;for(const[i,s]of this.syncCache.entries())e-s.timestamp>t&&this.syncCache.delete(i)}async checkCloudUpdates(){this.lastFullSync&&Date.now()-this.lastFullSync.getTime()>30*60*1e3&&await this.performFullSync()}async verifyDataConsistency(){}setAuthService(e){this.authService=e,e.onAuthStateChange(t=>{t.user&&this.canSync()&&this.performFullSync()})}onStatusChange(e){return this.listeners.add(e),e(this.getCurrentStatus()),()=>{this.listeners.delete(e)}}async notifyStatusChange(){const e=await this.getCurrentStatus();this.listeners.forEach(t=>t(e))}async getCurrentStatus(){const e=C.getCurrentStatus(),t=await w.getQueueStats();return{isOnline:e.isOnline,lastSyncTime:this.metrics.lastSyncTime,pendingOperations:t.totalOperations,syncInProgress:this.syncInProgress,hasConflicts:this.conflicts.length>0}}async getMetrics(){return{...this.metrics}}async getConflicts(){return[...this.conflicts]}async getOperationHistory(e){let t=[...this.operationHistory];return e?.entity&&(t=t.filter(i=>i.entity===e.entity)),e?.type&&(t=t.filter(i=>i.type===e.type)),e?.limit&&(t=t.slice(0,e.limit)),t}async clearHistory(e){e?this.operationHistory=this.operationHistory.filter(t=>t.timestamp>e):this.operationHistory=[]}async forceSync(){await this.performFullSync()}async pauseSync(){w.pause(),this.syncInProgress=!0}async resumeSync(){w.resume(),this.syncInProgress=!1,this.processNextOperations()}async getDataSyncStatus(){return{currentState:S.getCurrentState(),currentSession:S.getCurrentSession(),metrics:S.getMetrics()}}async getDataConsistencyReport(e){return await S.getDetailedConsistencyReport(e)}async performDataValidation(e){return await S.manualValidation(e)}async getBatchPerformanceMetrics(){return S.getBatchPerformanceMetrics()}configureDataValidation(e){S.configureValidation(e)}configureBatchOptimization(e){S.configureBatchOptimization(e)}async forceDataSync(e){return await S.forceSync(e)}}const se=new F,T=Object.freeze(Object.defineProperty({__proto__:null,UnifiedSyncService:F,unifiedSyncService:se},Symbol.toStringTag,{value:"Module"}));export{U as a,ce as c};
