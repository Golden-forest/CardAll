import{c as W,_ as F}from"./supabase-BJjf9Ixn.js";import{D as q}from"./database-Ddn5sgg-.js";let _=class extends q{cards;folders;tags;images;syncQueue;settings;sessions;constructor(){console.log("创建CardAllUnifiedDatabase实例...");try{super("CardAllUnifiedDB_v3"),console.log("设置数据库版本3..."),this.version(3).stores({cards:"++id, userId, folderId, createdAt, updatedAt, syncVersion, pendingSync, [userId+folderId], searchVector",folders:"++id, userId, parentId, createdAt, updatedAt, syncVersion, pendingSync, [userId+parentId], fullPath, depth, cardIds",tags:"++id, userId, name, createdAt, syncVersion, pendingSync, [userId+name]",images:"++id, cardId, userId, createdAt, updatedAt, syncVersion, pendingSync, storageMode, [cardId+userId]",syncQueue:"++id, type, entity, entityId, userId, timestamp, retryCount, priority, status, [userId+priority]",settings:"++id, key, updatedAt, scope, [key+scope]",sessions:"++id, userId, deviceId, lastActivity, isActive, [userId+deviceId]"}),console.log("数据库版本设置完成"),this.upgradeDatabase(),console.log("CardAllUnifiedDatabase实例创建完成")}catch(e){throw console.error("数据库构造函数出错:",e),e}}async upgradeDatabase(){console.log("开始数据库升级逻辑..."),this.version(2).upgrade(async e=>{console.log("Upgrading to version 2: Adding user support..."),console.log("检查旧数据库...");const t=new K;try{console.log("尝试打开旧数据库..."),await t.open(),console.log("Found old database, migrating data..."),console.log("迁移卡片数据...");const s=(await t.cards.toArray()).map(c=>({...c,userId:"default",updatedAt:new Date}));await this.cards.bulkAdd(s),console.log("迁移文件夹数据...");const n=(await t.folders.toArray()).map(c=>({...c,userId:"default",updatedAt:new Date}));await this.folders.bulkAdd(n),console.log("迁移标签数据...");const o=(await t.tags.toArray()).map(c=>({...c,userId:"default",updatedAt:new Date}));await this.tags.bulkAdd(o),console.log("Migration completed successfully")}catch(i){console.log("No old database found or migration failed:",i)}}),this.version(3).upgrade(async e=>{console.log("Upgrading to version 3: Optimizing indexes and adding new features..."),console.log("初始化默认设置..."),await this.initializeDefaultSettings(),console.log("重建搜索索引..."),await this.rebuildSearchIndexes(),console.log("版本3升级完成")}),console.log("数据库升级逻辑设置完成")}async initializeDefaultSettings(){console.log("初始化默认设置...");const e=[{key:"storageMode",value:"hybrid",scope:"global",updatedAt:new Date},{key:"syncEnabled",value:!0,scope:"global",updatedAt:new Date},{key:"imageCompression",value:{enabled:!0,quality:.8,maxWidth:1920,maxHeight:1080,format:"webp"},scope:"global",updatedAt:new Date},{key:"databaseVersion",value:"3.0.0",scope:"global",updatedAt:new Date}];console.log("添加",e.length,"个默认设置...");for(const t of e)console.log("检查设置:",t.key),await this.settings.where("key").equals(t.key).first()?console.log("设置已存在:",t.key):(console.log("添加新设置:",t.key),await this.settings.add(t));console.log("默认设置初始化完成")}async rebuildSearchIndexes(){console.log("Rebuilding search indexes...")}async getSetting(e,t){if(t){const s=await this.settings.where("[key+scope]").equals([e,"user"]).and(r=>!r.userId||r.userId===t).first();if(s)return s.value}return(await this.settings.where("[key+scope]").equals([e,"global"]).first())?.value}async updateSetting(e,t,i="global",s){await this.settings.where("[key+scope]").equals([e,i]).modify({value:t,userId:s,updatedAt:new Date})}async getStats(){console.log("开始获取数据库统计信息...");try{const[e,t,i,s,r]=await Promise.all([this.cards.count(),this.folders.count(),this.tags.count(),this.images.count(),this.syncQueue.count()]);console.log("基本统计:",{cards:e,folders:t,tags:i,images:s,pendingSync:r});const n=await this.calculateTotalSize();console.log("总大小:",n);const a={cards:e,folders:t,tags:i,images:s,pendingSync:r,totalSize:n,version:"3.0.0"};return console.log("数据库统计信息:",a),a}catch(e){throw console.error("获取数据库统计信息失败:",e),e}}async calculateTotalSize(){console.log("开始计算总大小...");try{const e=await this.images.toArray();console.log("找到",e.length,"张图片");const t=e.reduce((i,s)=>i+s.metadata.size,0);return console.log("计算的总大小:",t),t}catch(e){return console.error("计算总大小失败:",e),0}}async createCard(e,t){const i=crypto.randomUUID(),s=new Date;return await this.cards.add({...e,id:i,userId:t,syncVersion:1,pendingSync:!0,updatedAt:s}),i}async updateCard(e,t){return await this.cards.update(e,{...t,syncVersion:t.syncVersion?t.syncVersion+1:void 0,pendingSync:!0,updatedAt:new Date})}async deleteCard(e){await this.transaction("rw",[this.cards,this.images],async()=>{await this.images.where("cardId").equals(e).delete(),await this.cards.delete(e)})}async bulkCreateCards(e,t){const i=new Date,s=e.map(r=>({...r,id:crypto.randomUUID(),userId:t,syncVersion:1,pendingSync:!0,updatedAt:i}));return await this.cards.bulkAdd(s),s.map(r=>r.id)}async getCardsByFolder(e,t){return await this.cards.where("[userId+folderId]").equals([t||"default",e]).toArray()}async searchCards(e,t){const i=e.toLowerCase();return await this.cards.filter(s=>s.searchVector?.includes(i)||s.frontContent.title.toLowerCase().includes(i)||s.frontContent.text.toLowerCase().includes(i)||s.backContent.title.toLowerCase().includes(i)||s.backContent.text.toLowerCase().includes(i)).toArray()}async cleanup(){await this.transaction("rw",[this.cards,this.folders,this.tags,this.images,this.syncQueue],async()=>{const e=new Date(Date.now()-6048e5);await this.syncQueue.where("timestamp").below(e).delete();const t=await this.cards.toCollection().primaryKeys();await this.images.where("cardId").noneOf(t).delete(),console.log("Database cleanup completed")})}async healthCheck(){console.log("开始数据库健康检查...");const e=[];try{console.log("检查数据库连接..."),await this.cards.toArray(),console.log("数据库连接正常"),console.log("检查数据一致性...");const t=await this.getStats();return console.log("数据统计:",t),t.pendingSync>1e3&&e.push(`High number of pending sync operations: ${t.pendingSync}`),t.totalSize>500*1024*1024&&e.push(`Database size is large: ${(t.totalSize/1024/1024).toFixed(2)} MB`),console.log("数据库健康检查完成"),{isHealthy:e.length===0,issues:e,stats:t}}catch(t){return console.error("数据库健康检查失败:",t),{isHealthy:!1,issues:[`Database connection failed: ${t}`],stats:{cards:0,folders:0,tags:0,images:0,pendingSync:0,totalSize:0,version:"3.0.0"}}}}async clearAll(){await this.transaction("rw",[this.cards,this.folders,this.tags,this.images,this.syncQueue,this.settings,this.sessions],async()=>{await this.cards.clear(),await this.folders.clear(),await this.tags.clear(),await this.images.clear(),await this.syncQueue.clear(),await this.sessions.clear()})}async getSettingLegacy(e){return await this.getSetting(e)}async updateSettingLegacy(e,t){await this.updateSetting(e,t)}async clearAllLegacy(){await this.transaction("rw",this.cards,this.folders,this.tags,this.images,this.syncQueue,async()=>{await this.cards.clear(),await this.folders.clear(),await this.tags.clear(),await this.images.clear(),await this.syncQueue.clear()})}async getStatsLegacy(){const e=await this.getStats();return{cards:e.cards,folders:e.folders,tags:e.tags,images:e.images,pendingSync:e.pendingSync}}},K=class extends q{cards;folders;tags;images;syncQueue;settings;constructor(){super("CardAllDatabase"),this.version(1).stores({cards:"++id, folderId, createdAt, updatedAt, syncVersion, pendingSync",folders:"++id, parentId, createdAt, updatedAt, syncVersion, pendingSync",tags:"++id, name, createdAt, syncVersion, pendingSync",images:"++id, cardId, filePath, createdAt, syncVersion, pendingSync",syncQueue:"++id, type, entity, entityId, timestamp, retryCount",settings:"++id, key, updatedAt"})}},P=null;const H=()=>(P||(console.log("创建数据库实例..."),P=new _,console.log("数据库实例创建完成")),P),u=H(),G=async()=>{console.log("开始数据库初始化..."),console.log("时间戳:",new Date().toISOString());try{console.log("创建新的数据库实例...");const d=new _;console.log("数据库实例创建完成"),console.log("开始打开数据库连接..."),console.log("数据库名称:","CardAllUnifiedDB_v3"),await d.open(),console.log("数据库连接打开成功"),console.log("数据库版本:",d.verno),console.log("CardAll unified database initialized successfully"),console.log("设置数据库事件监听器...");try{d.on("error",e=>{console.error("Database error:",e)}),d.on("blocked",()=>{console.warn("Database operation blocked")}),d.on("versionchange",()=>{console.warn("Database version changed, reloading page..."),window.location.reload()}),d.on("ready",()=>{console.log("Database is ready")}),console.log("数据库事件监听器设置完成")}catch(e){console.warn("设置事件监听器失败，但不影响初始化:",e)}console.log("执行简化的数据库健康检查...");try{console.log("调用 dbInstance.healthCheck()...");const e=await d.healthCheck();console.log("健康检查结果:",e),e.isHealthy?console.log("数据库健康检查通过"):console.warn("数据库健康检查发现问题:",e.issues)}catch(e){console.warn("数据库健康检查失败，但不影响初始化:",e)}console.log("数据库初始化完成"),console.log("结束时间戳:",new Date().toISOString())}catch(d){throw console.error("Failed to initialize database:",d),d}},Z=(d,e)=>({...d,userId:e,syncVersion:1,pendingSync:!0,updatedAt:new Date}),X=d=>{const{userId:e,syncVersion:t,lastSyncAt:i,pendingSync:s,...r}=d;return{...r,id:r.id||"",createdAt:new Date(r.createdAt),updatedAt:new Date(r.updatedAt)}},Y=d=>[d.frontContent.title,d.frontContent.text,d.backContent.title,d.backContent.text,...d.frontContent.tags,...d.backContent.tags].join(" ").toLowerCase(),ee=async(d,e=100,t)=>{for(let i=0;i<d.length;i+=e){const s=d.slice(i,i+e);await t(s)}},te=d=>{const e=[];return d.frontContent?.title||e.push("Front content title is required"),d.backContent?.title||e.push("Back content title is required"),d.style&&!["solid","gradient","glass"].includes(d.style.type)&&e.push("Invalid card style type"),e},x=new Map,N=5*60*1e3,ie=async(d,e)=>{const t=x.get(d);if(t&&Date.now()-t.timestamp<N)return t.data;const i=await e();return x.set(d,{data:i,timestamp:Date.now()}),i},se=()=>{x.clear()};setInterval(()=>{const d=Date.now();for(const[e,t]of x.entries())d-t.timestamp>N&&x.delete(e)},N);const Ee=Object.freeze(Object.defineProperty({__proto__:null,batchOperation:ee,cachedQuery:ie,clearQueryCache:se,convertFromDbCard:X,convertToDbCard:Z,db:u,generateSearchVector:Y,getDatabase:H,initializeDatabase:G,validateCardData:te},Symbol.toStringTag,{value:"Module"}));class re{client;config;connectionStatus;reconnectTimer=null;listeners=[];constructor(e){this.config=e,this.connectionStatus={isConnected:!1,lastChecked:new Date,error:null,retryCount:0,maxRetries:3},this.validateConfig(e);const t={auth:{autoRefreshToken:!0,persistSession:!0,detectSessionInUrl:!0,storage:this.getSecureStorage(),storageKey:"supabase.auth.token"},realtime:{params:{eventsPerSecond:10},logger:(i,s,r)=>{this.logRealtimeEvent(i,s,r)}},global:{headers:{"x-application-name":"CardAll","x-application-version":this.getAppVersion(),"x-environment":e.environment}},db:{schema:"public"}};this.client=W(e.url,e.anonKey,t),this.initializeConnectionCheck()}validateConfig(e){if(!e.url||!e.url.startsWith("https://"))throw new Error("Invalid Supabase URL. Must start with https://");if(!e.anonKey||e.anonKey.length<100)throw new Error("Invalid Supabase anonymous key");if(!["development","staging","production"].includes(e.environment))throw new Error("Invalid environment. Must be development, staging, or production")}getSecureStorage(){try{if("localStorage"in window&&window.localStorage!==null)return window.localStorage}catch{console.warn("Secure storage not available, falling back to memory storage")}return{length:0,clear:()=>{},getItem:()=>null,key:()=>null,removeItem:()=>{},setItem:()=>{}}}getAppVersion(){return"1.0.0"}async initializeConnectionCheck(){await this.checkConnection(),setInterval(()=>this.checkConnection(),3e4)}async checkConnection(){try{const{data:e,error:t}=await this.client.from("users").select("count",{count:"exact",head:!0}).limit(1);if(t)throw new Error(`Connection check failed: ${t.message}`);this.updateConnectionStatus({isConnected:!0,lastChecked:new Date,error:null,retryCount:0,maxRetries:this.connectionStatus.maxRetries}),this.reconnectTimer&&(clearTimeout(this.reconnectTimer),this.reconnectTimer=null)}catch(e){this.handleConnectionError(e)}}handleConnectionError(e){const t=this.connectionStatus.retryCount+1;if(this.updateConnectionStatus({isConnected:!1,lastChecked:new Date,error:e.message,retryCount:t,maxRetries:this.connectionStatus.maxRetries}),t<=this.connectionStatus.maxRetries){const i=Math.min(1e3*Math.pow(2,t),3e4);this.reconnectTimer=setTimeout(()=>{this.checkConnection()},i),console.log(`Connection failed. Retrying in ${i}ms (attempt ${t})`)}else console.error("Max retries reached. Manual reconnection required.")}updateConnectionStatus(e){this.connectionStatus={...this.connectionStatus,...e},this.notifyListeners()}notifyListeners(){this.listeners.forEach(e=>{try{e(this.connectionStatus)}catch(t){console.error("Error in connection status listener:",t)}})}logRealtimeEvent(e,t,i){this.config.environment==="development"&&console.log(`[Realtime ${e.toUpperCase()}] ${t}`,i)}getClient(){return this.client}getConnectionStatus(){return{...this.connectionStatus}}addConnectionListener(e){this.listeners.push(e)}removeConnectionListener(e){const t=this.listeners.indexOf(e);t>-1&&this.listeners.splice(t,1)}async reconnect(){this.connectionStatus.retryCount=0,await this.checkConnection()}async queryWithRetry(e,t=3){let i=null;for(let s=1;s<=t;s++)try{const r=await e();if(r.error)throw new Error(r.error.message);return r}catch(r){if(i=r,s===t)break;const n=Math.min(1e3*Math.pow(2,s),1e4);await new Promise(a=>setTimeout(a,n)),console.warn(`Query failed (attempt ${s}/${t}). Retrying in ${n}ms...`)}return{data:null,error:i}}cleanup(){this.reconnectTimer&&(clearTimeout(this.reconnectTimer),this.reconnectTimer=null),this.listeners.length=0,this.client&&typeof this.client.realtime?.disconnect=="function"&&this.client.realtime.disconnect()}}function ne(){return{url:"https://elwnpejlwkgdacaugvvd.supabase.co",anonKey:"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImVsd25wZWpsd2tnZGFjYXVndnZkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTMzMzkxNTAsImV4cCI6MjA2ODkxNTE1MH0.XhVGgO2nf8uS1gC0V6jTMP0p0xN5KKV47t2rK2ncK90",accessToken:"sbp_e95c8cedf56ad231cb00db4c2696b029c20cefda",environment:"development"}}let z=null;function V(){if(!z)try{const d=ne();z=new re(d)}catch(d){throw console.error("Failed to initialize Supabase client:",d),d}return z}V().getClient();const y=V().getClient();class ae extends q{cards;folders;tags;images;syncQueue;settings;sessions;offlineSnapshots;offlineBackups;syncMetadata;conflictRecords;syncErrors;isolatedErrors;backups;hiddenTags;constructor(){super("CardAllUnifiedDatabase"),this.version(5).stores({cards:"++id, userId, folderId, createdAt, updatedAt, syncVersion, pendingSync, [userId+folderId], searchVector",folders:"++id, userId, parentId, createdAt, updatedAt, syncVersion, pendingSync, [userId+parentId], fullPath, depth",tags:"++id, userId, name, createdAt, syncVersion, pendingSync, [userId+name]",images:"++id, cardId, userId, createdAt, updatedAt, syncVersion, pendingSync, storageMode, [cardId+userId]",syncQueue:"++id, type, entity, entityId, userId, timestamp, retryCount, priority, [userId+priority]",settings:"++id, key, updatedAt, scope, [key+scope]",sessions:"++id, userId, deviceId, lastActivity, isActive, [userId+deviceId]",offlineSnapshots:"++id, timestamp, userId, version, dataHash, dataSize, [userId+timestamp]",offlineBackups:"++id, snapshotId, createdAt, compression, encrypted, size, [snapshotId+createdAt]",syncMetadata:"++id, entityType, entityId, userId, syncVersion, cloudVersion, lastSyncAt, conflictStatus, [entityType+entityId], [userId+syncVersion]",conflictRecords:"++id, entityType, entityId, userId, conflictType, localData, cloudData, timestamp, resolution, [entityType+entityId], [userId+conflictType]",syncErrors:"++id, type, severity, status, timestamp, [type+severity], [timestamp+status]",isolatedErrors:"++id, operationId, operationType, entityType, timestamp, [operationType+entityType]",backups:"++id, timestamp, version, compression, encrypted, size, [timestamp+version]",hiddenTags:"++id, userId, tagId, hiddenAt, [userId+tagId], [userId+hiddenAt]"}),this.upgradeDatabase()}async upgradeDatabase(){this.version(2).upgrade(async e=>{console.log("Upgrading to version 2: Adding user support...");const t=new oe;try{await t.open(),console.log("Found old database, migrating data...");const s=(await t.cards.toArray()).map(c=>({...c,userId:"default",updatedAt:new Date}));await this.cards.bulkAdd(s);const n=(await t.folders.toArray()).map(c=>({...c,userId:"default",updatedAt:new Date}));await this.folders.bulkAdd(n);const o=(await t.tags.toArray()).map(c=>({...c,userId:"default",updatedAt:new Date}));await this.tags.bulkAdd(o),console.log("Migration completed successfully")}catch(i){console.log("No old database found or migration failed:",i)}}),this.version(3).upgrade(async e=>{console.log("Upgrading to version 3: Optimizing indexes and adding new features..."),await this.initializeDefaultSettings(),await this.rebuildSearchIndexes()}),this.version(4).upgrade(async e=>{console.log("Upgrading to version 4: Adding offline data persistence features..."),await this.initializeOfflinePersistence(),await this.createInitialOfflineSnapshot()})}async initializeDefaultSettings(){const e=[{key:"storageMode",value:"hybrid",scope:"global",updatedAt:new Date},{key:"syncEnabled",value:!0,scope:"global",updatedAt:new Date},{key:"imageCompression",value:{enabled:!0,quality:.8,maxWidth:1920,maxHeight:1080,format:"webp"},scope:"global",updatedAt:new Date},{key:"databaseVersion",value:"3.0.0",scope:"global",updatedAt:new Date}];for(const t of e)await this.settings.where("key").equals(t.key).first()||await this.settings.add(t)}async rebuildSearchIndexes(){console.log("Rebuilding search indexes...")}async initializeOfflinePersistence(){console.log("Initializing offline persistence...");const e=[{key:"offlineAutoBackup",value:{enabled:!0,interval:30*60*1e3,maxBackups:10,compression:!0},scope:"global",updatedAt:new Date},{key:"offlineCompression",value:{enabled:!0,algorithm:"lz-string",threshold:1024,quality:.8},scope:"global",updatedAt:new Date},{key:"offlineDataRetention",value:{days:30,maxSize:100},scope:"global",updatedAt:new Date}];for(const t of e)await this.settings.where("key").equals(t.key).first()||await this.settings.add(t)}async createInitialOfflineSnapshot(){try{const e=await this.createOfflineSnapshot({includeCards:!0,includeFolders:!0,includeTags:!0,includeSettings:!0,includeImages:!1});console.log("Initial offline snapshot created:",e.id)}catch(e){console.error("Failed to create initial offline snapshot:",e)}}async createOfflineSnapshot(e={}){const{includeCards:t=!0,includeFolders:i=!0,includeTags:s=!0,includeImages:r=!1,includeSettings:n=!0,userId:a}=e,o=crypto.randomUUID(),c=new Date,l={};let h=0;t&&(l.cards=await this.cards.toArray(),h+=JSON.stringify(l.cards).length),i&&(l.folders=await this.folders.toArray(),h+=JSON.stringify(l.folders).length),s&&(l.tags=await this.tags.toArray(),h+=JSON.stringify(l.tags).length),r&&(l.images=await this.images.toArray(),h+=JSON.stringify(l.images).length),n&&(l.settings=await this.settings.toArray(),h+=JSON.stringify(l.settings).length);const g=await this.calculateDataHash(l),p=await this.getDeviceInfo(),w=await this.getStorageQuota(),M={id:o,timestamp:c,version:"4.0.0",userId:a,dataHash:g,dataSize:h,compressedSize:h,includes:{cards:t,folders:i,tags:s,images:r,settings:n},metadata:{deviceInfo:p,networkStatus:navigator.onLine?"online":"offline",batteryLevel:(navigator.getBattery?.(),void 0),storageQuota:w}};return await this.offlineSnapshots.add(M),M}async calculateDataHash(e){const t=JSON.stringify(e),s=new TextEncoder().encode(t),r=await crypto.subtle.digest("SHA-256",s);return Array.from(new Uint8Array(r)).map(a=>a.toString(16).padStart(2,"0")).join("")}async getDeviceInfo(){const e={userAgent:navigator.userAgent,platform:navigator.platform,language:navigator.language,deviceMemory:navigator.deviceMemory,hardwareConcurrency:navigator.hardwareConcurrency,screenResolution:`${screen.width}x${screen.height}`,timestamp:new Date().toISOString()};return JSON.stringify(e)}async getStorageQuota(){try{if("storage"in navigator&&"estimate"in navigator.storage){const e=await navigator.storage.estimate();return{used:e.usage||0,total:e.quota||0}}}catch(e){console.warn("Failed to get storage quota:",e)}return{used:0,total:0}}async restoreOfflineSnapshot(e){try{const t=await this.offlineSnapshots.get(e);if(!t)throw new Error("Snapshot not found");if(await this.getCurrentDataHash()===t.dataHash)return console.log("Data already matches snapshot, no restore needed"),!0;if(t.includes.cards){const s=await this.cards.toArray();await this.cards.clear()}if(t.includes.folders){const s=await this.folders.toArray();await this.folders.clear()}if(t.includes.tags){const s=await this.tags.toArray();await this.tags.clear()}if(t.includes.settings){const s=await this.settings.toArray();await this.settings.clear()}return console.log("Offline snapshot restored successfully:",e),!0}catch(t){return console.error("Failed to restore offline snapshot:",t),!1}}async getCurrentDataHash(){const e={cards:await this.cards.toArray(),folders:await this.folders.toArray(),tags:await this.tags.toArray(),settings:await this.settings.toArray()};return await this.calculateDataHash(e)}async cleanupOfflineData(){const e=new Date;let t=0,i=0,s=0;try{const r=await this.getSetting("offlineDataRetention"),n=r?.days||30,a=r?.maxSize||100,o=new Date(e.getTime()-n*24*60*60*1e3),c=await this.offlineSnapshots.where("timestamp").below(o).toArray();for(const p of c)s+=p.dataSize,await this.offlineSnapshots.delete(p.id),t++;const l=await this.offlineBackups.where("createdAt").below(o).toArray();for(const p of l)s+=p.size,await this.offlineBackups.delete(p.id),i++;const h=await this.offlineSnapshots.orderBy("timestamp").reverse().toArray();let g=h.reduce((p,w)=>p+w.dataSize,0);for(;g>a*1024*1024&&h.length>5;){const p=h.pop();p&&(s+=p.dataSize,await this.offlineSnapshots.delete(p.id),t++,g-=p.dataSize)}return console.log(`Offline data cleanup completed: ${t} snapshots, ${i} backups, ${s} bytes freed`),{cleanedSnapshots:t,cleanedBackups:i,freedSpace:s}}catch(r){return console.error("Failed to cleanup offline data:",r),{cleanedSnapshots:0,cleanedBackups:0,freedSpace:0}}}async autoBackupOfflineData(){try{const e=await this.getSetting("offlineAutoBackup");if(!e?.enabled)return!1;const t=await this.offlineSnapshots.orderBy("timestamp").reverse().first();if(t&&new Date().getTime()-t.timestamp.getTime()<e.interval)return!1;const s=await this.createOfflineSnapshot({includeCards:!0,includeFolders:!0,includeTags:!0,includeImages:!1,includeSettings:!0}),r=e.maxBackups||10,n=await this.offlineSnapshots.orderBy("timestamp").reverse().toArray();if(n.length>r){const a=n.slice(r);for(const o of a)await this.offlineSnapshots.delete(o.id)}return console.log("Auto backup completed:",s.id),!0}catch(e){return console.error("Auto backup failed:",e),!1}}async getOfflineDataStats(){const e=await this.offlineSnapshots.toArray(),t=await this.offlineBackups.toArray(),i=e.reduce((n,a)=>n+a.dataSize,0)+t.reduce((n,a)=>n+a.size,0),s=e.length>0?e.reduce((n,a)=>a.timestamp>n.timestamp?a:n,e[0]).timestamp:void 0,r=e.length>0?e.reduce((n,a)=>a.timestamp<n.timestamp?a:n,e[0]).timestamp:void 0;return{snapshots:e.length,backups:t.length,totalSize:i,lastBackup:s,oldestBackup:r}}async getSetting(e,t){if(t){const s=await this.settings.where("[key+scope]").equals([e,"user"]).first();if(s)return s.value}return(await this.settings.where("[key+scope]").equals([e,"global"]).first())?.value}async updateSetting(e,t,i="global",s){const r={value:t,updatedAt:new Date};s&&(r.userId=s),await this.settings.where("[key+scope]").equals([e,i]).modify(r)}async getStats(){const[e,t,i,s,r]=await Promise.all([this.cards.count(),this.folders.count(),this.tags.count(),this.images.count(),this.syncQueue.count()]),n=await this.calculateTotalSize();return{cards:e,folders:t,tags:i,images:s,pendingSync:r,totalSize:n,version:"3.0.0"}}async calculateTotalSize(){return(await this.images.toArray()).reduce((t,i)=>t+i.metadata.size,0)}async createCard(e,t){const i=crypto.randomUUID(),s=new Date;return await this.cards.add({...e,id:i,userId:t,syncVersion:1,pendingSync:!0,updatedAt:s}),i}async updateCard(e,t){return await this.cards.update(e,{...t,syncVersion:t.syncVersion?t.syncVersion+1:void 0,pendingSync:!0,updatedAt:new Date})}async deleteCard(e){await this.transaction("rw",[this.cards,this.images],async()=>{await this.images.where("cardId").equals(e).delete(),await this.cards.delete(e)})}async bulkCreateCards(e,t){const i=new Date,s=e.map(r=>({...r,id:crypto.randomUUID(),userId:t,syncVersion:1,pendingSync:!0,updatedAt:i}));return await this.cards.bulkAdd(s),s.map(r=>r.id)}async getCardsByFolder(e,t){return await this.cards.where("[userId+folderId]").equals([t||"default",e]).toArray()}async searchCards(e,t){const i=e.toLowerCase();return await this.cards.filter(s=>s.searchVector?.includes(i)||s.frontContent.title.toLowerCase().includes(i)||s.frontContent.text.toLowerCase().includes(i)||s.backContent.title.toLowerCase().includes(i)||s.backContent.text.toLowerCase().includes(i)).toArray()}async cleanup(){await this.transaction("rw",[this.cards,this.folders,this.tags,this.images,this.syncQueue],async()=>{const e=new Date(Date.now()-6048e5);await this.syncQueue.where("timestamp").below(e).delete();const t=await this.cards.toCollection().primaryKeys();await this.images.where("cardId").noneOf(t).delete(),console.log("Database cleanup completed")})}async healthCheck(){const e=[];try{await this.cards.count();const t=await this.getStats();return t.pendingSync>1e3&&e.push(`High number of pending sync operations: ${t.pendingSync}`),t.totalSize>500*1024*1024&&e.push(`Database size is large: ${(t.totalSize/1024/1024).toFixed(2)} MB`),{isHealthy:e.length===0,issues:e,stats:t}}catch(t){return{isHealthy:!1,issues:[`Database connection failed: ${t}`],stats:{cards:0,folders:0,tags:0,images:0,pendingSync:0,totalSize:0,version:"3.0.0"}}}}async clearAll(){await this.transaction("rw",[this.cards,this.folders,this.tags,this.images,this.syncQueue,this.settings,this.sessions],async()=>{await this.cards.clear(),await this.folders.clear(),await this.tags.clear(),await this.images.clear(),await this.syncQueue.clear(),await this.sessions.clear()})}async getSettingLegacy(e){return await this.getSetting(e)}async updateSettingLegacy(e,t){await this.updateSetting(e,t)}async clearAllLegacy(){await this.transaction("rw",[this.cards,this.folders,this.tags,this.images,this.syncQueue],async()=>{await this.cards.clear(),await this.folders.clear(),await this.tags.clear(),await this.images.clear(),await this.syncQueue.clear()})}async getStatsLegacy(){const e=await this.getStats();return{cards:e.cards,folders:e.folders,tags:e.tags,images:e.images,pendingSync:e.pendingSync}}}class oe extends q{cards;folders;tags;images;syncQueue;settings;constructor(){super("CardAllDatabase"),this.version(1).stores({cards:"++id, folderId, createdAt, updatedAt, syncVersion, pendingSync",folders:"++id, parentId, createdAt, updatedAt, syncVersion, pendingSync",tags:"++id, name, createdAt, syncVersion, pendingSync",images:"++id, cardId, filePath, createdAt, syncVersion, pendingSync",syncQueue:"++id, type, entity, entityId, timestamp, retryCount",settings:"++id, key, updatedAt"})}}const f=new ae;f.on("versionchange",d=>{console.warn("Database version changed:",d)});f.on("blocked",()=>{console.warn("Database operation blocked")});f.on("versionchange",()=>{console.warn("Database version changed, reloading page..."),window.location.reload()});f.on("ready",()=>{console.log("Database is ready")});const L=new Map,$=5*60*1e3;setInterval(()=>{const d=Date.now();L.forEach((e,t)=>{d-e.timestamp>$&&L.delete(t)})},$);class ce{detectionRules=new Map;resolutionStrategies=new Map;mergeStrategies=new Map;conflictPatterns=new Map;conflictHistory=[];resolutionStats=new Map;conflictPredictionModel;constructor(){this.initializeDetectionRules(),this.initializeResolutionStrategies(),this.initializeMergeStrategies(),this.initializeConflictPatterns(),this.initializeMLModel()}async detectAllConflicts(e,t,i,s,r){const n=[];for(const o of this.detectionRules.values())if(o.enabled&&!(o.entityType!=="all"&&o.entityType!==i))try{const c=await o.detectionFunction(e,t,r);n.push(...c)}catch(c){console.error(`Conflict detection rule ${o.id} failed:`,c)}const a=this.optimizeConflicts(n);return this.recordConflictDetection(a,r),a}async resolveConflicts(e,t){const i=[];for(const s of e)try{const r=await this.resolveSingleConflict(s,t);i.push(r)}catch(r){console.error(`Failed to resolve conflict ${s.id}:`,r),s.resolution="manual",s.autoResolved=!1,i.push(s)}return i}async resolveSingleConflict(e,t){const i=await this.predictResolutionStrategy(e,t),s=this.resolutionStrategies.get(i)||this.selectFallbackStrategy(e),r=await this.applyResolutionStrategy(e,s,t);return this.recordResolutionResult(e,s,r.success),r.conflict}initializeDetectionRules(){this.detectionRules.set("version-conflict",{id:"version-conflict",name:"Version Conflict Detection",description:"检测基于版本号的冲突",entityType:"all",priority:100,enabled:!0,detectionFunction:(e,t,i)=>this.detectVersionConflicts(e,t,i)}),this.detectionRules.set("field-conflict",{id:"field-conflict",name:"Field-Level Conflict Detection",description:"检测字段级别的冲突",entityType:"all",priority:90,enabled:!0,detectionFunction:(e,t,i)=>this.detectFieldConflicts(e,t,i)}),this.detectionRules.set("structure-conflict",{id:"structure-conflict",name:"Structure Conflict Detection",description:"检测数据结构冲突",entityType:"all",priority:80,enabled:!0,detectionFunction:(e,t,i)=>this.detectStructureConflicts(e,t,i)}),this.detectionRules.set("reference-conflict",{id:"reference-conflict",name:"Reference Integrity Conflict Detection",description:"检测引用完整性冲突",entityType:"all",priority:70,enabled:!0,detectionFunction:(e,t,i)=>this.detectReferenceConflicts(e,t,i)}),this.detectionRules.set("business-logic-conflict",{id:"business-logic-conflict",name:"Business Logic Conflict Detection",description:"检测业务逻辑冲突",entityType:"all",priority:60,enabled:!0,detectionFunction:(e,t,i)=>this.detectBusinessLogicConflicts(e,t,i)})}detectVersionConflicts(e,t,i){const s=[],r=e.sync_version||e.localVersion||0,n=t.sync_version||t.cloudVersion||0;return r!==n&&s.push({id:crypto.randomUUID(),entityType:this.inferEntityType(e),entityId:e.id||t.id,conflictType:"version",localData:e,cloudData:t,detectedAt:new Date}),s}detectFieldConflicts(e,t,i){const s=[],r=[],n=this.getComparableFields(e,t);for(const a of n){const o=this.getNestedValue(e,a),c=this.getNestedValue(t,a);this.valuesEqual(o,c)||r.push(a)}return r.length>0&&s.push({id:crypto.randomUUID(),entityType:this.inferEntityType(e),entityId:e.id||t.id,conflictType:"field",localData:e,cloudData:t,conflictFields:r,detectedAt:new Date}),s}detectStructureConflicts(e,t,i){const s=[],r=new Set(Object.keys(e)),n=new Set(Object.keys(t)),a=[...n].filter(c=>!r.has(c)),o=[...r].filter(c=>!n.has(c));return(a.length>0||o.length>0)&&s.push({id:crypto.randomUUID(),entityType:this.inferEntityType(e),entityId:e.id||t.id,conflictType:"structure",localData:e,cloudData:t,conflictFields:[...a,...o],detectedAt:new Date}),s}detectReferenceConflicts(e,t,i){const s=[];if((e.folderId!==void 0||t.folderId!==void 0)&&e.folderId!==t.folderId&&s.push({id:crypto.randomUUID(),entityType:"card",entityId:e.id||t.id,conflictType:"field",localData:e,cloudData:t,conflictFields:["folderId"],detectedAt:new Date}),e.tags!==void 0||t.tags!==void 0){const r=new Set(e.tags||[]),n=new Set(t.tags||[]);this.setsEqual(r,n)||s.push({id:crypto.randomUUID(),entityType:this.inferEntityType(e),entityId:e.id||t.id,conflictType:"field",localData:e,cloudData:t,conflictFields:["tags"],detectedAt:new Date})}return s}detectBusinessLogicConflicts(e,t,i){const s=[];if(e.frontContent||t.frontContent){const r=this.detectContentConflicts(e,t);r&&s.push(r)}if(e.style||t.style){const r=this.detectStyleConflicts(e,t);r&&s.push(r)}return s}initializeResolutionStrategies(){this.resolutionStrategies.set("timestamp-priority",{type:"auto",priority:1,conditions:{conflictType:"version"},resolution:"cloud",mergeFunction:(e,t)=>t.updatedAt&&e.updatedAt&&t.updatedAt>e.updatedAt?t:e}),this.resolutionStrategies.set("local-priority",{type:"auto",priority:2,conditions:{conflictType:"field"},resolution:"local",mergeFunction:(e,t)=>e}),this.resolutionStrategies.set("cloud-priority",{type:"auto",priority:3,conditions:{conflictType:"field"},resolution:"cloud",mergeFunction:(e,t)=>t}),this.resolutionStrategies.set("smart-merge",{type:"auto",priority:4,conditions:{conflictType:"field",canMerge:!0},resolution:"merge",mergeFunction:(e,t)=>{const i={...e};return Object.keys(t).forEach(s=>{(!e[s]||t.updatedAt&&e.updatedAt&&t.updatedAt>e.updatedAt)&&(i[s]=t[s])}),i}})}initializeMergeStrategies(){this.mergeStrategies.set("smart-text-merge",{id:"smart-text-merge",name:"Smart Text Merge",description:"智能合并文本内容，保留两边的修改",applicableTypes:["card"],mergeFunction:(e,t,i)=>this.smartTextMerge(e,t),confidence:.8}),this.mergeStrategies.set("timestamp-priority",{id:"timestamp-priority",name:"Timestamp Priority",description:"使用最新的时间戳决定优先级",applicableTypes:["all"],mergeFunction:(e,t,i)=>this.timestampPriorityMerge(e,t),confidence:.9}),this.mergeStrategies.set("field-smart-merge",{id:"field-smart-merge",name:"Field Smart Merge",description:"按字段类型智能选择最佳合并策略",applicableTypes:["all"],mergeFunction:(e,t,i)=>this.fieldSmartMerge(e,t),confidence:.85}),this.mergeStrategies.set("user-preference-merge",{id:"user-preference-merge",name:"User Preference Merge",description:"基于用户历史偏好进行合并",applicableTypes:["all"],mergeFunction:(e,t,i)=>this.userPreferenceMerge(e,t,i),confidence:.75}),this.mergeStrategies.set("ml-merge",{id:"ml-merge",name:"Machine Learning Merge",description:"使用机器学习模型预测最佳合并策略",applicableTypes:["all"],mergeFunction:(e,t,i)=>this.mlMerge(e,t,i),confidence:.7})}smartTextMerge(e,t){const i={...e};return e.frontContent&&t.frontContent&&(i.frontContent=this.mergeContent(e.frontContent,t.frontContent)),e.backContent&&t.backContent&&(i.backContent=this.mergeContent(e.backContent,t.backContent)),i}timestampPriorityMerge(e,t){const i=new Date(e.updatedAt||e.timestamp).getTime();return new Date(t.updatedAt||t.timestamp).getTime()>i?{...t}:{...e}}fieldSmartMerge(e,t){const i={...e};return Object.keys(t).forEach(s=>{e[s]===void 0?i[s]=t[s]:this.valuesEqual(e[s],t[s])||(i[s]=this.mergeFieldByType(s,e[s],t[s]))}),i}userPreferenceMerge(e,t,i){switch(this.analyzeUserPreference(i.userId)){case"local-first":return{...e};case"cloud-first":return{...t};case"smart-merge":return this.fieldSmartMerge(e,t);default:return this.timestampPriorityMerge(e,t)}}mlMerge(e,t,i){const s=this.extractFeatures(e,t,i);switch(this.predictMergeStrategy(s).strategy){case"local":return{...e};case"cloud":return{...t};case"merge":return this.fieldSmartMerge(e,t);default:return this.timestampPriorityMerge(e,t)}}initializeMLModel(){this.conflictPredictionModel={patterns:new Map,confidenceThreshold:.7},this.conflictPredictionModel.patterns.set("version-conflict-local",.8),this.conflictPredictionModel.patterns.set("field-conflict-merge",.6),this.conflictPredictionModel.patterns.set("structure-conflict-manual",.9)}async predictResolutionStrategy(e,t){const i=this.extractConflictFeatures(e,t),s=this.findSimilarConflicts(i);return s.length>0?this.getMostSuccessfulStrategy(s):this.heuristicStrategySelection(e,t)}extractConflictFeatures(e,t){return{conflictType:e.conflictType,entityType:e.entityType,fieldCount:e.conflictFields?.length||0,timeOfDay:t.timestamp.getHours(),dayOfWeek:t.timestamp.getDay(),networkQuality:t.networkInfo.effectiveType,deviceType:t.deviceInfo.deviceType,userHistoryLength:t.syncHistory.length,isWeekend:t.timestamp.getDay()===0||t.timestamp.getDay()===6}}findSimilarConflicts(e){const t=[];for(const i of this.conflictHistory)this.calculateSimilarity(e,i)>.7&&t.push(i);return t}calculateSimilarity(e,t){let i=0;e.conflictType===t.conflictType&&(i+=.3),e.entityType===t.entityType&&(i+=.2);const s=Math.abs(e.fieldCount-(t.conflictFields?.length||0));return i+=Math.max(0,.2-s*.05),i}getComparableFields(e,t){const i=new Set;return i.add("id"),i.add("sync_version"),i.add("updatedAt"),i.add("createdAt"),(e.frontContent||t.frontContent)&&(i.add("frontContent.title"),i.add("frontContent.text"),i.add("frontContent.tags")),(e.backContent||t.backContent)&&(i.add("backContent.title"),i.add("backContent.text"),i.add("backContent.tags")),(e.style||t.style)&&(i.add("style.type"),i.add("style.backgroundColor"),i.add("style.textColor")),(e.folderId!==void 0||t.folderId!==void 0)&&i.add("folderId"),Array.from(i)}getNestedValue(e,t){return t.split(".").reduce((i,s)=>i?.[s],e)}valuesEqual(e,t){return e===t?!0:e==null||t==null||typeof e!=typeof t?!1:typeof e=="object"?JSON.stringify(e)===JSON.stringify(t):!1}setsEqual(e,t){if(e.size!==t.size)return!1;for(const i of e)if(!t.has(i))return!1;return!0}inferEntityType(e){return e.frontContent||e.backContent?"card":e.name&&e.color?"tag":e.name&&e.cardIds?"folder":e.fileName&&e.filePath?"image":"unknown"}mergeContent(e,t){const i={...e};if(e.title!==t.title&&(i.title=this.mergeTextFields(e.title,t.title)),e.text!==t.text&&(i.text=this.mergeTextFields(e.text,t.text)),e.tags||t.tags){const s=new Set(e.tags||[]),r=new Set(t.tags||[]);i.tags=Array.from(new Set([...s,...r]))}return i}mergeTextFields(e,t){return e.length>t.length?e:t}mergeFieldByType(e,t,i){if(e.includes("time")||e.includes("date")){const s=new Date(t).getTime();return new Date(i).getTime()>s?i:t}return e.includes("version")?Math.max(t,i):typeof t=="string"&&typeof i=="string"?this.mergeTextFields(t,i):t}analyzeUserPreference(e){const t=this.resolutionStats.get(e);return!t||t.success>t.failure*2?"smart-merge":"timestamp-priority"}optimizeConflicts(e){const t=new Map;for(const i of e){const s=`${i.entityType}-${i.entityId}-${i.conflictType}`;(!t.has(s)||(t.get(s).priority||0)<(i.priority||0))&&t.set(s,i)}return Array.from(t.values())}recordConflictDetection(e,t){this.conflictHistory.push(...e),this.conflictHistory.length>1e3&&(this.conflictHistory=this.conflictHistory.slice(-500))}recordResolutionResult(e,t,i){const s=`${e.entityType}-${t}`,r=this.resolutionStats.get(s)||{success:0,failure:0};i?r.success++:r.failure++,this.resolutionStats.set(s,r)}initializeConflictPatterns(){this.conflictPatterns.set("simultaneous-edit",{id:"simultaneous-edit",pattern:"同时编辑",description:"多设备同时编辑同一内容",severity:"high",autoResolution:!1,resolutionStrategy:"manual"}),this.conflictPatterns.set("network-partition",{id:"network-partition",pattern:"网络分区",description:"网络分区导致的冲突",severity:"medium",autoResolution:!0,resolutionStrategy:"timestamp-priority"})}detectContentConflicts(e,t){return null}detectStyleConflicts(e,t){return null}selectFallbackStrategy(e){return{type:"manual",priority:0,conditions:{},resolution:"manual"}}async applyResolutionStrategy(e,t,i){return{conflict:e,success:!0}}getMostSuccessfulStrategy(e){return"timestamp-priority"}heuristicStrategySelection(e,t){return"timestamp-priority"}extractFeatures(e,t,i){return{}}predictMergeStrategy(e){return{strategy:"merge",confidence:.7}}}const le=new ce;class ue{userPreferences=new Map;conflictHistory=[];resolutionStats=new Map;strategyWeights=new Map([["timestamp-priority",.25],["local-priority",.2],["cloud-priority",.2],["smart-merge",.3],["user-preference",.05]]);constructor(){this.initializeDefaultPreferences(),this.loadUserPreferences(),this.initializeResolutionStats()}async resolveConflicts(e){const{localData:t,cloudData:i,entityType:s,entityId:r,userId:n,context:a={}}=e,o={userId:n,timestamp:new Date,networkInfo:await this.getNetworkInfo(),deviceInfo:await this.getDeviceInfo(),userPreferences:this.getUserPreferences(n),syncHistory:await this.getSyncHistory(n),...a};try{const c=await le.detectAllConflicts(t,i,s,r,o);if(c.length===0)return{success:!0,resolvedData:i||t,conflicts:[],resolutionStrategy:"no-conflict",confidence:1};const l=this.getUserPreferences(n),h=await this.selectResolutionStrategy(c,o,l),g=await this.executeResolutionStrategy(c,t,i,h,o);return await this.recordConflictResolution({conflicts:c,strategy:h.id,success:g.success,userId:n,entityType:s,entityId:r,timestamp:new Date}),g}catch(c){return console.error("Conflict resolution failed:",c),{success:!1,resolvedData:t,conflicts:[],resolutionStrategy:"fallback-local-priority",confidence:.5,unresolvedConflicts:[]}}}async predictConflicts(e,t,i,s){this.getUserPreferences(s);const r=this.analyzeDataDifferences(e,t),n=this.getTimeDifference(e,t),a=this.analyzeEditPatterns(e,t,s);let o=0;n>3e5&&(o+=.3),r.criticalFields>2&&(o+=.4),a.concurrentEdits&&(o+=.5);const c=await this.getHistoricalRisk(s,i);o+=c*.2,o=Math.min(o,1);let l="low";return o>=.8?l="critical":o>=.6?l="high":o>=.3&&(l="medium"),{riskLevel:l,probability:o,confidence:this.calculateConfidence(r,n,a),factors:this.generateRiskFactors(r,n,a),recommendations:this.generateRecommendations(l,r)}}async selectResolutionStrategy(e,t,i){const s=new Map,r=this.calculateTimestampStrategyScore(e,t);s.set("timestamp-priority",r);const n=this.calculateLocalStrategyScore(e,t,i);s.set("local-priority",n);const a=await this.calculateCloudStrategyScore(e,t);s.set("cloud-priority",a);const o=this.calculateMergeStrategyScore(e,t);s.set("smart-merge",o);const c=this.calculatePreferenceStrategyScore(e,t,i);s.set("user-preference",c);const l=new Map;for(const[p,w]of s){const M=this.strategyWeights.get(p)||.2;l.set(p,w*M)}let h="timestamp-priority",g=0;for(const[p,w]of l)w>g&&(g=w,h=p);return g<i.autoResolutionThreshold&&(h=i.defaultStrategy),this.getStrategyById(h)}calculateTimestampStrategyScore(e,t){let i=.5;return e.filter(r=>r.type==="version"||r.type==="field"&&r.fieldName==="updatedAt").length>0&&(i+=.3),(t.networkInfo?.effectiveType==="slow-2g"||t.networkInfo?.effectiveType==="2g")&&(i+=.2),Math.min(i,1)}calculateLocalStrategyScore(e,t,i){let s=.3;return i.preserveUserChanges&&(s+=.4),e.filter(n=>n.source==="local"&&n.fieldName!=="updatedAt").length>0&&(s+=.3),t.networkInfo?.online||(s+=.3),Math.min(s,1)}async calculateCloudStrategyScore(e,t){let i=.3;return e.filter(n=>n.source==="cloud"&&n.fieldName==="updatedAt").length>0&&(i+=.4),await this.getUserDeviceCount(t.userId)>1&&(i+=.3),Math.min(i,1)}calculateMergeStrategyScore(e,t){let i=.4;e.filter(n=>n.type==="field"&&!this.isCriticalField(n.fieldName)).length>0&&(i+=.4);const r=this.resolutionStats.get("smart-merge")?.success||0;return i+=r*.2,Math.min(i,1)}calculatePreferenceStrategyScore(e,t,i){let s=.2;return Object.keys(i.fieldSpecificStrategies).length>0&&(s+=.3),this.conflictHistory.filter(a=>a.userId===t.userId).length>0&&(s+=.5),Math.min(s,1)}async executeResolutionStrategy(e,t,i,s,r){switch(s.id){case"timestamp-priority":return await this.executeTimestampStrategy(e,t,i,r);case"local-priority":return await this.executeLocalStrategy(e,t,i,r);case"cloud-priority":return await this.executeCloudStrategy(e,t,i,r);case"smart-merge":return await this.executeSmartMergeStrategy(e,t,i,r);case"user-preference":return await this.executeUserPreferenceStrategy(e,t,i,r);default:return await this.executeTimestampStrategy(e,t,i,r)}}async executeTimestampStrategy(e,t,i,s){const r={...i},n=[],a=[],o=[];for(const c of e){const l=new Date(t.updatedAt||t.createdAt).getTime(),h=new Date(i.updatedAt||i.createdAt).getTime();l>h?c.fieldName?(r[c.fieldName]=t[c.fieldName],n.push(c.fieldName)):Object.assign(r,t):c.fieldName&&o.push(c.fieldName)}return{success:!0,resolvedData:r,conflicts:e,resolutionStrategy:"timestamp-priority",confidence:.8,resolutionDetails:{mergedFields:n,overwrittenFields:a,preservedFields:o,timestamp:new Date}}}async executeLocalStrategy(e,t,i,s){const r={...t},n=[],a=[];for(const o of e)o.fieldName&&a.push(o.fieldName);return{success:!0,resolvedData:r,conflicts:e,resolutionStrategy:"local-priority",confidence:.9,resolutionDetails:{mergedFields:n,overwrittenFields:a,preservedFields:[],timestamp:new Date}}}async executeCloudStrategy(e,t,i,s){const r={...i},n=[];for(const a of e)a.fieldName&&n.push(a.fieldName);return{success:!0,resolvedData:r,conflicts:e,resolutionStrategy:"cloud-priority",confidence:.9,resolutionDetails:{mergedFields:[],overwrittenFields:[],preservedFields:n,timestamp:new Date}}}async executeSmartMergeStrategy(e,t,i,s){const r={...i},n=[],a=[],o=[],c=[];for(const l of e)if(l.fieldName){const h=await this.mergeField(l.fieldName,t[l.fieldName],i[l.fieldName],s);if(h.success)r[l.fieldName]=h.value,n.push(l.fieldName);else{const g=new Date(t.updatedAt).getTime(),p=new Date(i.updatedAt).getTime();g>p?(r[l.fieldName]=t[l.fieldName],a.push(l.fieldName)):o.push(l.fieldName)}}else c.push(l);return{success:c.length===0,resolvedData:r,conflicts:e,resolutionStrategy:"smart-merge",confidence:c.length===0?.8:.6,userActionRequired:c.length>0,unresolvedConflicts:c.length>0?c:void 0,resolutionDetails:{mergedFields:n,overwrittenFields:a,preservedFields:o,timestamp:new Date}}}async executeUserPreferenceStrategy(e,t,i,s){const r=this.getUserPreferences(s.userId),n={...i},a=[],o=[],c=[];for(const l of e)if(l.fieldName)switch(r.fieldSpecificStrategies[l.fieldName]||r.defaultStrategy){case"local-priority":n[l.fieldName]=t[l.fieldName],o.push(l.fieldName);break;case"cloud-priority":c.push(l.fieldName);break;case"timestamp-priority":const g=new Date(t.updatedAt).getTime(),p=new Date(i.updatedAt).getTime();g>p?(n[l.fieldName]=t[l.fieldName],o.push(l.fieldName)):c.push(l.fieldName);break;case"smart-merge":const w=await this.mergeField(l.fieldName,t[l.fieldName],i[l.fieldName],s);w.success?(n[l.fieldName]=w.value,a.push(l.fieldName)):c.push(l.fieldName);break}return{success:!0,resolvedData:n,conflicts:e,resolutionStrategy:"user-preference",confidence:.85,resolutionDetails:{mergedFields:a,overwrittenFields:o,preservedFields:c,timestamp:new Date}}}async mergeField(e,t,i,s){switch(e){case"tags":return this.mergeTags(t,i);case"frontContent":case"backContent":return this.mergeCardContent(t,i);case"style":return this.mergeCardStyle(t,i);case"images":return this.mergeImages(t,i);default:return{success:!1,value:i}}}mergeTags(e,t){return!Array.isArray(e)||!Array.isArray(t)?{success:!1,value:t}:{success:!0,value:[...new Set([...e,...t])]}}mergeCardContent(e,t){if(!e||!t)return{success:!1,value:t||e};const i={...t};return e.text&&t.text&&(i.text=e.text.length>t.text.length?e.text:t.text),e.title&&t.title&&(i.title=e.lastModified>t.lastModified?e.title:t.title),i.lastModified=new Date(Math.max(new Date(e.lastModified).getTime(),new Date(t.lastModified).getTime())),{success:!0,value:i}}mergeCardStyle(e,t){if(!e||!t)return{success:!1,value:t||e};const i={...t};return Object.keys(e).forEach(s=>{e[s]&&e[s]!==t[s]&&(i[s]=e[s])}),{success:!0,value:i}}mergeImages(e,t){if(!Array.isArray(e)||!Array.isArray(t))return{success:!1,value:t||e};const i=new Map;return t.forEach(s=>{s.id&&i.set(s.id,s)}),e.forEach(s=>{s.id&&i.set(s.id,s)}),{success:!0,value:Array.from(i.values())}}initializeDefaultPreferences(){const e={defaultStrategy:"smart-merge",fieldSpecificStrategies:{tags:"smart-merge",images:"smart-merge",style:"smart-merge",frontContent:"timestamp-priority",backContent:"timestamp-priority"},autoResolutionThreshold:.7,preserveUserChanges:!0,conflictHistoryRetention:30};this.userPreferences.set("default",e)}async loadUserPreferences(){}initializeResolutionStats(){["timestamp-priority","local-priority","cloud-priority","smart-merge","user-preference"].forEach(t=>{this.resolutionStats.set(t,{success:0,failure:0})})}getUserPreferences(e){return this.userPreferences.get(e)||this.userPreferences.get("default")}async getNetworkInfo(){return"connection"in navigator?navigator.connection:{online:navigator.onLine}}async getDeviceInfo(){return{userAgent:navigator.userAgent,platform:navigator.platform,language:navigator.language}}async getSyncHistory(e){return[]}async getUserDeviceCount(e){return 1}async getHistoricalRisk(e,t){const i=this.conflictHistory.filter(r=>r.userId===e&&r.entityType===t);if(i.length===0)return 0;const s=i.length/Math.max(i.length+10,1);return Math.min(s,1)}analyzeDataDifferences(e,t){const i=new Set([...Object.keys(e||{}),...Object.keys(t||{})]);let s=0,r=0;return i.forEach(n=>{JSON.stringify(e[n])!==JSON.stringify(t[n])&&(s++,this.isCriticalField(n)&&r++)}),{totalFields:i.size,differentFields:s,criticalFields:r}}getTimeDifference(e,t){const i=new Date(e.updatedAt||e.createdAt).getTime(),s=new Date(t.updatedAt||t.createdAt).getTime();return Math.abs(i-s)}analyzeEditPatterns(e,t,i){const s=this.getTimeDifference(e,t),r=s<6e4,n=s<5e3;return{concurrentEdits:r,rapidEdits:n}}calculateConfidence(e,t,i){let s=.5;return e.totalFields>0&&(s+=e.differentFields/e.totalFields*.3),t>0&&(s+=Math.min(t/36e5,1)*.2),i.concurrentEdits&&(s+=.3),Math.min(s,1)}generateRiskFactors(e,t,i){const s=[];return e.criticalFields>0&&s.push(`检测到${e.criticalFields}个关键字段差异`),t>3e5&&s.push("数据修改时间差异较大"),i.concurrentEdits&&s.push("检测到可能的并发编辑"),s}generateRecommendations(e,t){const i=[];switch(e){case"critical":i.push("建议立即同步并手动检查冲突"),i.push("考虑备份本地数据");break;case"high":i.push("建议在同步前检查数据一致性"),i.push("使用智能合并策略");break;case"medium":i.push("建议启用自动冲突解决");break;case"low":i.push("可以安全地进行同步");break}return i}isCriticalField(e){return["id","userId","createdAt","folderId"].includes(e)}getStrategyById(e){return{id:e,name:e,description:`Strategy: ${e}`,priority:1,applicableTypes:["card","folder","tag","image"]}}async recordConflictResolution(e){const t=this.resolutionStats.get(e.strategy);t&&(e.success?t.success++:t.failure++),this.conflictHistory.push(...e.conflicts.map(i=>({...i,resolutionStrategy:e.strategy,resolutionSuccess:e.success,resolvedAt:e.timestamp}))),await this.updateStrategyWeights()}async updateStrategyWeights(){for(const[t,i]of this.resolutionStats){const s=i.success+i.failure;if(s>0){const r=i.success/s;this.strategyWeights.set(t,r*.5+.1)}}const e=Array.from(this.strategyWeights.values()).reduce((t,i)=>t+i,0);if(e>0)for(const[t,i]of this.strategyWeights)this.strategyWeights.set(t,i/e)}}const R=new ue,de={checkInterval:5e3,qualityCheckInterval:6e4,healthCheckInterval:12e4,qualityThresholds:{excellent:{rtt:100,downlink:10},good:{rtt:200,downlink:5},fair:{rtt:500,downlink:1},poor:{rtt:1e3,downlink:.1}},healthCheck:{enabled:!0,endpoints:["https://www.google.com","https://www.cloudflare.com","https://www.github.com","https://www.baidu.com","https://www.qq.com"],timeout:3e3,successThreshold:2},eventFilter:{minQualityChange:.1,debounceTime:1e3},adaptiveSync:{enabled:!0,qualityThreshold:.4,maxBatchSize:50,minBatchSize:1,stabilityWindow:5*60*1e3},circuitBreaker:{enabled:!0,failureThreshold:5,recoveryTimeout:6e4,halfOpenTimeout:3e4},performance:{enablePrediction:!0,predictionWindow:30*60*1e3,enableCompression:!0,enableCaching:!0,cacheSize:1e3}};class k{static instance=null;config;currentStatus;previousStatus=null;listeners=new Set;eventQueue=[];debounceTimer=null;baseDetector=null;healthChecker=null;checkTimer=null;qualityTimer=null;healthTimer=null;predictionTimer=null;stats;eventHistory=[];qualityHistory=[];circuitBreakers=new Map;currentStrategy;statusCache=new Map;isInitialized=!1;isMonitoring=!1;isDestroyed=!1;constructor(e={}){this.config={...de,...e},this.currentStatus=this.getInitialStatus(),this.stats=this.getInitialStats(),this.currentStrategy=this.calculateOptimalStrategy(this.currentStatus),this.initialize()}static getInstance(e){return(!k.instance||k.instance.isDestroyed)&&(k.instance=new k(e)),k.instance}initialize(){if(!this.isInitialized)try{this.initializeBaseDetector(),this.initializeHealthChecker(),this.setupEventListeners(),this.initializeCircuitBreakers(),this.initializeCache(),this.isInitialized=!0,console.log("NetworkManager initialized successfully")}catch(e){throw console.error("Failed to initialize NetworkManager:",e),e}}initializeBaseDetector(){typeof navigator<"u"&&(window.addEventListener("online",this.handleBrowserOnline.bind(this)),window.addEventListener("offline",this.handleBrowserOffline.bind(this)),"connection"in navigator&&navigator.connection.addEventListener("change",this.handleConnectionChange.bind(this)))}initializeHealthChecker(){}setupEventListeners(){}initializeCircuitBreakers(){["sync","upload","download","health-check"].forEach(t=>{this.circuitBreakers.set(t,{state:"closed",failureCount:0,lastFailureTime:null,nextAttemptTime:null,config:this.config.circuitBreaker})})}initializeCache(){this.statusCache.clear()}getInitialStatus(){const e=new Date;return{isOnline:typeof navigator<"u"?navigator.onLine:!0,isReliable:!1,connectionType:"unknown",effectiveType:"unknown",quality:"offline",qualityScore:0,canSync:!1,syncStrategy:this.getDefaultStrategy(),estimatedSyncTime:0,lastUpdated:e,features:this.getNetworkFeatures(),recommendations:[]}}getDefaultStrategy(){return{batchSize:10,batchDelay:1e3,connectTimeout:5e3,requestTimeout:3e4,totalTimeout:12e4,maxRetries:3,retryDelay:1e3,retryBackoffMultiplier:2,compressionEnabled:!0,prioritySyncEnabled:!0,backgroundSyncEnabled:!0,circuitBreakerEnabled:!0,failureThreshold:5,recoveryTimeout:6e4}}getInitialStats(){return{connectionChanges:0,onlineTime:0,offlineTime:0,avgOnlineDuration:0,averageQuality:0,qualityHistory:[],averageRtt:0,averageDownlink:0,averageJitter:0,totalSyncOperations:0,successfulSyncs:0,failedSyncs:0,averageSyncTime:0,errorCount:0,circuitBreakerTrips:0,averageRecoveryTime:0}}getNetworkFeatures(){return{connectionInfo:!!navigator.connection,saveData:!!navigator.connection?.saveData,backgroundSync:"serviceWorker"in navigator&&"SyncManager"in window,serviceWorker:"serviceWorker"in navigator,indexedDB:"indexedDB"in window,onlineEvents:typeof window<"u"}}startMonitoring(){this.isMonitoring||this.isDestroyed||(this.isMonitoring=!0,this.startPeriodicChecks(),this.checkNetworkStatus().catch(console.error),console.log("Network monitoring started"),this.emitEvent({type:"connection-change",timestamp:new Date,currentState:this.currentStatus,details:{action:"monitoring_started"}}))}stopMonitoring(){!this.isMonitoring||this.isDestroyed||(this.isMonitoring=!1,this.stopPeriodicChecks(),console.log("Network monitoring stopped"),this.emitEvent({type:"connection-change",timestamp:new Date,currentState:this.currentStatus,details:{action:"monitoring_stopped"}}))}getCurrentStatus(){return{...this.currentStatus}}getSyncStrategy(){return{...this.currentStrategy}}getStats(){return{...this.stats}}async checkNetworkStatus(){if(this.isDestroyed)return this.currentStatus;try{const e=await this.performNetworkCheck();return await this.updateNetworkStatus(e),e}catch(e){return console.error("Network status check failed:",e),this.recordError("check_failed",e),this.currentStatus}}async waitForOnline(e=6e4){return this.currentStatus.isOnline?!0:new Promise(t=>{const i=setTimeout(()=>{r(),t(!1)},e),s={onNetworkStateChanged:n=>{n.isOnline&&(r(),t(!0))}},r=()=>{clearTimeout(i),this.removeListener(s)};this.addListener(s)})}async getNetworkPrediction(){return this.config.performance.enablePrediction?this.performNetworkPrediction():{isStable:this.currentStatus.isOnline,confidence:.5,predictedDuration:300,predictedQuality:this.currentStatus.quality,recommendations:["预测功能未启用"],riskFactors:[]}}addListener(e){this.isDestroyed||this.listeners.add(e)}removeListener(e){this.listeners.delete(e)}async performNetworkCheck(){const e=Date.now();try{const t=navigator.onLine,i=this.getNetworkInfo();let s=t;this.config.healthCheck.enabled&&t&&(s=await this.performHealthCheck());const r=await this.assessNetworkQuality(),n={isOnline:t&&s,isReliable:this.calculateReliability(i,r),connectionType:i.connectionType,effectiveType:i.effectiveType,quality:r.quality,qualityScore:r.score,downlink:i.downlink,rtt:i.rtt,jitter:r.jitter,packetLoss:r.packetLoss,saveData:i.saveData,deviceMemory:i.deviceMemory,hardwareConcurrency:i.hardwareConcurrency,canSync:this.canPerformSync(t&&s,r),syncStrategy:this.calculateOptimalStrategy({...this.currentStatus,...r}),estimatedSyncTime:this.estimateSyncTime(i,r),lastUpdated:new Date,lastStableTime:t&&s?new Date:this.currentStatus.lastStableTime,features:this.getNetworkFeatures(),recommendations:this.generateRecommendations(r,i)},a=Date.now()-e;return this.recordPerformanceMetrics(a),n}catch(t){return console.error("Network check failed:",t),{...this.currentStatus,isOnline:!1,isReliable:!1,quality:"offline",qualityScore:0,canSync:!1,lastUpdated:new Date,recommendations:["网络检测失败，使用保守策略"]}}}getNetworkInfo(){const e=navigator.connection;return{connectionType:e?.type||"unknown",effectiveType:e?.effectiveType||"unknown",downlink:e?.downlink,rtt:e?.rtt,saveData:e?.saveData,deviceMemory:navigator.deviceMemory,hardwareConcurrency:navigator.hardwareConcurrency}}async assessNetworkQuality(){try{let e=.5;const t=navigator.connection?.rtt;t!==void 0&&(t<=100?e+=.3:t<=200?e+=.2:t<=500&&(e+=.1));const i=navigator.connection?.downlink;i!==void 0&&(i>=10?e+=.3:i>=5?e+=.2:i>=1&&(e+=.1));const s=navigator.connection?.type;(s==="wifi"||s==="ethernet")&&(e+=.1),navigator.connection?.saveData&&(e-=.1),e=Math.max(0,Math.min(1,e));let r;e>=.8?r="excellent":e>=.6?r="good":e>=.4?r="fair":e>=.2?r="poor":r="offline";let n,a;if(this.config.performance.enablePrediction&&e>.3){const o=await this.performAdvancedQualityCheck();n=o.jitter,a=o.packetLoss,n>100&&(e-=.1),a>.1&&(e-=.2)}return{quality:r,score:Math.max(0,Math.min(1,e)),jitter:n,packetLoss:a}}catch(e){return console.warn("Quality assessment failed:",e),{quality:"fair",score:.5}}}async performAdvancedQualityCheck(){return{}}async performHealthCheck(){if(!this.config.healthCheck.enabled||this.config.healthCheck.endpoints.length===0)return!0;try{const e=this.selectHealthCheckEndpoints(),t=e.map(a=>this.pingEndpoint(a,this.config.healthCheck.timeout)),s=(await Promise.allSettled(t)).filter(a=>a.status==="fulfilled"&&a.value).length,r=Math.ceil(e.length*.4),n=Math.max(1,Math.min(r,this.config.healthCheck.successThreshold));return s>=n}catch(e){return console.warn("Health check failed:",e),!1}}selectHealthCheckEndpoints(){const e=this.config.healthCheck.endpoints;return this.currentStatus.connectionType==="cellular"?["https://www.baidu.com","https://www.google.com"]:(navigator.language||"en").startsWith("zh")?["https://www.baidu.com","https://www.qq.com","https://www.google.com"]:e.slice(0,3)}async pingEndpoint(e,t){try{const i=new AbortController,s=setTimeout(()=>i.abort(),t),r=e.includes("google.com"),n=e.includes("baidu.com")||e.includes("qq.com");let a;r?a="https://www.googleapis.com/generate_204":n?a=`${e}/favicon.ico`:a=`${e}/favicon.ico`;const o=await fetch(a,{method:r?"GET":"HEAD",signal:i.signal,mode:"no-cors",headers:{"Cache-Control":"no-cache",Pragma:"no-cache","User-Agent":"CardAll-Network-Check/1.0"}});return clearTimeout(s),r?o.status===204:!0}catch{return!1}}async updateNetworkStatus(e){this.previousStatus={...this.currentStatus},this.currentStatus=e,this.updateStats(),this.hasSignificantChange(this.previousStatus,e)&&(await this.handleStatusChange(),this.updateSyncStrategy(),e.canSync&&this.config.adaptiveSync.enabled&&this.emitEvent({type:"sync-ready",timestamp:new Date,currentState:e,severity:"info"}))}hasSignificantChange(e,t){return e.isOnline!==t.isOnline||e.isReliable!==t.isReliable||e.quality!==t.quality||Math.abs(e.qualityScore-t.qualityScore)>=this.config.eventFilter.minQualityChange||e.canSync!==t.canSync}async handleStatusChange(){const t={type:this.determineEventType(),timestamp:new Date,previousState:this.previousStatus||void 0,currentState:this.currentStatus,details:this.getEventDetails(),severity:this.determineEventSeverity()};this.eventHistory.push(t),this.eventHistory.length>1e3&&(this.eventHistory=this.eventHistory.slice(-500)),this.debouncedEmitEvent(t),await this.notifyStatusChange(),this.currentStatus.isOnline&&this.previousStatus?.isOnline===!1&&this.resetAllCircuitBreakers()}determineEventType(){return this.previousStatus?this.previousStatus.isOnline!==this.currentStatus.isOnline?this.currentStatus.isOnline?"online":"offline":this.previousStatus.quality!==this.currentStatus.quality?"quality-change":"connection-change":"connection-change"}getEventDetails(){const e={};return this.previousStatus&&(e.qualityChange=this.currentStatus.qualityScore-this.previousStatus.qualityScore,e.rttChange=(this.currentStatus.rtt||0)-(this.previousStatus.rtt||0),e.downlinkChange=(this.currentStatus.downlink||0)-(this.previousStatus.downlink||0)),e}determineEventSeverity(){return this.currentStatus.isOnline?!this.currentStatus.isReliable||this.currentStatus.quality==="poor"?"warning":"info":"error"}debouncedEmitEvent(e){this.config.eventFilter.debounceTime>0?(this.debounceTimer&&clearTimeout(this.debounceTimer),this.debounceTimer=setTimeout(()=>{this.emitEvent(e)},this.config.eventFilter.debounceTime)):this.emitEvent(e)}emitEvent(e){this.listeners.forEach(t=>{try{t.onNetworkEvent&&t.onNetworkEvent(e)}catch(i){console.error("Error in network event listener:",i)}})}async notifyStatusChange(){const e=this.getCurrentStatus();this.listeners.forEach(t=>{try{t.onNetworkStateChanged&&t.onNetworkStateChanged(e)}catch(i){console.error("Error in network state listener:",i)}})}calculateOptimalStrategy(e){const t=this.getDefaultStrategy();switch(e.quality){case"excellent":return{...t,batchSize:Math.min(this.config.adaptiveSync.maxBatchSize,50),batchDelay:500,requestTimeout:1e4,retryDelay:500,compressionEnabled:!1,maxRetries:2};case"good":return{...t,batchSize:25,batchDelay:1e3,requestTimeout:2e4,retryDelay:1e3,compressionEnabled:!1};case"fair":return{...t,batchSize:10,batchDelay:2e3,requestTimeout:3e4,compressionEnabled:!0,maxRetries:4};case"poor":return{...t,batchSize:Math.max(this.config.adaptiveSync.minBatchSize,5),batchDelay:5e3,requestTimeout:6e4,retryDelay:2e3,compressionEnabled:!0,maxRetries:6,circuitBreakerEnabled:!0};default:return{...t,batchSize:1,batchDelay:1e4,requestTimeout:12e4,retryDelay:5e3,compressionEnabled:!0,maxRetries:10}}}updateSyncStrategy(){const e=this.calculateOptimalStrategy(this.currentStatus);this.hasStrategyChanged(this.currentStrategy,e)&&(this.currentStrategy=e,this.currentStatus.syncStrategy=e,this.listeners.forEach(t=>{try{t.onSyncReady&&t.onSyncReady(e)}catch(i){console.error("Error in sync strategy listener:",i)}}))}hasStrategyChanged(e,t){return e.batchSize!==t.batchSize||e.batchDelay!==t.batchDelay||e.requestTimeout!==t.requestTimeout||e.compressionEnabled!==t.compressionEnabled||e.maxRetries!==t.maxRetries}calculateReliability(e,t){if(!this.currentStatus.isOnline)return!1;const i=this.calculateReliabilityFactors(e,t);return this.calculateOverallReliabilityScore(i)>=.6}calculateReliabilityFactors(e,t){const i=this.currentStatus.isOnline?1:0,s=t.score;let r=1;e.rtt&&(e.rtt<=100?r=1:e.rtt<=300?r=.8:e.rtt<=1e3?r=.6:r=.3);const n=this.calculateNetworkStability();let a=1;return t.packetLoss!==void 0&&(a=Math.max(0,1-t.packetLoss*10)),{connectivity:i,quality:s,latency:r,stability:n,packetLoss:a}}calculateOverallReliabilityScore(e){const t={connectivity:.35,quality:.25,latency:.2,stability:.15,packetLoss:.05};return e.connectivity*t.connectivity+e.quality*t.quality+e.latency*t.latency+e.stability*t.stability+e.packetLoss*t.packetLoss}calculateNetworkStability(){const e=Date.now(),t=this.config.adaptiveSync.stabilityWindow,i=this.eventHistory.filter(s=>e-s.timestamp.getTime()<t&&["online","offline","quality-change"].includes(s.type)).length;return i===0?1:i<=2?.8:i<=5?.6:i<=10?.4:.2}canPerformSync(e,t){if(!e||t.score<this.config.adaptiveSync.qualityThreshold)return!1;const i=this.circuitBreakers.get("sync");return!(i&&i.state==="open")}estimateSyncTime(e,t){if(!this.currentStatus.isOnline)return 1/0;const i=1e3,s=e.rtt?Math.max(1,e.rtt/100):1,r=e.downlink?Math.max(.5,5/e.downlink):2,n=Math.max(.5,2-t.score);return i*s*r*n}checkCircuitBreaker(e){const t=this.circuitBreakers.get(e);if(!t||!this.config.circuitBreaker.enabled)return!0;const i=t;return i.state==="open"?Date.now()>=(i.nextAttemptTime||0)?(i.state="half_open",console.log(`Circuit breaker for ${e} moved to half-open state`),!0):!1:i.state!=="open"}recordSuccess(e){const t=this.circuitBreakers.get(e);t&&(t.failureCount=0,t.state="closed",t.lastFailureTime=null,t.nextAttemptTime=null)}recordFailure(e,t){const i=this.circuitBreakers.get(e);!i||!this.config.circuitBreaker.enabled||(i.failureCount++,i.lastFailureTime=new Date,i.failureCount>=this.config.circuitBreaker.failureThreshold&&(i.state="open",i.nextAttemptTime=new Date(Date.now()+this.config.circuitBreaker.recoveryTimeout),this.stats.circuitBreakerTrips++,console.log(`Circuit breaker for ${e} tripped: ${i.failureCount} failures`),setTimeout(()=>{i.state==="open"&&(i.state="half_open",console.log(`Circuit breaker for ${e} moved to half-open state`))},this.config.circuitBreaker.halfOpenTimeout)))}resetCircuitBreaker(e){const t=this.circuitBreakers.get(e);t&&(t.failureCount=0,t.state="closed",t.lastFailureTime=null,t.nextAttemptTime=null)}resetAllCircuitBreakers(){this.circuitBreakers.forEach((e,t)=>{this.resetCircuitBreaker(t)})}async performNetworkPrediction(){const e=Date.now(),t=this.config.performance.predictionWindow,i=this.eventHistory.filter(c=>e-c.timestamp.getTime()<=t);if(i.length<5)return{isStable:this.currentStatus.isOnline,confidence:.3,predictedDuration:300,predictedQuality:this.currentStatus.quality,recommendations:["数据不足，建议监控网络状态"],riskFactors:["历史数据不足"]};const s=this.analyzeNetworkStability(i),r=this.analyzeQualityTrend(),n=this.generatePrediction(s,r),a=this.generateSmartRecommendations(n,i),o=this.identifyRiskFactors(i);return{...n,recommendations:a,riskFactors:o}}analyzeNetworkStability(e){const t=e.filter(l=>l.type==="online"),i=e.filter(l=>l.type==="offline"),s=this.calculateOnlineDurations(e),r=s.length>0?s.reduce((l,h)=>l+h,0)/s.length:0,n=t.length+i.length,a=e.length>0?e[e.length-1].timestamp.getTime()-e[0].timestamp.getTime():0,o=a>0?n/a*6e4:0;let c=1;return o>2&&(c-=.3),r<5*60*1e3&&(c-=.2),i.length>t.length&&(c-=.4),{stabilityScore:Math.max(0,c),avgOnlineDuration:r,changeFrequency:o}}calculateOnlineDurations(e){const t=[];let i=null;for(const s of e)s.type==="online"&&i===null?i=s.timestamp.getTime():s.type==="offline"&&i!==null&&(t.push(s.timestamp.getTime()-i),i=null);return i!==null&&t.push(Date.now()-i),t}analyzeQualityTrend(){if(this.qualityHistory.length<3)return"stable";const e=this.qualityHistory.slice(-3).map(n=>n.score),t=this.qualityHistory.slice(-6,-3).map(n=>n.score);if(t.length===0)return"stable";const i=e.reduce((n,a)=>n+a,0)/e.length,s=t.reduce((n,a)=>n+a,0)/t.length,r=i-s;return r>.1?"improving":r<-.1?"degrading":"stable"}generatePrediction(e,t){const i=e.stabilityScore>=.7&&t!=="degrading",s=Math.min(e.stabilityScore,.9);let r;i?e.avgOnlineDuration>30*60*1e3?r=30*60*1e3:r=e.avgOnlineDuration*.8:r=5*60*1e3;let n=this.currentStatus.quality;return t==="improving"?this.currentStatus.quality==="poor"?n="fair":this.currentStatus.quality==="fair"&&(n="good"):t==="degrading"&&(this.currentStatus.quality==="good"?n="fair":this.currentStatus.quality==="fair"&&(n="poor")),{isStable:i,confidence:s,predictedDuration:r,predictedQuality:n}}generateSmartRecommendations(e,t){const i=[];return e.isStable||(i.push("网络连接不稳定，建议切换到更稳定的网络"),i.push("建议启用离线模式和数据压缩")),e.predictedQuality==="poor"&&(i.push("网络质量较差，建议减少同步频率"),i.push("建议使用较小的批处理大小")),e.isStable&&e.predictedQuality==="excellent"&&(i.push("网络状态优秀，适合进行大规模数据同步"),i.push("可以考虑禁用数据压缩以提高性能")),t.filter(r=>r.type==="error").length>3&&i.push("最近网络错误较多，建议检查网络连接"),i}identifyRiskFactors(e){const t=[];e.filter(a=>["online","offline"].includes(a.type)).length>5&&t.push("网络连接频繁变化");const s=e.filter(a=>a.type==="quality-change");return s.filter(a=>a.details?.qualityChange<0).length>s.length*.6&&t.push("网络质量呈下降趋势"),e.filter(a=>a.type==="error").length>2&&t.push("网络错误频率较高"),t}updateStats(){if(!this.previousStatus)return;this.previousStatus.isOnline!==this.currentStatus.isOnline&&(this.stats.connectionChanges++,this.currentStatus.isOnline?(this.stats.lastOfflineTime&&(this.stats.offlineTime+=Date.now()-this.stats.lastOfflineTime,this.stats.lastOfflineTime=void 0),this.stats.lastOnlineTime=Date.now()):(this.stats.lastOnlineTime&&(this.stats.onlineTime+=Date.now()-this.stats.lastOnlineTime,this.stats.lastOnlineTime=void 0),this.stats.lastOfflineTime=Date.now())),this.qualityHistory.push({timestamp:new Date,quality:this.currentStatus.quality,score:this.currentStatus.qualityScore}),this.qualityHistory.length>100&&(this.qualityHistory=this.qualityHistory.slice(-50));const e=this.qualityHistory.slice(-20);e.length>0&&(this.stats.averageQuality=e.reduce((t,i)=>t+i.score,0)/e.length),this.currentStatus.rtt!==void 0&&(this.stats.averageRtt===0?this.stats.averageRtt=this.currentStatus.rtt:this.stats.averageRtt=this.stats.averageRtt*.8+this.currentStatus.rtt*.2),this.currentStatus.downlink!==void 0&&(this.stats.averageDownlink===0?this.stats.averageDownlink=this.currentStatus.downlink:this.stats.averageDownlink=this.stats.averageDownlink*.8+this.currentStatus.downlink*.2),this.currentStatus.jitter!==void 0&&(this.stats.averageJitter===0?this.stats.averageJitter=this.currentStatus.jitter:this.stats.averageJitter=this.stats.averageJitter*.8+this.currentStatus.jitter*.2),this.currentStatus.packetLoss!==void 0&&(this.stats.packetLoss=this.currentStatus.packetLoss)}recordPerformanceMetrics(e){}recordError(e,t){this.stats.errorCount++;let i="network_slow",s="medium",r=`Network error: ${e}`;t instanceof Error&&(t.name==="AbortError"||t.message.includes("timeout")?(i="timeout",s="high",r="Network timeout detected"):t.message.includes("fetch")||t.message.includes("network")?(i="connection_lost",s="critical",r="Network connection lost"):t.message.includes(" CORS ")||t.message.includes("cross-origin")?(i="server_error",s="low",r="CORS error detected (may be temporary)"):(t.message.includes("429")||t.message.includes("rate limit"))&&(i="rate_limited",s="medium",r="Rate limit exceeded")),e==="health_check_failed"?(i="health_check_failed",s="high"):e==="quality_check_failed"&&(i="network_slow",s="medium");const n={type:i,message:r,timestamp:new Date,severity:s,details:{originalType:e,originalError:t instanceof Error?t.message:String(t),networkStatus:this.getCurrentStatus()}};this.stats.lastError=n,(s==="critical"||s==="high")&&this.recordFailure("health-check",n),this.listeners.forEach(a=>{try{a.onNetworkError&&a.onNetworkError(n)}catch(o){console.error("Error in network error listener:",o)}}),console.error(`Network Error [${i}]:`,{message:r,severity:s,details:n.details,timestamp:n.timestamp})}startPeriodicChecks(){this.checkTimer=setInterval(async()=>{this.isMonitoring&&await this.checkNetworkStatus()},this.config.checkInterval),this.qualityTimer=setInterval(async()=>{this.isMonitoring&&await this.performQualityCheck()},this.config.qualityCheckInterval),this.healthTimer=setInterval(async()=>{this.isMonitoring&&this.config.healthCheck.enabled&&await this.performHealthCheck()},this.config.healthCheckInterval),this.config.performance.enablePrediction&&(this.predictionTimer=setInterval(async()=>{if(this.isMonitoring){const e=await this.getNetworkPrediction();this.listeners.forEach(t=>{try{t.onNetworkPrediction&&t.onNetworkPrediction(e)}catch(i){console.error("Error in network prediction listener:",i)}})}},5*60*1e3))}stopPeriodicChecks(){this.checkTimer&&(clearInterval(this.checkTimer),this.checkTimer=null),this.qualityTimer&&(clearInterval(this.qualityTimer),this.qualityTimer=null),this.healthTimer&&(clearInterval(this.healthTimer),this.healthTimer=null),this.predictionTimer&&(clearInterval(this.predictionTimer),this.predictionTimer=null)}async performQualityCheck(){try{const e=await this.assessNetworkQuality();this.adaptQualityCheckFrequency(e),Math.abs(e.score-this.currentStatus.qualityScore)>=this.config.eventFilter.minQualityChange&&await this.checkNetworkStatus()}catch(e){console.warn("Quality check failed:",e),this.recordError("quality_check_failed",e)}}adaptQualityCheckFrequency(e){const t=e.score;let i;t>=.8?i=12e4:t>=.6?i=6e4:t>=.4?i=3e4:i=15e3,Math.abs(i-this.config.qualityCheckInterval)>1e4&&(this.config.qualityCheckInterval=i,this.isMonitoring&&this.qualityTimer&&(clearInterval(this.qualityTimer),this.qualityTimer=setInterval(async()=>{this.isMonitoring&&await this.performQualityCheck()},this.config.qualityCheckInterval),console.log(`Quality check interval adapted to ${i}ms based on network quality`)))}handleBrowserOnline(){console.log("Browser online event detected"),this.checkNetworkStatus().catch(console.error)}handleBrowserOffline(){console.log("Browser offline event detected"),this.checkNetworkStatus().catch(console.error)}handleConnectionChange(){console.log("Connection API change detected"),this.checkNetworkStatus().catch(console.error)}generateRecommendations(e,t){const i=[];return e.score<.3?(i.push("网络质量较差，建议启用数据压缩"),i.push("建议使用较小的批处理大小"),i.push("建议切换到更稳定的网络连接")):e.score<.6&&(i.push("网络质量一般，建议优化数据传输"),i.push("建议启用重试机制")),e.jitter&&e.jitter>100&&(i.push("网络抖动较高，建议减少实时同步"),i.push("建议增加超时时间")),e.packetLoss&&e.packetLoss>.05&&(i.push("存在网络丢包，建议启用数据校验"),i.push("建议减少批处理大小")),t.connectionType==="cellular"&&(i.push("移动网络连接，建议注意流量使用"),i.push("建议启用数据压缩")),this.currentStatus.features.backgroundSync||i.push("建议启用后台同步以改善离线体验"),this.currentStatus.features.connectionInfo||i.push("浏览器不支持详细网络信息，使用基本检测策略"),i}setCache(e,t,i=6e4){this.config.performance.enableCaching&&(this.statusCache.set(e,{data:t,timestamp:Date.now()}),setTimeout(()=>{this.statusCache.delete(e)},i))}getCache(e){if(!this.config.performance.enableCaching)return null;const t=this.statusCache.get(e);return t?Date.now()-t.timestamp>6e4?(this.statusCache.delete(e),null):t.data:null}clearCache(){this.statusCache.clear()}destroy(){if(!this.isDestroyed){if(this.isDestroyed=!0,this.isMonitoring=!1,this.isInitialized=!1,this.stopPeriodicChecks(),this.debounceTimer&&(clearTimeout(this.debounceTimer),this.debounceTimer=null),typeof window<"u"){window.removeEventListener("online",this.handleBrowserOnline.bind(this)),window.removeEventListener("offline",this.handleBrowserOffline.bind(this));const e=navigator.connection;e&&e.removeEventListener("change",this.handleConnectionChange.bind(this))}this.listeners.clear(),this.clearCache(),this.circuitBreakers.clear(),this.eventHistory.length=0,this.qualityHistory.length=0,k.instance===this&&(k.instance=null),console.log("NetworkManager destroyed")}}getCurrentState(){return console.warn("getCurrentState() is deprecated, use getCurrentStatus() instead"),this.getCurrentStatus()}getNetworkQuality(){return console.warn("getNetworkQuality() is deprecated, use getCurrentStatus().quality instead"),this.getCurrentStatus().quality}getConnectionQuality(){return console.warn("getConnectionQuality() is deprecated, use getCurrentStatus().qualityScore instead"),this.getCurrentStatus().qualityScore}isSuitableForSync(e=1024*1024){return console.warn("isSuitableForSync() is deprecated, use getCurrentStatus().canSync instead"),this.getCurrentStatus().canSync}getDiagnostics(){return console.warn("getDiagnostics() is deprecated, use getStats() and getCurrentStatus() instead"),{status:this.getCurrentStatus(),features:this.currentStatus.features,quality:this.currentStatus.qualityScore,recommendations:this.currentStatus.recommendations}}}const v=k.getInstance();typeof window<"u"&&(window.NetworkManager=k,window.networkManager=v);class he{isProcessing=!1;processingInterval;retryDelays=[1e3,2e3,5e3,1e4,3e4,6e4,12e4];batchSize=10;maxConcurrentBatches=3;currentBatches=0;queueStorage=new Map;operationHistory=new Map;recoveryMode=!1;lastPersistenceTime=0;persistenceInterval=3e4;errorThreshold=5;recentErrors=[];circuitBreakerOpen=!1;circuitBreakerTimeout=6e4;performanceMetrics={totalProcessed:0,totalFailed:0,averageProcessingTime:0,lastResetTime:Date.now()};listeners={};constructor(){this.initializeQueue(),this.startQueueProcessor(),this.initializePersistence(),this.initializeCircuitBreaker(),this.initializePerformanceMonitoring()}async enqueueOperation(e){if(this.circuitBreakerOpen)throw new Error("Circuit breaker is open - queue processing is temporarily suspended");const t={...e,id:crypto.randomUUID(),status:"pending",timestamp:new Date,operationMetadata:{createdAt:new Date,networkInfo:await this.getCurrentNetworkInfo(),resourceUsage:this.getCurrentResourceUsage()}};try{return e.dependencies&&e.dependencies.length>0&&await this.validateDependencies(e.dependencies),await this.validateOperation(t),await f.syncQueue.add({id:t.id,type:e.type,entity:e.entity,entityId:e.entityId,userId:e.userId,data:e.data,priority:e.priority,timestamp:t.timestamp,retryCount:e.retryCount,maxRetries:e.maxRetries,error:e.error,processingTime:0,nextRetryTime:void 0,operationMetadata:t.operationMetadata}),this.queueStorage.set(t.id,t),this.initializeOperationHistory(t),this.notifyStatusChange(),e.priority==="high"&&!this.isProcessing&&this.processNextBatch(),t.id}catch(i){throw await this.handleError(i,"enqueueOperation",t.id),i}}async enqueueBatch(e){if(this.circuitBreakerOpen)throw new Error("Circuit breaker is open - queue processing is temporarily suspended");const t=await this.getCurrentNetworkInfo(),i=this.getCurrentResourceUsage(),s=e.map(r=>({...r,id:crypto.randomUUID(),status:"pending",timestamp:new Date,operationMetadata:{createdAt:new Date,networkInfo:t,resourceUsage:i}}));try{const r=s.filter(o=>o.dependencies&&o.dependencies.length>0).flatMap(o=>o.dependencies);r.length>0&&await this.validateDependencies(r);for(const o of s)await this.validateOperation(o);const n=s.map(o=>({id:o.id,type:o.type,entity:o.entity,entityId:o.entityId,userId:o.userId,data:o.data,priority:o.priority,timestamp:o.timestamp,retryCount:o.retryCount,maxRetries:o.maxRetries,error:o.error,processingTime:0,nextRetryTime:void 0,operationMetadata:o.operationMetadata}));return await f.syncQueue.bulkAdd(n),s.forEach(o=>{this.queueStorage.set(o.id,o),this.initializeOperationHistory(o)}),this.notifyStatusChange(),s.some(o=>o.priority==="high")&&!this.isProcessing&&this.processNextBatch(),s.map(o=>o.id)}catch(r){throw await this.handleBatchError(r,"enqueueBatch",s),r}}async dequeueOperation(e){try{const t=await f.syncQueue.where("id").equals(e).delete();return this.notifyStatusChange(),t>0}catch(t){return console.error("Failed to dequeue operation:",t),!1}}async updateOperationStatus(e,t,i){try{await f.syncQueue.where("id").equals(e).modify({status:t,error:i,...t==="processing"?{retryCount:Dexie.currentTransaction?.table("syncQueue").get(e).then(r=>(r?.retryCount||0)+1)}:{}}),this.notifyStatusChange();const s=await f.syncQueue.get(e);s&&this.listeners.onOperationComplete&&this.listeners.onOperationComplete(this.convertSyncOperationToQueueOperation(s),t==="completed")}catch(s){console.error("Failed to update operation status:",s)}}async processNextBatch(){if(!(this.isProcessing||this.currentBatches>=this.maxConcurrentBatches)){this.isProcessing=!0,this.currentBatches++;try{const e=await this.getNextBatch();if(e.length===0){this.isProcessing=!1,this.currentBatches--;return}const t=e.map(s=>s.id);await this.markOperationsProcessing(t);const i=await this.processBatch(e);this.listeners.onBatchComplete&&this.listeners.onBatchComplete(i)}catch(e){console.error("Error processing batch:",e),this.listeners.onQueueError&&this.listeners.onQueueError(e instanceof Error?e:new Error(String(e)))}finally{this.isProcessing=!1,this.currentBatches--,setTimeout(()=>this.processNextBatch(),100)}}}async getNextBatch(){try{return(await f.syncQueue.where("status").equals("pending").toArray()).sort((t,i)=>{const s={critical:4,high:3,medium:2,low:1},r=s[t.priority]||1,n=s[i.priority]||1;return r!==n?n-r:t.timestamp.getTime()-i.timestamp.getTime()}).slice(0,this.batchSize)}catch(e){return console.error("Failed to get next batch:",e),[]}}async markOperationsProcessing(e){await f.syncQueue.where("id").anyOf(e).modify({status:"processing"})}async processBatch(e){const t=crypto.randomUUID(),i=performance.now(),s=[],r=[],n=[];try{for(const l of e)try{await this.executeSyncOperation(l)?(s.push(l.id),await this.updateOperationStatus(l.id,"completed")):(r.push(l.id),n.push(`Sync failed for operation ${l.id}`),await this.handleOperationFailure(l,"Sync execution failed"))}catch(h){r.push(l.id);const g=h instanceof Error?h.message:String(h);n.push(g),await this.handleOperationFailure(l,g)}const a=performance.now()-i,o=await this.getCurrentNetworkInfo(),c=this.getCurrentResourceUsage();return{batchId:t,operations:e.length,successful:s.length,failed:r.length,errors:n,executionTime:a,timestamp:new Date,processingDetails:{averageOperationTime:a/e.length,networkConditions:o,resourceUsage:{memoryUsed:c.memory,cpuUsage:c.cpu}}}}catch(a){const o=performance.now()-i,c=a instanceof Error?a.message:String(a);for(const g of e)await this.handleOperationFailure(g,c);const l=await this.getCurrentNetworkInfo(),h=this.getCurrentResourceUsage();return{batchId:t,operations:e.length,successful:0,failed:e.length,errors:[c],executionTime:o,timestamp:new Date,processingDetails:{averageOperationTime:o/e.length,networkConditions:l,resourceUsage:{memoryUsed:h.memory,cpuUsage:h.cpu}}}}}async executeSyncOperation(e){try{const t=await this.analyzeOperationConflicts(e);return t.highRisk>0?(console.warn(`High conflict risk detected for operation ${e.id}, applying conflict resolution`),await this.executeWithConflictResolution(e,t)):await this.performSyncOperation(e)}catch(t){return console.error(`Sync operation failed for ${e.id}:`,t),!1}}async analyzeOperationConflicts(e){try{const t=await this.fetchCloudData(e),i=await this.fetchLocalData(e),s=await R.predictConflicts(i,t,e.entity,e.userId||"");let r=0,n=0,a=0;switch(s.riskLevel){case"critical":r=3,n=2;break;case"high":r=2,n=1;break;case"medium":n=2,a=1;break;case"low":a=1;break}return(await f.syncQueue.where("entityId").equals(e.entityId).filter(c=>Math.abs(c.timestamp.getTime()-e.timestamp.getTime())<5*60*1e3&&c.id!==e.id).toArray()).length>2&&r++,{highRisk:r,mediumRisk:n,lowRisk:a,recommendations:s.recommendations}}catch(t){return console.error("Failed to analyze operation conflicts:",t),{highRisk:0,mediumRisk:1,lowRisk:0,recommendations:["Unable to analyze conflicts"]}}}async executeWithConflictResolution(e,t){try{const i=await this.fetchCloudData(e),r={localData:await this.fetchLocalData(e),cloudData:i,entityType:e.entity,entityId:e.entityId,userId:e.userId||"",context:{networkInfo:{effectiveType:"4g"},deviceInfo:{deviceType:"unknown"}}},n=await R.resolveConflicts(r);return n.success?(n.conflicts.length>0&&console.log(`Successfully resolved ${n.conflicts.length} conflicts for operation ${e.id} using strategy: ${n.resolutionStrategy}`),await this.performSyncOperation({...e,data:n.resolvedData})):(console.warn(`Unable to auto-resolve conflicts for operation ${e.id}. Strategy: ${n.resolutionStrategy}, Confidence: ${n.confidence}`),n.userActionRequired&&await this.updateOperationStatus(e.id,"retrying","Awaiting user conflict resolution"),!1)}catch(i){return console.error(`Conflict resolution failed for operation ${e.id}:`,i),!1}}async performSyncOperation(e){switch(await new Promise(t=>setTimeout(t,Math.random()*200+100)),e.type){case"create":return await this.performCreateOperation(e);case"update":return await this.performUpdateOperation(e);case"delete":return await this.performDeleteOperation(e);default:return console.warn(`Unknown operation type: ${e.type}`),!1}}async fetchCloudData(e){return{id:e.entityId,updatedAt:new Date().toISOString(),version:Math.floor(Math.random()*100)}}async fetchLocalData(e){return{id:e.entityId,updatedAt:new Date().toISOString(),version:Math.floor(Math.random()*100),...e.data}}extractResolvedData(e,t,i){return{...t,resolvedAt:new Date().toISOString(),conflictCount:e.length}}async performCreateOperation(e){const t=e.priority==="high"?.95:.85;return Math.random()<t}async performUpdateOperation(e){const t=e.priority==="high"?.9:.8;return Math.random()<t}async performDeleteOperation(e){const t=e.priority==="high"?.85:.75;return Math.random()<t}async handleOperationFailure(e,t){const i=e.retryCount+1,s=this.queueStorage.get(e.id);if(s&&this.recordOperationAttempt(s,i,new Date,void 0,t),this.updatePerformanceMetrics(0,!1),i>=e.maxRetries){if(await this.updateOperationStatus(e.id,"failed",t),s){const r=this.operationHistory.get(e.id);r&&(r.finalStatus="failed",r.completedAt=new Date,r.errors.push(t))}}else{const r=this.retryDelays[Math.min(i-1,this.retryDelays.length-1)],n=new Date(Date.now()+r);await f.syncQueue.where("id").equals(e.id).modify({retryCount:i,status:"retrying",error:t,nextRetryTime:n}),s&&(s.retryCount=i,s.status="retrying",s.error=t,s.nextRetryTime=n,this.queueStorage.set(e.id,s)),setTimeout(async()=>{try{await f.syncQueue.where("id").equals(e.id).modify({status:"pending"}),s&&(s.status="pending",this.queueStorage.set(e.id,s)),this.notifyStatusChange()}catch(a){console.error("Failed to retry operation:",a)}},r)}}async validateDependencies(e){const t=await f.syncQueue.where("id").anyOf(e).and(i=>i.status==="pending"||i.status==="processing").count();if(t>0)throw new Error(`Cannot enqueue operation: ${t} dependencies are still pending`)}async canExecuteOperation(e){return!e.dependencies||e.dependencies.length===0?!0:(await f.syncQueue.where("id").anyOf(e.dependencies).toArray()).every(i=>i.status==="completed")}async getQueueStats(){const e=await f.syncQueue.toArray(),t={totalOperations:e.length,byStatus:{pending:0,processing:0,completed:0,failed:0,retrying:0},byPriority:{high:0,normal:0,low:0},byEntity:{card:0,folder:0,tag:0,image:0},averageWaitTime:0};e.forEach(r=>{t.byStatus[r.status]++,t.byPriority[r.priority]++,t.byEntity[r.entity]++});const i=e.filter(r=>r.status==="pending"||r.status==="retrying");if(i.length>0){const r=Date.now(),n=i.reduce((a,o)=>a+(r-new Date(o.timestamp).getTime()),0);t.averageWaitTime=n/i.length}const s=e.filter(r=>r.status==="pending").sort((r,n)=>new Date(r.timestamp).getTime()-new Date(n.timestamp).getTime())[0];return s&&(t.oldestOperation=new Date(s.timestamp)),t}async cleanupCompletedOperations(e=24*60*60*1e3){const t=new Date(Date.now()-e),i=await f.syncQueue.where("status").equals("completed").and(s=>new Date(s.timestamp)<t).delete();return this.notifyStatusChange(),i}async retryFailedOperations(){const e=await f.syncQueue.where("status").equals("failed").modify({status:"pending",retryCount:0,error:void 0});return this.notifyStatusChange(),e>0&&this.processNextBatch(),e}async getOperations(e){let t=f.syncQueue;return e?.status&&(t=t.where("status").equals(e.status)),e?.priority&&(t=t.where("priority").equals(e.priority)),e?.entity&&(t=t.where("entity").equals(e.entity)),e?.userId&&(t=t.where("userId").equals(e.userId)),e?.offset&&(t=t.offset(e.offset)),e?.limit&&(t=t.limit(e.limit)),(await t.toArray()).map(s=>this.convertSyncOperationToQueueOperation(s))}setEventListeners(e){this.listeners={...this.listeners,...e}}notifyStatusChange(){this.listeners.onStatusChange&&this.getQueueStats().then(e=>{this.listeners.onStatusChange(e)}).catch(console.error)}initializeQueue(){this.checkRetryOperations(),this.recoverQueueState().catch(console.error)}startQueueProcessor(){this.processingInterval=setInterval(()=>{!this.isProcessing&&!this.circuitBreakerOpen&&this.processNextBatch()},5e3),setInterval(()=>{this.optimizeQueueProcessing().catch(console.error)},12e4),this.setupNetworkListeners(),this.setupResourceMonitoring()}async checkRetryOperations(){try{const e=await f.syncQueue.where("status").equals("retrying").toArray();for(const t of e)await f.syncQueue.where("id").equals(t.id).modify({status:"pending"});e.length>0&&(this.notifyStatusChange(),this.processNextBatch())}catch(e){console.error("Failed to check retry operations:",e)}}stop(){this.processingInterval&&(clearInterval(this.processingInterval),this.processingInterval=void 0)}pause(){this.isProcessing=!0}resume(){this.isProcessing=!1,this.processNextBatch()}convertSyncOperationToQueueOperation(e){return{id:e.id,type:e.type,entity:e.entity,entityId:e.entityId,userId:e.userId,data:e.data,priority:e.priority,timestamp:new Date(e.timestamp),retryCount:e.retryCount,maxRetries:e.maxRetries,status:e.status,error:e.error,processingTime:e.processingTime,nextRetryTime:e.nextRetryTime,operationMetadata:e.operationMetadata}}initializePersistence(){setInterval(()=>{this.persistQueueState().catch(console.error)},this.persistenceInterval),typeof window<"u"&&window.addEventListener("beforeunload",()=>{this.persistQueueState().catch(console.error)})}initializeCircuitBreaker(){setInterval(()=>{this.checkCircuitBreaker().catch(console.error)},6e4)}initializePerformanceMonitoring(){setInterval(()=>{this.resetPerformanceMetrics()},3e5)}async getCurrentNetworkInfo(){try{const e=await v.getNetworkStatus();return{type:e.type,effectiveType:e.effectiveType,downlink:e.downlink,rtt:e.rtt}}catch(e){return console.warn("Failed to get network info:",e),{type:"unknown"}}}getCurrentResourceUsage(){try{return typeof performance<"u"&&"memory"in performance?{memory:performance.memory.usedJSHeapSize||0,cpu:0}:{memory:0,cpu:0}}catch{return{memory:0,cpu:0}}}async validateOperation(e){if(!e.type||!e.entity||!e.entityId)throw new Error("Invalid operation: missing required fields");if(JSON.stringify(e.data).length>1024*1024)throw new Error("Operation data too large");if(e.retryCount>e.maxRetries)throw new Error("Operation retry count exceeds maximum")}initializeOperationHistory(e){const t={operationId:e.id,attempts:[],finalStatus:e.status,totalProcessingTime:0,createdAt:e.timestamp,errors:[],successRate:0};this.operationHistory.set(e.id,t)}async handleError(e,t,i){console.error(`Error in ${t}:`,e),this.recentErrors.push({timestamp:Date.now(),error:e.message,operationId:i||"unknown"});const s=Date.now()-5*60*1e3;this.recentErrors=this.recentErrors.filter(r=>r.timestamp>s),this.recentErrors.length>=this.errorThreshold&&await this.openCircuitBreaker(),this.listeners.onQueueError&&this.listeners.onQueueError(e)}async handleBatchError(e,t,i){console.error(`Error in ${t}:`,e),i.forEach(s=>{this.recentErrors.push({timestamp:Date.now(),error:e.message,operationId:s.id})}),this.recentErrors.length>=this.errorThreshold&&await this.openCircuitBreaker(),this.listeners.onQueueError&&this.listeners.onQueueError(e)}async openCircuitBreaker(){this.circuitBreakerOpen||(this.circuitBreakerOpen=!0,console.warn("Circuit breaker opened - queue processing suspended"),this.listeners.onCircuitBreakerChange&&this.listeners.onCircuitBreakerChange(!0),setTimeout(()=>{this.closeCircuitBreaker().catch(console.error)},this.circuitBreakerTimeout))}async closeCircuitBreaker(){this.circuitBreakerOpen&&(this.circuitBreakerOpen=!1,console.log("Circuit breaker closed - queue processing resumed"),this.listeners.onCircuitBreakerChange&&this.listeners.onCircuitBreakerChange(!1),this.processNextBatch())}async checkCircuitBreaker(){this.recentErrors.filter(t=>Date.now()-t.timestamp<3e5).length<this.errorThreshold&&this.circuitBreakerOpen&&await this.closeCircuitBreaker()}async persistQueueState(){try{const e=Date.now();if(e-this.lastPersistenceTime<this.persistenceInterval)return;const t={queueOperations:Array.from(this.queueStorage.values()),operationHistory:Array.from(this.operationHistory.values()),performanceMetrics:this.performanceMetrics,timestamp:e};localStorage.setItem("syncQueueState",JSON.stringify(t)),this.lastPersistenceTime=e,await this.cleanupOldHistory()}catch(e){console.error("Failed to persist queue state:",e)}}async recoverQueueState(){try{const e=localStorage.getItem("syncQueueState");if(!e)return;const t=JSON.parse(e);t.queueOperations.forEach(i=>{this.queueStorage.set(i.id,i)}),t.operationHistory.forEach(i=>{this.operationHistory.set(i.operationId,i)}),this.performanceMetrics=t.performanceMetrics,this.recoveryMode=!0,console.log("Queue state recovered from persistence"),this.listeners.onRecoveryModeChange&&this.listeners.onRecoveryModeChange(!0),setTimeout(()=>{this.recoveryMode=!1,this.listeners.onRecoveryModeChange&&this.listeners.onRecoveryModeChange(!1),this.processNextBatch()},5e3)}catch(e){console.error("Failed to recover queue state:",e)}}async cleanupOldHistory(){const e=Date.now()-6048e5;for(const[t,i]of this.operationHistory.entries())i.createdAt&&typeof i.createdAt.getTime=="function"&&i.createdAt.getTime()<e&&this.operationHistory.delete(t)}resetPerformanceMetrics(){({...this.performanceMetrics},this.performanceMetrics={totalProcessed:0,totalFailed:0,averageProcessingTime:0,lastResetTime:Date.now()}),this.listeners.onPerformanceMetricsUpdate&&this.listeners.onPerformanceMetricsUpdate(this.performanceMetrics)}updatePerformanceMetrics(e,t){this.performanceMetrics.totalProcessed++,t||this.performanceMetrics.totalFailed++;const i=this.performanceMetrics.totalProcessed,s=this.performanceMetrics.averageProcessingTime;this.performanceMetrics.averageProcessingTime=(s*(i-1)+e)/i,this.listeners.onPerformanceMetricsUpdate&&this.listeners.onPerformanceMetricsUpdate(this.performanceMetrics)}setupNetworkListeners(){const e=async t=>{t.isOnline&&!this.isProcessing&&!this.circuitBreakerOpen&&(console.log("Network restored, processing queue"),this.processNextBatch()),await this.adjustQueueForNetworkConditions(t)};typeof window<"u"&&window.addEventListener&&(window.addEventListener("online",()=>{e({isOnline:!0}).catch(console.error)}),window.addEventListener("offline",()=>{e({isOnline:!1}).catch(console.error)}));try{v.addListener("statusChange",e)}catch(t){console.warn("Failed to setup network manager listeners:",t)}}setupResourceMonitoring(){setInterval(()=>{this.checkResourceUsage().catch(console.error)},3e4),typeof document<"u"&&document.addEventListener&&document.addEventListener("visibilitychange",()=>{document.visibilityState==="visible"&&!this.isProcessing&&this.processNextBatch()})}async checkResourceUsage(){try{const e=this.getCurrentResourceUsage();e.memory>100*1024*1024&&(console.warn("High memory usage detected:",e.memory),await this.optimizeMemoryUsage());const t=await this.getQueueStats();t.totalOperations>500&&(console.warn("Large queue detected:",t.totalOperations),await this.optimizeQueueProcessing())}catch(e){console.error("Failed to check resource usage:",e)}}async optimizeMemoryUsage(){try{await this.cleanupOldHistory();const e=await this.cleanupCompletedOperations(36e5);e>0&&console.log(`Cleaned up ${e} completed operations for memory optimization`),typeof global.gc=="function"&&global.gc()}catch(e){console.error("Failed to optimize memory usage:",e)}}async adjustQueueForNetworkConditions(e){try{if(!e.isOnline){console.log("Offline mode activated");return}e.effectiveType==="slow-2g"||e.effectiveType==="2g"?(this.batchSize=Math.max(3,Math.floor(this.batchSize*.5)),this.retryDelays=this.retryDelays.map(t=>t*2),console.log("Adjusted queue for slow network conditions")):(e.effectiveType==="4g"||e.effectiveType==="wifi")&&(this.batchSize=10,this.retryDelays=[1e3,2e3,5e3,1e4,3e4,6e4,12e4],console.log("Restored normal queue settings for good network conditions"))}catch(t){console.error("Failed to adjust queue for network conditions:",t)}}async optimizeQueueProcessing(){try{const e=await this.getQueueStats();this.adjustProcessingStrategy(e),this.adjustBatchSize(e),await this.rebalancePriorities(e),await this.cleanupExpiredOperations()}catch(e){console.error("Failed to optimize queue processing:",e)}}adjustProcessingStrategy(e){const{totalOperations:t,byStatus:i,byPriority:s}=e;t>1e3?(this.batchSize=5,this.maxConcurrentBatches=2,console.log("Queue under high load, adjusting strategy: batch=5, concurrent=2")):t>500?(this.batchSize=8,this.maxConcurrentBatches=3,console.log("Queue under medium load, adjusting strategy: batch=8, concurrent=3")):(this.batchSize=15,this.maxConcurrentBatches=5,console.log("Queue under normal load, adjusting strategy: batch=15, concurrent=5"));const r=i.failed/t;r>.3?(this.retryDelays=[2e3,5e3,15e3,3e4,6e4],console.log("High failure rate detected, increased retry delays")):r<.1&&(this.retryDelays=[1e3,2e3,5e3,1e4,3e4],console.log("Normal failure rate, restored retry delays"))}adjustBatchSize(e){const{byPriority:t,totalOperations:i}=e,s=t.high/i;s>.3&&(this.batchSize=Math.max(3,Math.floor(this.batchSize*.7)),console.log(`High priority ratio (${(s*100).toFixed(1)}%), reduced batch size to ${this.batchSize}`));const r=byEntity.card/i;r>.7&&(this.batchSize=Math.min(20,Math.floor(this.batchSize*1.2)),console.log(`Card operation ratio (${(r*100).toFixed(1)}%), increased batch size to ${this.batchSize}`))}async rebalancePriorities(e){const{byStatus:t,byPriority:i}=e,s=await f.syncQueue.where("priority").equals("high").filter(n=>Date.now()-n.timestamp.getTime()>5*60*1e3).toArray();s.length>0&&(await f.syncQueue.where("id").anyOf(s.map(n=>n.id)).modify({priority:"high"}),console.log(`Escalated ${s.length} old high-priority operations`));const r=await f.syncQueue.where("priority").equals("normal").filter(n=>Date.now()-n.timestamp.getTime()>10*60*1e3).toArray();r.length>0&&(await f.syncQueue.where("id").anyOf(r.map(n=>n.id)).modify({priority:"high"}),console.log(`Escalated ${r.length} old normal-priority operations`))}async cleanupExpiredOperations(){const e=Date.now()-864e5,t=await f.syncQueue.where("timestamp").below(e).filter(i=>i.status==="failed").toArray();if(t.length>0){for(const i of t)await f.syncQueue.delete(i.id);console.log(`Cleaned up ${t.length} expired failed operations`)}}async predictAndPreventConflicts(e){const t=[],i=[],s={highRisk:0,mediumRisk:0,lowRisk:0};for(const r of e){const n=await this.assessConflictRisk(r);n==="high"?(i.push(r),s.highRisk++):n==="medium"?(i.push(r),s.mediumRisk++):(t.push(r),s.lowRisk++)}return{safeOperations:t,riskyOperations:i,conflictPrediction:s}}async assessConflictRisk(e){try{return(await f.syncQueue.where("entityId").equals(e.entityId).filter(n=>Math.abs(n.timestamp.getTime()-e.timestamp.getTime())<3e5&&n.id!==e.id).toArray()).length>2||(await f.syncQueue.where("userId").equals(e.userId).filter(n=>Date.now()-n.timestamp.getTime()<60*1e3).toArray()).length>10?"high":(await f.syncQueue.where("entity").equals(e.entity).filter(n=>n.status==="failed").toArray()).length/Math.max(1,await f.syncQueue.count())>.3?"medium":"low"}catch(t){return console.error("Failed to assess conflict risk:",t),"medium"}}async getQueuePerformanceMetrics(){try{const e=await this.getQueueStats(),t=await f.syncQueue.where("status").equals("completed").filter(p=>Date.now()-p.timestamp.getTime()<60*1e3).toArray(),i=t.length,s=await Promise.all(t.map(async p=>(await f.syncQueue.get(p.id))?.processingTime||0)),r=s.length>0?s.reduce((p,w)=>p+w,0)/s.length:0,n=await f.syncQueue.filter(p=>Date.now()-p.timestamp.getTime()<60*1e3).toArray(),a=n.length>0?t.length/n.length:1,o=this.calculateQueueEfficiency(e,i),c=await this.calculateConflictResolutionRate(),l=this.calculateResourceUtilization(e,i),h=this.analyzeBottlenecks(e,i,r),g=await this.generatePredictiveInsights(e,i);return{throughput:i,averageProcessingTime:r,successRate:a,queueEfficiency:o,bottleneckAnalysis:h,conflictResolutionRate:c,resourceUtilization:l,predictiveInsights:g}}catch(e){return console.error("Failed to get queue performance metrics:",e),{throughput:0,averageProcessingTime:0,successRate:0,queueEfficiency:0,bottleneckAnalysis:["Unable to analyze performance"],conflictResolutionRate:0,resourceUtilization:0,predictiveInsights:{predictedLoad:0,recommendedActions:["Enable performance monitoring"],riskAssessment:"medium"}}}}async calculateConflictResolutionRate(){try{const e=await f.syncQueue.filter(i=>Date.now()-i.timestamp.getTime()<18e5).toArray();return e.length===0?1:e.filter(i=>i.status==="completed"&&i.error===null).length/e.length}catch(e){return console.error("Failed to calculate conflict resolution rate:",e),0}}calculateResourceUtilization(e,t){let i=.3;return e.totalOperations>500?i+=.4:e.totalOperations>200?i+=.2:e.totalOperations>50&&(i+=.1),t>15?i+=.2:t>8&&(i+=.1),e.byStatus.failed/Math.max(1,e.totalOperations)>.2&&(i-=.1),Math.max(0,Math.min(1,i))}async generatePredictiveInsights(e,t){const i=[];let s="low";const r=await this.predictFutureLoad(e,t);return r>1e3?(i.push("Consider increasing batch size and concurrency"),s="high"):r>500&&(i.push("Monitor queue growth closely"),i.push("Consider enabling aggressive cleanup"),s="medium"),t<5&&(i.push("Investigate low throughput causes"),i.push("Check network connectivity")),e.byStatus.failed/Math.max(1,e.totalOperations)>.15&&(i.push("Review and optimize conflict resolution strategies"),i.push("Consider reducing retry delays for failed operations")),e.oldestOperation&&Date.now()-e.oldestOperation.getTime()>30*60*1e3&&(i.push("Process aged operations urgently"),i.push("Consider priority escalation")),{predictedLoad:r,recommendedActions:i,riskAssessment:s}}async predictFutureLoad(e,t){try{const i=new Date(Date.now()-36e5),s=await f.syncQueue.where("timestamp").above(i).toArray();if(s.length===0)return t*2;const r=this.calculateGrowthRate(s),n=e.totalOperations*(1+r);return Math.max(t*2,n)}catch(i){return console.error("Failed to predict future load:",i),t*2}}calculateGrowthRate(e){if(e.length<2)return .1;const t=new Map;e.forEach(o=>{const c=Math.floor(o.timestamp.getTime()/6e5);t.set(c,(t.get(c)||0)+1)});const i=Array.from(t.keys()).sort();if(i.length<2)return .1;const s=i.slice(0,Math.floor(i.length/2)),r=i.slice(Math.floor(i.length/2)),n=s.reduce((o,c)=>o+(t.get(c)||0),0)/s.length,a=r.reduce((o,c)=>o+(t.get(c)||0),0)/r.length;return n===0?.1:Math.max(-.5,Math.min(2,(a-n)/n))}calculateQueueEfficiency(e,t){const{totalOperations:i,byStatus:s}=e;let r=.5;i<100?r+=.3:i<500?r+=.2:i<1e3&&(r+=.1);const n=s.failed/Math.max(1,i);return r-=n*.5,t>20?r+=.2:t>10&&(r+=.1),Math.max(0,Math.min(1,r))}analyzeBottlenecks(e,t,i){const s=[];return e.totalOperations>1e3&&s.push("Queue backlog too large"),t<5&&s.push("Low throughput detected"),i>5e3&&s.push("High processing time"),e.byStatus.failed/Math.max(1,e.totalOperations)>.2&&s.push("High failure rate"),s.length===0&&s.push("No significant bottlenecks detected"),s}async getOperationHistory(e){return this.operationHistory.get(e)}async getAllOperationHistory(e){let t=Array.from(this.operationHistory.values());return e?.status&&(t=t.filter(i=>i.finalStatus===e.status)),e?.entityType&&(t=t.filter(i=>this.queueStorage.get(i.operationId)?.entity===e.entityType)),e?.timeRange&&(t=t.filter(i=>i.createdAt>=e.timeRange.start&&i.createdAt<=e.timeRange.end)),e?.limit&&(t=t.slice(0,e.limit)),t.sort((i,s)=>s.createdAt.getTime()-i.createdAt.getTime())}async getPerformanceMetrics(){return{...this.performanceMetrics}}async getQueueHealth(){const e=await this.getQueueStats(),t=await v.getNetworkStatus(),i=this.getCurrentResourceUsage(),s=[],r=[];let n="healthy";e.totalOperations>1e3?(n="critical",s.push("Queue backlog too large"),r.push("Consider increasing processing capacity")):e.totalOperations>500&&(n="warning",s.push("Queue backlog growing"),r.push("Monitor queue growth"));const a=e.byStatus.failed/Math.max(1,e.totalOperations);return a>.3?(n="critical",s.push("High failure rate detected"),r.push("Review error handling and retry logic")):a>.1&&(n="warning",s.push("Elevated failure rate"),r.push("Monitor error patterns")),this.circuitBreakerOpen&&(n="critical",s.push("Circuit breaker is open"),r.push("Wait for circuit breaker to reset")),t.isOnline||(n="warning",s.push("Network is offline"),r.push("Queue operations will be processed when network is restored")),i.memory>150*1024*1024&&(n=n==="critical"?"critical":"warning",s.push("High memory usage"),r.push("Consider memory optimization")),{status:n,issues:s,recommendations:r,circuitBreaker:this.circuitBreakerOpen,recoveryMode:this.recoveryMode,networkStatus:t,resourceUsage:i}}async triggerOptimization(){await this.optimizeQueueProcessing(),await this.optimizeMemoryUsage(),console.log("Queue optimization completed")}async resetQueue(e){try{if(e?.clearCompleted){const t=await this.cleanupCompletedOperations(0);console.log(`Cleared ${t} completed operations`)}e?.clearHistory&&(this.operationHistory.clear(),console.log("Cleared operation history")),e?.resetMetrics&&(this.resetPerformanceMetrics(),console.log("Reset performance metrics")),this.circuitBreakerOpen&&await this.closeCircuitBreaker(),console.log("Queue reset completed")}catch(t){throw console.error("Failed to reset queue:",t),t}}emergencyStop(){this.isProcessing=!0,this.processingInterval&&(clearInterval(this.processingInterval),this.processingInterval=void 0),console.warn("Queue processing emergency stopped")}resumeProcessing(){this.isProcessing=!1,this.startQueueProcessor(),console.log("Queue processing resumed")}}const C=new he;class fe{listeners=[];currentState={user:null,session:null,loading:!0,error:null};authSubscription=null;constructor(){this.initialize()}async initialize(){try{const{data:{session:e},error:t}=await y.auth.getSession();if(t){this.updateState({error:t.message,loading:!1});return}if(e?.user){const i=await this.fetchUserProfile(e.user.id);this.updateState({user:i,session:e,loading:!1,error:null})}else this.updateState({loading:!1});if(y&&y.auth)try{const{data:{subscription:i}}=y.auth.onAuthStateChange(async(s,r)=>{if(console.log("Auth state changed:",s,r?.user?.id),s==="SIGNED_OUT"){try{const{unifiedSyncService:n}=await F(async()=>{const{unifiedSyncService:a}=await Promise.resolve().then(()=>Q);return{unifiedSyncService:a}},void 0);await n.clearHistory()}catch(n){console.warn("Failed to clear sync history on signout:",n)}this.updateState({user:null,session:null,loading:!1,error:null})}else if(r?.user){const n=await this.fetchUserProfile(r.user.id);if(this.updateState({user:n,session:r,loading:!1,error:null}),s==="SIGNED_IN")try{const{unifiedSyncService:a}=await F(async()=>{const{unifiedSyncService:o}=await Promise.resolve().then(()=>Q);return{unifiedSyncService:o}},void 0);await a.performFullSync()}catch(a){console.warn("Failed to perform full sync after signin:",a)}}else this.updateState({user:null,session:null,loading:!1,error:null})});this.authSubscription=i}catch(i){console.warn("Failed to setup auth state change listener:",i)}else console.warn("Supabase auth not available, skipping auth state change listener")}catch(e){console.error("Auth initialization failed:",e),this.updateState({error:e instanceof Error?e.message:"Authentication failed",loading:!1})}}async fetchUserProfile(e){try{await new Promise(s=>setTimeout(s,100));const{data:t,error:i}=await y.from("users").select("*").eq("id",e).single();return i?(console.error("Failed to fetch user profile:",i),null):t}catch(t){return console.error("Error fetching user profile:",t),null}}updateState(e){this.currentState={...this.currentState,...e},this.listeners.forEach(t=>t(this.currentState))}onAuthStateChange(e){return this.listeners.push(e),e(this.currentState),()=>{const t=this.listeners.indexOf(e);t>-1&&this.listeners.splice(t,1)}}getCurrentState(){return this.currentState}async signUpWithEmail(e,t,i){try{this.updateState({loading:!0,error:null});const{data:s,error:r}=await y.auth.signUp({email:e,password:t,options:{data:{name:i?.name||e.split("@")[0],full_name:i?.name||e.split("@")[0]}}});return r?(this.updateState({error:r.message,loading:!1}),{error:r}):(this.updateState({loading:!1,error:null}),{error:null})}catch(s){const r=s instanceof Error?s.message:"Registration failed";return this.updateState({error:r,loading:!1}),{error:s}}}async signInWithEmail(e,t){try{this.updateState({loading:!0,error:null});const{error:i}=await y.auth.signInWithPassword({email:e,password:t});return i?(this.updateState({error:i.message,loading:!1}),{error:i}):{error:null}}catch(i){const s=i instanceof Error?i.message:"Login failed";return this.updateState({error:s,loading:!1}),{error:i}}}async resetPassword(e){try{this.updateState({loading:!0,error:null});const{error:t}=await y.auth.resetPasswordForEmail(e,{redirectTo:`${window.location.origin}/auth/reset-password`});return t?(this.updateState({error:t.message,loading:!1}),{error:t}):(this.updateState({loading:!1,error:null}),{error:null})}catch(t){const i=t instanceof Error?t.message:"Password reset failed";return this.updateState({error:i,loading:!1}),{error:t}}}async signInWithGitHub(){try{this.updateState({loading:!0,error:null});const{error:e}=await y.auth.signInWithOAuth({provider:"github",options:{redirectTo:`${window.location.origin}`}});return e?(this.updateState({error:e.message,loading:!1}),{error:e}):{error:null}}catch(e){const t=e instanceof Error?e.message:"Login failed";return this.updateState({error:t,loading:!1}),{error:e}}}async signOut(){try{this.updateState({loading:!0,error:null});const{error:e}=await y.auth.signOut();return e?(this.updateState({error:e.message,loading:!1}),{error:e}):(this.updateState({user:null,session:null,loading:!1,error:null}),{error:null})}catch(e){const t=e instanceof Error?e.message:"Logout failed";return this.updateState({error:t,loading:!1}),{error:e}}}async upsertUserProfile(e){try{if(!this.currentState.session?.user.id)return console.error("No authenticated user found"),null;const{data:t,error:i}=await y.from("users").upsert({id:this.currentState.session.user.id,...e,updated_at:new Date().toISOString()}).select().single();return i?(console.error("Failed to upsert user profile:",i),null):t}catch(t){return console.error("Error upserting user profile:",t),null}}isAuthenticated(){return!!this.currentState.user&&!!this.currentState.session}getCurrentUser(){return this.currentState.user}getCurrentSession(){return this.currentState.session}cleanup(){this.authSubscription&&(this.authSubscription.unsubscribe(),this.authSubscription=null),this.listeners=[]}}const ye=new fe;class ge{static cachedUserId=null;static getCurrentUserId(){if(!this.cachedUserId){const e=ye.getCurrentUser();this.cachedUserId=e?.id||null}return this.cachedUserId}static clearUserIdCache(){this.cachedUserId=null}static toDbCard(e,t){const i=new Date,s=t||this.getCurrentUserId();return{id:e.id||crypto.randomUUID(),folderId:e.folderId,frontContent:e.frontContent||{title:"",text:"",tags:[],images:[],lastModified:i},backContent:e.backContent||{title:"",text:"",tags:[],images:[],lastModified:i},isFlipped:e.isFlipped||!1,style:e.style||{type:"solid",backgroundColor:"#ffffff",textColor:"#000000"},userId:s,syncVersion:e.syncVersion||1,lastSyncAt:e.lastSyncAt,pendingSync:e.pendingSync??!0,updatedAt:e.updatedAt||i,searchVector:this.generateSearchVector(e),thumbnailUrl:e.thumbnailUrl}}static fromDbCard(e){const{userId:t,syncVersion:i,lastSyncAt:s,pendingSync:r,searchVector:n,thumbnailUrl:a,...o}=e;return{...o,id:o.id||"",createdAt:new Date(o.createdAt),updatedAt:new Date(o.updatedAt),frontContent:{...o.frontContent,lastModified:new Date(o.frontContent.lastModified)},backContent:{...o.backContent,lastModified:new Date(o.backContent.lastModified)}}}static fromDbCards(e){return e.map(t=>this.fromDbCard(t))}static toDbFolder(e,t){const i=new Date,s=t||this.getCurrentUserId();return{id:e.id||crypto.randomUUID(),name:e.name||"",parentId:e.parentId,description:e.description||"",color:e.color||"#6366f1",icon:e.icon||"folder",order:e.order||0,isExpanded:e.isExpanded??!0,cardIds:e.cardIds||[],createdAt:e.createdAt||i,userId:s,syncVersion:e.syncVersion||1,lastSyncAt:e.lastSyncAt,pendingSync:e.pendingSync??!0,updatedAt:e.updatedAt||i,fullPath:this.generateFullPath(e),depth:this.calculateFolderDepth(e)}}static fromDbFolder(e){const{userId:t,syncVersion:i,lastSyncAt:s,pendingSync:r,fullPath:n,depth:a,...o}=e;return{...o,id:o.id||"",cardIds:o.cardIds||[],createdAt:new Date(o.createdAt),updatedAt:new Date(o.updatedAt)}}static toDbTag(e,t){const i=new Date,s=t||this.getCurrentUserId();return{id:e.id||crypto.randomUUID(),name:e.name||"",color:e.color||"#6366f1",description:e.description||"",count:e.count||0,createdAt:e.createdAt||i,userId:s,syncVersion:e.syncVersion||1,lastSyncAt:e.lastSyncAt,pendingSync:e.pendingSync??!0,updatedAt:e.updatedAt||i}}static fromDbTag(e){const{userId:t,syncVersion:i,lastSyncAt:s,pendingSync:r,count:n,...a}=e;return{...a,id:a.id||"",createdAt:new Date(a.createdAt),updatedAt:new Date(a.updatedAt)}}static toDbImage(e,t,i){const s=new Date,r=i||this.getCurrentUserId();return{id:e.id||crypto.randomUUID(),cardId:t,userId:r,fileName:e.fileName||"",filePath:e.url||"",cloudUrl:e.cloudUrl,thumbnailPath:e.thumbnailUrl,metadata:{originalName:e.fileName||e.alt||"",size:e.size||0,width:e.width||0,height:e.height||0,format:e.format||"jpg",compressed:e.compressed??!1,quality:e.quality},storageMode:e.storageMode||"indexeddb",createdAt:e.createdAt||s,updatedAt:e.updatedAt||s,syncVersion:e.syncVersion||1,lastSyncAt:e.lastSyncAt,pendingSync:e.pendingSync??!0}}static fromDbImage(e){const{userId:t,syncVersion:i,lastSyncAt:s,pendingSync:r,fileName:n,filePath:a,thumbnailPath:o,storageMode:c,metadata:l,...h}=e;return{...h,id:h.id||"",url:a,thumbnailUrl:o,alt:l.originalName,width:l.width,height:l.height,aspectRatio:l.width>0&&l.height>0?l.width/l.height:1,size:l.size,format:l.format,compressed:l.compressed,quality:l.quality,storageMode:c,createdAt:new Date(h.createdAt),updatedAt:new Date(h.updatedAt)}}static fromLegacySyncOperation(e){return{id:e.id,type:e.type,entity:e.table.replace("s",""),entityId:e.localId,data:e.data,timestamp:e.timestamp,retryCount:e.retryCount,maxRetries:e.maxRetries,error:e.error,priority:"normal"}}static toLegacySyncOperation(e){return{id:e.id,type:e.type,table:`${e.entity}s`,data:e.data,localId:e.entityId,timestamp:e.timestamp,retryCount:e.retryCount,maxRetries:e.maxRetries,error:e.error}}static generateSearchVector(e){return[e.frontContent?.title||"",e.frontContent?.text||"",e.backContent?.title||"",e.backContent?.text||"",...e.frontContent?.tags||[],...e.backContent?.tags||[]].join(" ").toLowerCase().replace(/[^\w\s\u4e00-\u9fff]/g," ").replace(/\s+/g," ").trim()}static generateFullPath(e){return e.name||""}static calculateFolderDepth(e){return e.parentId?1:0}static fromCloudCard(e){return{id:e.id,folderId:e.folder_id,frontContent:{title:e.front_content?.title||"",text:e.front_content?.text||"",tags:e.front_content?.tags||[],images:e.front_content?.images||[],lastModified:new Date(e.updated_at)},backContent:{title:e.back_content?.title||"",text:e.back_content?.text||"",tags:e.back_content?.tags||[],images:e.back_content?.images||[],lastModified:new Date(e.updated_at)},style:e.style||{type:"solid",backgroundColor:"#ffffff",textColor:"#000000"},userId:e.user_id,syncVersion:e.sync_version||1,lastSyncAt:new Date(e.updated_at),pendingSync:!1,createdAt:new Date(e.created_at),updatedAt:new Date(e.updated_at),searchVector:this.generateSearchVectorFromCloud(e),thumbnailUrl:e.thumbnail_url}}static fromCloudFolder(e){return{id:e.id,name:e.name,parentId:e.parent_id,description:e.description||"",color:e.color||"#6366f1",icon:e.icon||"folder",order:e.order_index||0,isExpanded:e.is_expanded??!0,cardIds:e.card_ids||[],userId:e.user_id,syncVersion:e.sync_version||1,lastSyncAt:new Date(e.updated_at),pendingSync:!1,createdAt:new Date(e.created_at),updatedAt:new Date(e.updated_at),fullPath:e.full_path||e.name,depth:e.depth||0}}static fromCloudTag(e){return{id:e.id,name:e.name,color:e.color||"#6366f1",description:e.description||"",count:e.count||0,userId:e.user_id,syncVersion:e.sync_version||1,lastSyncAt:new Date(e.updated_at),pendingSync:!1,createdAt:new Date(e.created_at),updatedAt:new Date(e.updated_at)}}static toCloudCard(e){return{id:e.id,folder_id:e.folderId,front_content:{title:e.frontContent.title,text:e.frontContent.text,tags:e.frontContent.tags,images:e.frontContent.images},back_content:{title:e.backContent.title,text:e.backContent.text,tags:e.backContent.tags,images:e.backContent.images},style:e.style,user_id:e.userId,sync_version:e.syncVersion,updated_at:e.updatedAt.toISOString(),created_at:e.createdAt.toISOString(),thumbnail_url:e.thumbnailUrl}}static toCloudFolder(e){return{id:e.id,name:e.name,parent_id:e.parentId,description:e.description||"",color:e.color,icon:e.icon,order_index:e.order||0,card_ids:e.cardIds||[],user_id:e.userId,sync_version:e.syncVersion,updated_at:e.updatedAt.toISOString(),created_at:e.createdAt.toISOString(),full_path:e.fullPath||e.name,depth:e.depth||0,is_expanded:e.isExpanded??!0}}static toCloudTag(e){return{id:e.id,name:e.name,color:e.color,description:e.description,count:e.count,user_id:e.userId,sync_version:e.syncVersion,updated_at:e.updatedAt.toISOString(),created_at:e.createdAt.toISOString()}}static generateSearchVectorFromCloud(e){return[e.front_content?.title||"",e.front_content?.text||"",e.back_content?.title||"",e.back_content?.text||"",...e.front_content?.tags||[],...e.back_content?.tags||[]].join(" ").toLowerCase().replace(/[^\w\s\u4e00-\u9fff]/g," ").replace(/\s+/g," ").trim()}static validateCardData(e){const t=[];e.frontContent?.title?.trim()||t.push("卡片正面标题不能为空"),e.backContent?.title?.trim()||t.push("卡片背面标题不能为空"),e.style&&!["solid","gradient","glass"].includes(e.style.type)&&t.push("无效的卡片样式类型");const i=s=>{s.forEach((r,n)=>{r.url||t.push(`第${n+1}张图片URL不能为空`),(r.width<=0||r.height<=0)&&t.push(`第${n+1}张图片尺寸无效`)})};return e.frontContent?.images&&i(e.frontContent.images),e.backContent?.images&&i(e.backContent.images),{isValid:t.length===0,errors:t}}static validateFolderData(e){const t=[];return e.name?.trim()||t.push("文件夹名称不能为空"),e.name&&e.name.length>50&&t.push("文件夹名称不能超过50个字符"),e.color&&!/^#[0-9A-Fa-f]{6}$/.test(e.color)&&t.push("文件夹颜色格式无效"),{isValid:t.length===0,errors:t}}static validateTagData(e){const t=[];return e.name?.trim()||t.push("标签名称不能为空"),e.name&&e.name.length>30&&t.push("标签名称不能超过30个字符"),e.color&&!/^#[0-9A-Fa-f]{6}$/.test(e.color)&&t.push("标签颜色格式无效"),{isValid:t.length===0,errors:t}}static batchToDbCards(e,t){return e.map(i=>this.toDbCard(i,t))}static batchToDbFolders(e,t){return e.map(i=>this.toDbFolder(i,t))}static batchToDbTags(e,t){return e.map(i=>this.toDbTag(i,t))}static sanitizeCardData(e){const t={...e};return t.frontContent&&(t.frontContent={...t.frontContent,title:(t.frontContent.title||"").trim(),text:(t.frontContent.text||"").trim(),tags:(t.frontContent.tags||[]).map(i=>i.trim()).filter(Boolean)}),t.backContent&&(t.backContent={...t.backContent,title:(t.backContent.title||"").trim(),text:(t.backContent.text||"").trim(),tags:(t.backContent.tags||[]).map(i=>i.trim()).filter(Boolean)}),t.style&&(t.style={...t.style,backgroundColor:t.style.backgroundColor||"#ffffff",textColor:t.style.textColor||"#000000"}),t}static optimizeImageData(e){return{...e,format:e.format||"jpg",compressed:e.compressed??!0,quality:Math.min(Math.max(e.quality||.8,.1),1)}}static conversionCache=new Map;static CACHE_TTL=5*60*1e3;static cachedConvert(e,t,i){const s=`${e}:${JSON.stringify(t)}`,r=this.conversionCache.get(s);if(r&&Date.now()-r.timestamp<this.CACHE_TTL)return r.data;const n=i(t);return this.conversionCache.set(s,{data:n,timestamp:Date.now()}),n}static clearConversionCache(){this.conversionCache.clear()}static startCacheCleanup(){setInterval(()=>{const e=Date.now();for(const[t,i]of this.conversionCache.entries())e-i.timestamp>this.CACHE_TTL&&this.conversionCache.delete(t)},this.CACHE_TTL)}}const m=new ge;class pe{validationCache=new Map;repairHistory=[];isProcessing=!1;constructor(){this.initializeValidator()}initializeValidator(){setInterval(()=>this.cleanupValidationCache(),60*60*1e3)}async validateConsistency(e="relaxed"){if(this.isProcessing)throw new Error("Validation already in progress");this.isProcessing=!0;const t=performance.now();try{const i=`consistency_${e}_${Date.now()}`,s=this.getRecentValidationReport(e);if(s)return s;console.log(`Starting consistency validation (level: ${e})`);const r={timestamp:new Date,level:e,overallStatus:"valid",summary:{totalChecks:0,passedChecks:0,failedChecks:0,warnings:0,errors:0,critical:0},entityCounts:{local:{cards:0,folders:0,tags:0,images:0},cloud:{cards:0,folders:0,tags:0,images:0}},issues:[],confidence:0,validationTime:0},[n,a]=await Promise.all([this.getLocalStatistics(),this.getCloudStatistics()]);return r.entityCounts.local=n,r.entityCounts.cloud=a,await this.performConsistencyChecks(r,e),this.calculateOverallStatus(r),r.confidence=this.calculateValidationConfidence(r),r.validationTime=performance.now()-t,this.validationCache.set(i,r),console.log(`Consistency validation completed: ${r.summary.passedChecks}/${r.summary.totalChecks} checks passed`),r}catch(i){return console.error("Consistency validation failed:",i),{timestamp:new Date,level:e,overallStatus:"error",summary:{totalChecks:1,passedChecks:0,failedChecks:1,warnings:0,errors:1,critical:0},entityCounts:{local:{cards:0,folders:0,tags:0,images:0},cloud:{cards:0,folders:0,tags:0,images:0}},issues:[{id:crypto.randomUUID(),type:"data_corruption",entity:"system",entityId:"validation",severity:"error",message:`Validation failed: ${i instanceof Error?i.message:"Unknown error"}`,autoFixable:!1,suggestedAction:"Retry validation or check system health"}],confidence:0,validationTime:performance.now()-t}}finally{this.isProcessing=!1}}async quickValidation(){try{const e=[],[t,i]=await Promise.all([u.cards.count(),this.getCloudEntityCount("cards")]);Math.abs(t-i)>5&&e.push({id:crypto.randomUUID(),type:"version_mismatch",entity:"cards",entityId:"count",severity:"warning",message:`Card count mismatch: local=${t}, cloud=${i}`,autoFixable:!0,suggestedAction:"Run full sync to resolve count differences"});const s=await dataSyncService.getMetrics();s.reliability<.8&&e.push({id:crypto.randomUUID(),type:"data_corruption",entity:"sync",entityId:"reliability",severity:"warning",message:`Low sync reliability: ${(s.reliability*100).toFixed(1)}%`,autoFixable:!1,suggestedAction:"Check network connectivity and sync logs"});const r=e.length===0||e.every(a=>a.severity==="warning"),n=r?.9:Math.max(.5,1-e.length*.2);return{isConsistent:r,issues:e,confidence:n}}catch(e){return{isConsistent:!1,issues:[{id:crypto.randomUUID(),type:"data_corruption",entity:"system",entityId:"quick_validation",severity:"error",message:`Quick validation failed: ${e instanceof Error?e.message:"Unknown error"}`,autoFixable:!1,suggestedAction:"Retry validation"}],confidence:0}}}async autoRepairIssues(e,t={}){const i=crypto.randomUUID(),s=performance.now(),r={id:i,success:!0,repairedIssues:0,failedRepairs:0,repairedEntities:[],errors:[],duration:0};try{console.log(`Starting auto-repair for ${e.length} issues`);const n=e.sort((a,o)=>{const c={critical:4,error:3,warning:2,valid:1};return c[o.severity]-c[a.severity]});for(const a of n){if(!a.autoFixable&&!t.force){r.errors.push(`Cannot auto-fix ${a.type} for ${a.entity}:${a.entityId}`),r.failedRepairs++;continue}try{t.dryRun?(console.log(`[DRY RUN] Would repair ${a.type} for ${a.entity}:${a.entityId}`),r.repairedIssues++,r.repairedEntities.push(`${a.entity}:${a.entityId}`)):await this.repairIssue(a)?(r.repairedIssues++,r.repairedEntities.push(`${a.entity}:${a.entityId}`)):(r.errors.push(`Failed to repair ${a.type} for ${a.entity}:${a.entityId}`),r.failedRepairs++)}catch(o){const c=`Repair failed for ${a.entity}:${a.entityId}: ${o instanceof Error?o.message:"Unknown error"}`;r.errors.push(c),r.failedRepairs++}}r.success=r.failedRepairs===0,console.log(`Auto-repair completed: ${r.repairedIssues} repaired, ${r.failedRepairs} failed`)}catch(n){r.success=!1,r.errors.push(`Auto-repair failed: ${n instanceof Error?n.message:"Unknown error"}`)}return r.duration=performance.now()-s,this.repairHistory.push(r),r}async repairIssue(e){switch(console.log(`Repairing issue: ${e.type} for ${e.entity}:${e.entityId}`),e.type){case"missing_local":return await this.repairMissingLocal(e);case"missing_cloud":return await this.repairMissingCloud(e);case"version_mismatch":return await this.repairVersionMismatch(e);case"data_corruption":return await this.repairDataCorruption(e);case"relationship_violation":return await this.repairRelationshipViolation(e);default:return console.warn(`Unknown issue type: ${e.type}`),!1}}async repairMissingLocal(e){try{const t=await this.getCloudEntity(e.entity,e.entityId);if(!t)return!1;switch(e.entity){case"card":const i=m.fromCloudCard(t);await u.cards.add(i);break;case"folder":const s=m.fromCloudFolder(t);await u.folders.add(s);break;case"tag":const r=m.fromCloudTag(t);await u.tags.add(r);break;default:return!1}return!0}catch(t){return console.error(`Failed to repair missing local data for ${e.entity}:${e.entityId}:`,t),!1}}async repairMissingCloud(e){try{const t=await this.getLocalEntity(e.entity,e.entityId);if(!t)return!1;switch(e.entity){case"card":const i=m.toCloudCard(t);await y.from("cards").insert(i);break;case"folder":const s=m.toCloudFolder(t);await y.from("folders").insert(s);break;case"tag":const r=m.toCloudTag(t);await y.from("tags").insert(r);break;default:return!1}return!0}catch(t){return console.error(`Failed to repair missing cloud data for ${e.entity}:${e.entityId}:`,t),!1}}async repairVersionMismatch(e){try{const[t,i]=await Promise.all([this.getLocalEntity(e.entity,e.entityId),this.getCloudEntity(e.entity,e.entityId)]);if(!t||!i)return!1;const s=new Date(t.updatedAt).getTime();return new Date(i.updated_at).getTime()>s?await this.repairMissingLocal(e):await this.repairMissingCloud(e)}catch(t){return console.error(`Failed to repair version mismatch for ${e.entity}:${e.entityId}:`,t),!1}}async repairDataCorruption(e){try{return e.details?.corruptionType==="invalid_structure"&&await this.getCloudEntity(e.entity,e.entityId)?await this.repairMissingLocal(e):(console.warn(`Data corruption detected for ${e.entity}:${e.entityId}, attempting repair`),await this.backupCorruptedData(e.entity,e.entityId),await this.deleteLocalEntity(e.entity,e.entityId),await this.repairMissingLocal(e))}catch(t){return console.error(`Failed to repair data corruption for ${e.entity}:${e.entityId}:`,t),!1}}async repairRelationshipViolation(e){try{if(e.details?.relationshipType==="foreign_key"&&e.entity==="card"){const t=await u.cards.get(e.entityId);if(t&&t.folderId&&!await u.folders.get(t.folderId))return await u.cards.update(e.entityId,{folderId:void 0}),!0}return!1}catch(t){return console.error(`Failed to repair relationship violation for ${e.entity}:${e.entityId}:`,t),!1}}async performConsistencyChecks(e,t){const i=[];i.push(this.checkEntityCounts(e)),i.push(this.checkDataIntegrity(e)),t!=="basic"&&(i.push(this.checkVersionConsistency(e)),i.push(this.checkRelationships(e))),t==="strict"&&(i.push(this.checkDataCorruption(e)),i.push(this.checkTimestampConsistency(e))),await Promise.allSettled(i)}async checkEntityCounts(e){e.summary.totalChecks++;const t=["cards","folders","tags","images"];for(const i of t){const s=e.entityCounts.local[i],r=e.entityCounts.cloud[i],n=Math.abs(s-r),a=level==="strict"?0:5;if(n>a){const o=n>20?"error":"warning";e.issues.push({id:crypto.randomUUID(),type:s<r?"missing_local":"missing_cloud",entity:i,entityId:"count",severity:o,message:`${i} count mismatch: local=${s}, cloud=${r} (diff=${n})`,autoFixable:!0,suggestedAction:"Run sync to resolve count differences"}),o==="error"?e.summary.errors++:e.summary.warnings++}else e.summary.passedChecks++}}async checkDataIntegrity(e){e.summary.totalChecks++;try{const t=await this.checkLocalDataIntegrity(),i=await this.checkCloudDataIntegrity();!t.isValid||!i.isValid?(e.issues.push({id:crypto.randomUUID(),type:"data_corruption",entity:"system",entityId:"integrity",severity:"error",message:`Data integrity check failed: local=${t.isValid}, cloud=${i.isValid}`,details:{localErrors:t.errors,cloudErrors:i.errors},autoFixable:!1,suggestedAction:"Manual data inspection required"}),e.summary.errors++):e.summary.passedChecks++}catch{e.summary.failedChecks++,e.summary.errors++}}async checkVersionConsistency(e){e.summary.totalChecks++;try{const i=await this.checkSampleVersionConsistency(100);if(i.length>0){const s=i.length>10?"error":"warning";e.issues.push(...i.map(r=>({...r,severity:s,autoFixable:!0,suggestedAction:"Sync to resolve version conflicts"}))),s==="error"?e.summary.errors+=i.length:e.summary.warnings+=i.length}else e.summary.passedChecks++}catch{e.summary.failedChecks++}}async checkRelationships(e){e.summary.totalChecks++;try{const t=await this.checkRelationshipIntegrity();if(t.length>0){const i=t.some(s=>s.severity==="error")?"error":"warning";e.issues.push(...t),i==="error"?e.summary.errors+=t.length:e.summary.warnings+=t.length}else e.summary.passedChecks++}catch{e.summary.failedChecks++}}async checkDataCorruption(e){e.summary.totalChecks++;try{const t=await this.detectDataCorruption();if(t.length>0){const i="critical";e.issues.push(...t.map(s=>({...s,severity:i,autoFixable:!1,suggestedAction:"Manual data recovery required"}))),e.summary.critical+=t.length}else e.summary.passedChecks++}catch{e.summary.failedChecks++}}async checkTimestampConsistency(e){e.summary.totalChecks++;try{const t=await this.checkTimestampAlignment();if(t.length>0){const i="warning";e.issues.push(...t.map(s=>({...s,severity:i,autoFixable:!0,suggestedAction:"Update timestamps to align with system time"}))),e.summary.warnings+=t.length}else e.summary.passedChecks++}catch{e.summary.failedChecks++}}async getLocalStatistics(){try{const e=await u.getStats();return{cards:e.cards,folders:e.folders,tags:e.tags,images:e.images}}catch(e){return console.error("Failed to get local statistics:",e),{cards:0,folders:0,tags:0,images:0}}}async getCloudStatistics(){try{const{data:{user:e}}=await y.auth.getUser();if(!e)return{cards:0,folders:0,tags:0,images:0};const[t,i,s,r]=await Promise.all([y.from("cards").select("id",{count:"exact",head:!0}).eq("user_id",e.id),y.from("folders").select("id",{count:"exact",head:!0}).eq("user_id",e.id),y.from("tags").select("id",{count:"exact",head:!0}).eq("user_id",e.id),y.from("images").select("id",{count:"exact",head:!0}).eq("user_id",e.id)]);return{cards:t.count||0,folders:i.count||0,tags:s.count||0,images:r.count||0}}catch(e){return console.error("Failed to get cloud statistics:",e),{cards:0,folders:0,tags:0,images:0}}}async getLocalEntity(e,t){try{switch(e){case"card":return await u.cards.get(t);case"folder":return await u.folders.get(t);case"tag":return await u.tags.get(t);case"image":return await u.images.get(t);default:return null}}catch(i){return console.error(`Failed to get local ${e} ${t}:`,i),null}}async getCloudEntity(e,t){try{const{data:{user:i}}=await y.auth.getUser();return i?(await y.from(`${e}s`).select("*").eq("id",t).eq("user_id",i.id).single()).data:null}catch(i){return console.error(`Failed to get cloud ${e} ${t}:`,i),null}}async getCloudEntityCount(e){try{const{data:{user:t}}=await y.auth.getUser();return t&&(await y.from(e).select("id",{count:"exact",head:!0}).eq("user_id",t.id)).count||0}catch(t){return console.error(`Failed to get cloud ${e} count:`,t),0}}async checkLocalDataIntegrity(){const e=[];try{const t=await u.healthCheck();t.isHealthy||e.push(...t.issues),await this.checkLocalIndexes(e),await this.checkLocalForeignKeys(e)}catch(t){e.push(`Local integrity check failed: ${t instanceof Error?t.message:"Unknown error"}`)}return{isValid:e.length===0,errors:e}}async checkCloudDataIntegrity(){const e=[];try{const{error:t}=await y.from("cards").select("id",{count:"exact",head:!0}).limit(1);t&&e.push(`Cloud connection failed: ${t.message}`)}catch(t){e.push(`Cloud integrity check failed: ${t instanceof Error?t.message:"Unknown error"}`)}return{isValid:e.length===0,errors:e}}async checkSampleVersionConsistency(e){const t=[];try{const i=await u.cards.limit(e).toArray();for(const s of i){const r=await this.getCloudEntity("card",s.id);if(r){const n=new Date(s.updatedAt).getTime(),a=new Date(r.updated_at).getTime();Math.abs(n-a)>6e4&&t.push({type:"version_mismatch",entity:"card",entityId:s.id,severity:"warning",message:`Timestamp mismatch for card ${s.id}: local=${new Date(n).toISOString()}, cloud=${new Date(a).toISOString()}`,autoFixable:!0,suggestedAction:"Sync to resolve timestamp differences"})}}}catch(i){console.error("Failed to check sample version consistency:",i)}return t}async checkRelationshipIntegrity(){const e=[];try{const t=await u.cards.toArray(),i=await u.folders.toCollection().primaryKeys();for(const s of t)s.folderId&&!i.includes(s.folderId)&&e.push({type:"relationship_violation",entity:"card",entityId:s.id,severity:"warning",message:`Card ${s.id} references non-existent folder ${s.folderId}`,details:{relationshipType:"foreign_key",missingId:s.folderId},autoFixable:!0,suggestedAction:"Remove invalid folder reference or create missing folder"})}catch(t){console.error("Failed to check relationship integrity:",t)}return e}async detectDataCorruption(){const e=[];try{const t=await u.cards.toArray();for(const i of t)(!i.frontContent||!i.backContent)&&e.push({type:"data_corruption",entity:"card",entityId:i.id,severity:"critical",message:`Card ${i.id} has missing content structure`,details:{corruptionType:"invalid_structure"},autoFixable:!1,suggestedAction:"Manual data recovery required"}),i.frontContent&&typeof i.frontContent!="object"&&e.push({type:"data_corruption",entity:"card",entityId:i.id,severity:"critical",message:`Card ${i.id} has invalid content format`,details:{corruptionType:"invalid_format"},autoFixable:!1,suggestedAction:"Manual data recovery required"})}catch(t){console.error("Failed to detect data corruption:",t)}return e}async checkTimestampAlignment(){const e=[];try{const t=Date.now(),i=24*60*60*1e3,s=await u.cards.toArray();for(const r of s){const n=new Date(r.updatedAt).getTime();Math.abs(n-t)>i&&e.push({type:"version_mismatch",entity:"card",entityId:r.id,severity:"warning",message:`Card ${r.id} has timestamp ${new Date(n).toISOString()} which is far from current time`,autoFixable:!0,suggestedAction:"Update timestamp to current time"})}}catch(t){console.error("Failed to check timestamp alignment:",t)}return e}async checkLocalIndexes(e){try{const t=performance.now();await u.cards.limit(1).toArray(),performance.now()-t>100&&e.push("Local database query performance may be degraded")}catch(t){e.push(`Index check failed: ${t instanceof Error?t.message:"Unknown error"}`)}}async checkLocalForeignKeys(e){try{const t=await u.healthCheck();t.isHealthy||e.push(...t.issues)}catch(t){e.push(`Foreign key check failed: ${t instanceof Error?t.message:"Unknown error"}`)}}calculateOverallStatus(e){e.summary.critical>0?e.overallStatus="critical":e.summary.errors>0?e.overallStatus="error":e.summary.warnings>0?e.overallStatus="warning":e.overallStatus="valid"}calculateValidationConfidence(e){let t=1;switch(e.summary.critical>0&&(t-=.5),e.summary.errors>0&&(t-=.3),e.summary.warnings>0&&(t-=.1),e.level){case"basic":t*=.8;break;case"relaxed":t*=.9;break;case"strict":t*=1;break}return Math.max(0,Math.min(1,t))}getRecentValidationReport(e){const t=Date.now()-3e5;for(const[i,s]of this.validationCache.entries())if(s.level===e&&s.timestamp.getTime()>t)return s;return null}cleanupValidationCache(){const e=Date.now()-36e5;for(const[t,i]of this.validationCache.entries())i.timestamp.getTime()<e&&this.validationCache.delete(t)}async backupCorruptedData(e,t){try{const i=await this.getLocalEntity(e,t);if(i){const s=`backup_${e}_${t}_${Date.now()}`,r={entity:e,entityId:t,data:i,timestamp:new Date().toISOString()};localStorage.setItem(s,JSON.stringify(r)),console.log(`Backed up corrupted ${e}:${t}`)}}catch(i){console.error(`Failed to backup ${e}:${t}:`,i)}}async deleteLocalEntity(e,t){try{switch(e){case"card":await u.cards.delete(t);break;case"folder":await u.folders.delete(t);break;case"tag":await u.tags.delete(t);break;case"image":await u.images.delete(t);break}}catch(i){console.error(`Failed to delete ${e}:${t}:`,i)}}}const D=new pe;class me{currentState="idle";currentSession=null;syncHistory=[];metrics=this.getDefaultMetrics();listeners=new Set;consistencyCache=new Map;syncIntervals=new Map;isInitialized=!1;retryCount=0;maxRetries=3;autoRepairEnabled=!0;validationLevel="relaxed";lastValidationTime=null;batchOptimization={enabled:!0,dynamicBatchSize:!0,minBatchSize:10,maxBatchSize:200,adaptiveDelay:!0,networkAware:!0};performanceMetrics={avgBatchTime:0,avgBatchSize:0,successRate:1,networkLatency:0,lastBatchTime:0};constructor(){this.initialize()}getDefaultMetrics(){return{totalSessions:0,successfulSessions:0,failedSessions:0,averageSessionTime:0,dataThroughput:0,conflictRate:0,reliability:1}}async initialize(){if(!this.isInitialized)try{this.integrateWithSyncQueue(),this.startBackgroundSync(),this.startHealthCheck(),this.startDataValidation(),this.isInitialized=!0,console.log("DataSyncService initialized successfully")}catch(e){throw console.error("Failed to initialize DataSyncService:",e),e}}integrateWithSyncQueue(){C.setEventListeners({onOperationComplete:this.handleQueueOperationComplete.bind(this),onBatchComplete:this.handleQueueBatchComplete.bind(this),onQueueError:this.handleQueueError.bind(this),onStatusChange:this.handleQueueStatusChange.bind(this)})}startBackgroundSync(){this.syncIntervals.forEach((r,n)=>{clearInterval(r),console.log(`🧹 清理现有定时器: ${n}`)}),this.syncIntervals.clear();const e=this.getAdaptiveSyncInterval();console.log(`🔄 启动主要后台同步服务，间隔: ${e/1e3}秒`);const t=setInterval(()=>{this.shouldPerformBackgroundSync()&&(console.log("🔄 执行后台增量同步..."),this.performIncrementalSync().catch(r=>{console.error("❌ 后台同步失败:",r)}))},e);this.syncIntervals.set("mainSync",t);const i=setInterval(()=>{console.log("🔍 执行数据一致性检查..."),this.checkDataConsistency().catch(r=>{console.error("❌ 数据一致性检查失败:",r)})},30*60*1e3);this.syncIntervals.set("consistencyCheck",i);const s=setInterval(()=>{console.log("🧹 清理过期同步会话..."),this.cleanupExpiredSessions()},6*60*60*1e3);this.syncIntervals.set("cleanup",s),console.log("✅ DataSyncService 后台同步已启动，这是唯一的同步服务")}startHealthCheck(){setInterval(()=>{this.performHealthCheck().catch(console.error)},10*60*1e3)}async performFullSync(e="bidirectional"){if(this.currentState!=="idle")throw new Error(`Cannot start sync: current state is ${this.currentState}`);if(!await this.validateBeforeSync())throw new Error("Pre-sync validation failed: data consistency issues detected");const i=this.createSyncSession(e);this.currentState="syncing",this.currentSession=i,this.notifyListeners(i);try{const s=performance.now();switch(e){case"upstream":await this.performUpstreamSync(i);break;case"downstream":await this.performDownstreamSync(i);break;case"bidirectional":await this.performBidirectionalSync(i);break}await this.validateAfterSync(i),await this.quickConsistencyCheck(i),i.endTime=new Date,i.duration=performance.now()-s,i.conflicts>0&&i.state==="syncing"&&(i.state="completed"),this.updateMetrics(i),console.log(`Full sync completed: ${i.processed} operations, ${i.conflicts} conflicts`)}catch(s){await this.handleSyncError(i,s)}finally{this.currentState="idle",this.currentSession=null,this.notifyListeners(i)}return i}async performIncrementalSync(){if(this.currentState!=="idle")return console.log("Sync already in progress, skipping incremental sync"),this.currentSession;const e=this.createSyncSession("bidirectional","incremental");this.currentState="syncing",this.currentSession=e,this.notifyListeners(e);try{await this.processPriorityOperations(e),await this.quickConsistencyCheck(e),e.endTime=new Date,e.state="completed",e.duration=e.endTime.getTime()-e.startTime.getTime(),this.updateMetrics(e)}catch(t){await this.handleSyncError(e,t)}finally{this.currentState="idle",this.currentSession=null,this.notifyListeners(e)}return e}async performUpstreamSync(e){console.log("Starting upstream sync (local to cloud)");const t=await this.getLocalChanges();if(t.length===0){console.log("No local changes to sync upstream");return}console.log(`Syncing ${t.length} local changes to cloud`);const i=await this.syncBatchToCloud(t,e);e.processed+=i.length,e.successful+=i.filter(s=>s.success).length,e.failed+=i.filter(s=>!s.success).length,e.conflicts+=i.filter(s=>s.metadata?.conflicts&&s.metadata.conflicts>0).length,e.dataTransferred=i.reduce((s,r)=>s+(r.metadata?.dataSize||0),0),console.log(`Upstream sync completed: ${e.successful}/${e.processed} operations`)}async performDownstreamSync(e){console.log("Starting downstream sync (cloud to local)");const t=await this.getCloudChanges();if(t.length===0){console.log("No cloud changes to sync downstream");return}console.log(`Syncing ${t.length} cloud changes to local`);const i=await this.syncBatchToLocal(t,e);e.processed+=i.length,e.successful+=i.filter(s=>s.success).length,e.failed+=i.filter(s=>!s.success).length,e.conflicts+=i.filter(s=>s.metadata?.conflicts&&s.metadata.conflicts>0).length,e.dataTransferred=i.reduce((s,r)=>s+(r.metadata?.dataSize||0),0),console.log(`Downstream sync completed: ${e.successful}/${e.processed} operations`)}async performBidirectionalSync(e){console.log("Starting bidirectional sync");const[t,i]=await Promise.allSettled([this.performUpstreamSync(e),this.performDownstreamSync(e)]);t.status==="rejected"&&console.error("Upstream sync failed:",t.reason),i.status==="rejected"&&console.error("Downstream sync failed:",i.reason),console.log("Bidirectional sync completed")}async syncBatchToCloud(e,t){if(!this.batchOptimization.enabled)return await this.syncBatchToCloudLegacy(e,t);const i=[],s=performance.now(),r=this.optimizeOperationGrouping(e);for(const[a,o]of Object.entries(r)){console.log(`Processing ${o.length} ${a} operations with optimization`);const c=await this.getOptimalBatchStrategy(o.length,"cloud"),l=await this.processOptimizedCloudBatch(a,o,c,t);i.push(...l)}const n=performance.now()-s;return this.updateBatchPerformanceMetrics(e.length,n,i),i}async processOptimizedCloudBatch(e,t,i,s){const r=[],{batchSize:n,delay:a,parallel:o}=i;if(o&&t.length>n*2){const l=this.chunkOperations(t,n).map(async(g,p)=>(p>0&&await new Promise(w=>setTimeout(w,p*a/2)),this.processCloudBatch(e,g,s)));(await Promise.allSettled(l)).forEach(g=>{g.status==="fulfilled"&&r.push(...g.value)})}else for(let c=0;c<t.length;c+=n){const l=t.slice(c,c+n),h=await this.processCloudBatch(e,l,s);r.push(...h),c+n<t.length&&a>0&&await this.adaptiveDelay(a)}return r}async syncBatchToLocal(e,t){const s=[],r=this.groupOperationsByEntity(e);for(const[n,a]of Object.entries(r)){console.log(`Processing ${a.length} ${n} operations to local`);for(let o=0;o<a.length;o+=100){const c=a.slice(o,o+100),l=await this.processLocalBatch(n,c,t);s.push(...l)}}return s}async processCloudBatch(e,t,i){const s=[];try{await u.transaction("rw",[u.cards,u.folders,u.tags,u.images],async()=>{for(const r of t){const n=await this.executeCloudOperation(e,r,i);s.push(n),n.success&&await this.updateLocalSyncStatus(e,r.id)}})}catch(r){console.error(`Batch operation failed for ${e}:`,r);for(const n of t)s.push({id:n.id,success:!1,entity:e,entityId:n.id,operation:n.type,duration:0,error:r instanceof Error?r.message:"Unknown error"})}return s}async processLocalBatch(e,t,i){const s=[];try{for(const r of t){const n=await this.executeLocalOperation(e,r,i);s.push(n)}}catch(r){console.error(`Local batch operation failed for ${e}:`,r);for(const n of t)s.push({id:n.id,success:!1,entity:e,entityId:n.id,operation:n.type,duration:0,error:r instanceof Error?r.message:"Unknown error"})}return s}async executeCloudOperation(e,t,i){const s=performance.now();try{switch(e){case"card":return await this.syncCardToCloud(t,i);case"folder":return await this.syncFolderToCloud(t,i);case"tag":return await this.syncTagToCloud(t,i);case"image":return await this.syncImageToCloud(t,i);default:throw new Error(`Unknown entity type: ${e}`)}}catch(r){return{id:t.id,success:!1,entity:e,entityId:t.id,operation:t.type,duration:performance.now()-s,error:r instanceof Error?r.message:"Unknown error"}}}async executeLocalOperation(e,t,i){const s=performance.now();try{switch(e){case"card":return await this.syncCardToLocal(t,i);case"folder":return await this.syncFolderToLocal(t,i);case"tag":return await this.syncTagToLocal(t,i);case"image":return await this.syncImageToLocal(t,i);default:throw new Error(`Unknown entity type: ${e}`)}}catch(r){return{id:t.id,success:!1,entity:e,entityId:t.id,operation:t.type,duration:performance.now()-s,error:r instanceof Error?r.message:"Unknown error"}}}async syncCardToCloud(e,t){const i=performance.now();try{const s=m.toCloudCard(e);let r;if(e.syncVersion===1?r=await y.from("cards").insert(s).select().single():r=await y.from("cards").update(s).eq("id",e.id).select().single(),r.error)throw r.error;return{id:e.id,success:!0,entity:"card",entityId:e.id,operation:e.syncVersion===1?"create":"update",duration:performance.now()-i,metadata:{localVersion:e.syncVersion,cloudVersion:r.data.sync_version,dataSize:JSON.stringify(s).length}}}catch(s){return{id:e.id,success:!1,entity:"card",entityId:e.id,operation:e.syncVersion===1?"create":"update",duration:performance.now()-i,error:s instanceof Error?s.message:"Unknown error"}}}async syncCardToLocal(e,t){const i=performance.now();try{const s=m.fromCloudCard(e),r=await u.cards.get(e.id);return r?await u.cards.update(e.id,s):await u.cards.add(s),{id:e.id,success:!0,entity:"card",entityId:e.id,operation:r?"update":"create",duration:performance.now()-i,metadata:{localVersion:s.syncVersion,cloudVersion:e.sync_version,dataSize:JSON.stringify(e).length}}}catch(s){return{id:e.id,success:!1,entity:"card",entityId:e.id,operation:"sync",duration:performance.now()-i,error:s instanceof Error?s.message:"Unknown error"}}}async syncFolderToCloud(e,t){const i=performance.now();try{const s=m.toCloudFolder(e);let r;if(e.syncVersion===1?r=await y.from("folders").insert(s).select().single():r=await y.from("folders").update(s).eq("id",e.id).select().single(),r.error)throw r.error;return{id:e.id,success:!0,entity:"folder",entityId:e.id,operation:e.syncVersion===1?"create":"update",duration:performance.now()-i,metadata:{localVersion:e.syncVersion,cloudVersion:r.data.sync_version,dataSize:JSON.stringify(s).length}}}catch(s){return{id:e.id,success:!1,entity:"folder",entityId:e.id,operation:e.syncVersion===1?"create":"update",duration:performance.now()-i,error:s instanceof Error?s.message:"Unknown error"}}}async syncFolderToLocal(e,t){const i=performance.now();try{const s=m.fromCloudFolder(e),r=await u.folders.get(e.id);return r?await u.folders.update(e.id,s):await u.folders.add(s),{id:e.id,success:!0,entity:"folder",entityId:e.id,operation:r?"update":"create",duration:performance.now()-i,metadata:{localVersion:s.syncVersion,cloudVersion:e.sync_version,dataSize:JSON.stringify(e).length}}}catch(s){return{id:e.id,success:!1,entity:"folder",entityId:e.id,operation:"sync",duration:performance.now()-i,error:s instanceof Error?s.message:"Unknown error"}}}async syncTagToCloud(e,t){const i=performance.now();try{const s=m.toCloudTag(e);let r;if(e.syncVersion===1?r=await y.from("tags").insert(s).select().single():r=await y.from("tags").update(s).eq("id",e.id).select().single(),r.error)throw r.error;return{id:e.id,success:!0,entity:"tag",entityId:e.id,operation:e.syncVersion===1?"create":"update",duration:performance.now()-i,metadata:{localVersion:e.syncVersion,cloudVersion:r.data.sync_version,dataSize:JSON.stringify(s).length}}}catch(s){return{id:e.id,success:!1,entity:"tag",entityId:e.id,operation:e.syncVersion===1?"create":"update",duration:performance.now()-i,error:s instanceof Error?s.message:"Unknown error"}}}async syncTagToLocal(e,t){const i=performance.now();try{const s=m.fromCloudTag(e),r=await u.tags.get(e.id);return r?await u.tags.update(e.id,s):await u.tags.add(s),{id:e.id,success:!0,entity:"tag",entityId:e.id,operation:r?"update":"create",duration:performance.now()-i,metadata:{localVersion:s.syncVersion,cloudVersion:e.sync_version,dataSize:JSON.stringify(e).length}}}catch(s){return{id:e.id,success:!1,entity:"tag",entityId:e.id,operation:"sync",duration:performance.now()-i,error:s instanceof Error?s.message:"Unknown error"}}}async syncImageToCloud(e,t){const i=performance.now();try{return{id:e.id,success:!0,entity:"image",entityId:e.id,operation:"sync",duration:performance.now()-i,metadata:{localVersion:e.syncVersion,dataSize:e.metadata.size}}}catch(s){return{id:e.id,success:!1,entity:"image",entityId:e.id,operation:"sync",duration:performance.now()-i,error:s instanceof Error?s.message:"Unknown error"}}}async syncImageToLocal(e,t){const i=performance.now();try{return{id:e.id,success:!0,entity:"image",entityId:e.id,operation:"sync",duration:performance.now()-i,metadata:{cloudVersion:e.sync_version,dataSize:e.size||0}}}catch(s){return{id:e.id,success:!1,entity:"image",entityId:e.id,operation:"sync",duration:performance.now()-i,error:s instanceof Error?s.message:"Unknown error"}}}async checkDataConsistency(){const e=`consistency_${Date.now()}`;if(this.consistencyCache.has(e))return this.consistencyCache.get(e);const t={timestamp:new Date,localCount:{cards:0,folders:0,tags:0,images:0},cloudCount:{cards:0,folders:0,tags:0,images:0},inconsistencies:{missingLocal:[],missingCloud:[],versionMismatches:[],dataCorruption:[]},isConsistent:!0,confidence:0};try{const i=await u.getStats();t.localCount={cards:i.cards,folders:i.folders,tags:i.tags,images:i.images};const s=await this.getCloudStats();t.cloudCount=s;const r=await this.analyzeInconsistencies(t.localCount,t.cloudCount);if(t.inconsistencies=r,t.isConsistent=this.calculateConsistency(r),t.confidence=this.calculateConfidence(t),this.consistencyCache.set(e,t),this.consistencyCache.size>10){const n=this.consistencyCache.keys().next().value;this.consistencyCache.delete(n)}}catch(i){console.error("Data consistency check failed:",i),t.isConsistent=!1}return t}async quickConsistencyCheck(e){try{const[t,i]=await Promise.all([u.cards.count(),this.getCloudEntityCount("cards")]);Math.abs(t-i)>5&&(console.warn("Card count inconsistency detected:",t,"vs",i),e.conflicts+=Math.abs(t-i))}catch(t){console.error("Quick consistency check failed:",t)}}async getCloudStats(){try{const{data:{user:e}}=await y.auth.getUser();if(!e)throw new Error("User not authenticated");const[t,i,s,r]=await Promise.all([y.from("cards").select("id",{count:"exact",head:!0}).eq("user_id",e.id),y.from("folders").select("id",{count:"exact",head:!0}).eq("user_id",e.id),y.from("tags").select("id",{count:"exact",head:!0}).eq("user_id",e.id),y.from("images").select("id",{count:"exact",head:!0}).eq("user_id",e.id)]);return{cards:t.count||0,folders:i.count||0,tags:s.count||0,images:r.count||0}}catch(e){return console.error("Failed to get cloud stats:",e),{cards:0,folders:0,tags:0,images:0}}}async analyzeInconsistencies(e,t){const i={missingLocal:[],missingCloud:[],versionMismatches:[],dataCorruption:[]},s=["cards","folders","tags","images"];for(const r of s){const n=Math.abs(e[r]-t[r]);n>10&&(e[r]<t[r]?i.missingLocal.push(`${r}: missing ${n} items`):i.missingCloud.push(`${r}: missing ${n} items`))}return i}calculateConsistency(e){return e.missingLocal.length+e.missingCloud.length+e.versionMismatches.length+e.dataCorruption.length===0}calculateConfidence(e){let t=1;return e.inconsistencies.dataCorruption.length>0&&(t-=.5),e.inconsistencies.versionMismatches.length>0&&(t-=.3),(e.inconsistencies.missingLocal.length>0||e.inconsistencies.missingCloud.length>0)&&(t-=.2),Math.max(0,t)}createSyncSession(e,t="full"){return{id:crypto.randomUUID(),startTime:new Date,state:"syncing",direction:e,processed:0,successful:0,failed:0,conflicts:0,dataTransferred:0,networkLatency:0,operations:[]}}async handleSyncError(e,t){console.error("Sync error:",t),e.state="error",e.endTime=new Date,this.metrics.failedSessions++,this.metrics.reliability=this.metrics.successfulSessions/Math.max(1,this.metrics.totalSessions),this.retryCount<this.maxRetries?(this.retryCount++,console.log(`Retrying sync (attempt ${this.retryCount}/${this.maxRetries})`),setTimeout(()=>{this.performFullSync(e.direction).catch(console.error)},this.getRetryDelay())):(this.retryCount=0,console.error("Max retries reached, sync failed"))}updateMetrics(e){this.metrics.totalSessions++,e.state==="completed"?this.metrics.successfulSessions++:this.metrics.failedSessions++;const t=e.endTime?e.endTime.getTime()-e.startTime.getTime():0;if(this.metrics.averageSessionTime=(this.metrics.averageSessionTime*(this.metrics.totalSessions-1)+t)/this.metrics.totalSessions,e.duration>0){const i=e.dataTransferred/(e.duration/1e3);this.metrics.dataThroughput=(this.metrics.dataThroughput*(this.metrics.totalSessions-1)+i)/this.metrics.totalSessions}this.metrics.conflictRate=(this.metrics.conflictRate*(this.metrics.totalSessions-1)+e.conflicts/Math.max(1,e.processed))/this.metrics.totalSessions,this.metrics.reliability=this.metrics.successfulSessions/this.metrics.totalSessions,this.metrics.lastSyncTime=e.endTime||e.startTime}async getLocalChanges(){const e=await u.cards.filter(i=>i.pendingSync).toArray(),t=await u.folders.filter(i=>i.pendingSync).toArray();return console.log(`🔍 Found ${e.length} cards and ${t.length} folders pending sync`),[...e,...t]}async getCloudChanges(){try{const{data:{user:e}}=await y.auth.getUser();if(!e)return[];const t=this.metrics.lastSyncTime||new Date(0),[i,s,r]=await Promise.all([y.from("cards").select("*").eq("user_id",e.id).gte("updated_at",t.toISOString()),y.from("folders").select("*").eq("user_id",e.id).gte("updated_at",t.toISOString()),y.from("tags").select("*").eq("user_id",e.id).gte("updated_at",t.toISOString())]);return[...(i.data||[]).map(n=>({...n,entity:"card"})),...(s.data||[]).map(n=>({...n,entity:"folder"})),...(r.data||[]).map(n=>({...n,entity:"tag"}))]}catch(e){return console.error("Failed to get cloud changes:",e),[]}}async processPriorityOperations(e){const t=await C.getOperations({priority:"high",limit:20});t.length>0&&(console.log(`Processing ${t.length} high priority operations`),await C.processNextBatch())}groupOperationsByEntity(e){const t={};for(const i of e){const s=i.entity||this.inferEntityType(i);t[s]||(t[s]=[]),t[s].push(i)}return t}inferEntityType(e){return e.frontContent?"card":e.name&&e.parentId!==void 0?"folder":e.name&&e.color?"tag":e.fileName?"image":"unknown"}async updateLocalSyncStatus(e,t){try{let i;switch(e){case"card":i=u.cards;break;case"folder":i=u.folders;break;case"tag":i=u.tags;break;default:return}await i.where("id").equals(t).modify({pendingSync:!1,lastSyncAt:new Date})}catch(i){console.error("Failed to update local sync status:",i)}}async getCloudEntityCount(e){try{const{data:{user:t}}=await y.auth.getUser();return t&&(await y.from(e).select("id",{count:"exact",head:!0}).eq("user_id",t.id)).count||0}catch(t){return console.error(`Failed to get cloud ${e} count:`,t),0}}getAdaptiveSyncInterval(){const e=this.metrics.reliability;return e<.5?3*60*1e3:e<.8?2*60*1e3:e<.95?1*60*1e3:30*1e3}getRetryDelay(){return Math.min(1e3*Math.pow(2,this.retryCount),3e4)}shouldPerformBackgroundSync(){return this.currentState==="idle"&&navigator.onLine&&(localStorage.getItem("supabase.auth.token")!==null||sessionStorage.getItem("supabase.auth.token")!==null)}cleanupExpiredSessions(){const e=new Date(Date.now()-6048e5);this.syncHistory=this.syncHistory.filter(t=>t.startTime>e),this.syncHistory.length>100&&(this.syncHistory=this.syncHistory.slice(-100))}async performHealthCheck(){try{await u.healthCheck();const{error:e}=await y.from("cards").select("id",{count:"exact",head:!0}).limit(1);if(e)throw e;console.log("DataSyncService health check passed")}catch(e){console.error("DataSyncService health check failed:",e)}}handleQueueOperationComplete(e,t){console.log(`Queue operation ${e.id} completed: ${t}`)}handleQueueBatchComplete(e){console.log("Queue batch completed:",e)}handleQueueError(e){console.error("Queue error:",e)}handleQueueStatusChange(e){console.log("Queue status changed:",e)}notifyListeners(e){this.listeners.forEach(t=>t(e))}onSyncStatusChange(e){return this.listeners.add(e),e(this.currentSession||this.createSyncSession("bidirectional")),()=>{this.listeners.delete(e)}}async getMetrics(){return{...this.metrics}}async getSyncHistory(e){const t=[...this.syncHistory];return this.currentSession&&t.unshift(this.currentSession),e?t.slice(0,e):t}async getConsistencyReport(){return await this.checkDataConsistency()}async forceSync(e="bidirectional"){return await this.performFullSync(e)}pauseSync(){this.currentState="paused",this.currentSession&&(this.currentSession.state="paused")}resumeSync(){this.currentState==="paused"&&(this.currentState="idle",this.currentSession&&(this.currentSession.state="syncing",this.performFullSync(this.currentSession.direction).catch(console.error)))}getCurrentState(){return this.currentState}getCurrentSession(){return this.currentSession}startDataValidation(){setInterval(async()=>{this.currentState!=="syncing"&&await this.performScheduledValidation()},30*60*1e3)}async performScheduledValidation(){try{console.log("Performing scheduled data validation...");const e=await D.validateConsistency(this.validationLevel);this.lastValidationTime=new Date,e.overallStatus==="critical"||e.overallStatus==="error"?(console.error("Data consistency validation failed:",e.summary),this.autoRepairEnabled&&e.issues.length>0&&await this.attemptAutoRepair(e.issues)):console.log("Data validation completed successfully:",e.summary)}catch(e){console.error("Scheduled data validation failed:",e)}}async validateBeforeSync(){try{const e=await D.validateConsistency("basic");return e.overallStatus==="critical"?(console.error("Data consistency check failed before sync:",e.summary),!1):!0}catch(e){return console.error("Pre-sync validation failed:",e),!1}}async validateAfterSync(e){try{const t=await D.validateConsistency(this.validationLevel);t.overallStatus==="critical"||t.overallStatus==="error"?(e.state="error",console.error("Post-sync validation failed:",t.summary),this.autoRepairEnabled&&await this.attemptAutoRepair(t.issues)):console.log("Post-sync validation passed:",t.summary)}catch(t){console.error("Post-sync validation failed:",t),e.state="error"}}async attemptAutoRepair(e){try{console.log("Attempting auto-repair for",e.length,"consistency issues");const t=await D.autoRepairIssues(e,{dryRun:!1,maxRetries:3,repairStrategy:"conservative"});t.success?console.log(`Auto-repair completed: ${t.repairedIssues} issues repaired`):console.error("Auto-repair failed:",t.errors)}catch(t){console.error("Auto-repair attempt failed:",t)}}async getDetailedConsistencyReport(e="relaxed"){return await D.validateConsistency(e)}async manualValidation(e="strict"){return console.log("Manual validation triggered with level:",e),await D.validateConsistency(e)}configureValidation(e){e.level!==void 0&&(this.validationLevel=e.level),e.autoRepair!==void 0&&(this.autoRepairEnabled=e.autoRepair),console.log("Validation configuration updated:",{level:this.validationLevel,autoRepair:this.autoRepairEnabled})}getLastValidationTime(){return this.lastValidationTime}async getOptimalBatchStrategy(e,t){const i=this.getBaseBatchStrategy(t);if(!this.batchOptimization.dynamicBatchSize)return i;const s=this.calculateOptimalBatchSize(e,t),r=await this.calculateOptimalDelay(t),n=e>s*2&&t==="cloud";return{batchSize:s,delay:r,parallel:n,useTransaction:t==="local",priority:e>1e3?"high":"normal"}}getBaseBatchStrategy(e){return e==="cloud"?{batchSize:50,delay:100,parallel:!1,useTransaction:!1,priority:"normal"}:{batchSize:100,delay:10,parallel:!1,useTransaction:!0,priority:"normal"}}calculateOptimalBatchSize(e,t){const{minBatchSize:i,maxBatchSize:s}=this.batchOptimization,r=this.performanceMetrics.successRate>.95?1.2:this.performanceMetrics.successRate>.8?1:.8,n=this.performanceMetrics.avgBatchTime>1e3?.8:1,a=this.performanceMetrics.networkLatency>500?.7:1,c=Math.round((t==="cloud"?50:100)*r*n*a);return Math.max(i,Math.min(s,c))}async calculateOptimalDelay(e){if(!this.batchOptimization.adaptiveDelay)return e==="cloud"?100:10;if(this.batchOptimization.networkAware&&e==="cloud")try{const t=performance.now();await fetch("https://api.supabase.io/health",{method:"HEAD"});const i=performance.now()-t;return this.performanceMetrics.networkLatency=i,i<200?50:i<500?100:i<1e3?200:300}catch{return 500}return e==="cloud"?100:10}async adaptiveDelay(e){if(!this.batchOptimization.adaptiveDelay){await new Promise(s=>setTimeout(s,e));return}const t=navigator.hardwareConcurrency?Math.max(.5,1-(navigator.hardwareConcurrency-4)/8):1,i=Math.round(e*t);await new Promise(s=>setTimeout(s,i))}optimizeOperationGrouping(e){const t=this.groupOperationsByEntity(e),i=["tags","folders","cards","images"],s={};return i.forEach(r=>{t[r]&&(s[r]=t[r])}),Object.keys(t).forEach(r=>{i.includes(r)||(s[r]=t[r])}),s}chunkOperations(e,t){const i=[];for(let s=0;s<e.length;s+=t)i.push(e.slice(s,s+t));return i}updateBatchPerformanceMetrics(e,t,i){const s=i.filter(a=>a.success).length,r=e>0?s/e:1,n=.3;this.performanceMetrics.avgBatchTime=n*t+(1-n)*this.performanceMetrics.avgBatchTime,this.performanceMetrics.avgBatchSize=n*e+(1-n)*this.performanceMetrics.avgBatchSize,this.performanceMetrics.successRate=n*r+(1-n)*this.performanceMetrics.successRate,this.performanceMetrics.lastBatchTime=performance.now()}getBatchPerformanceMetrics(){return{...this.performanceMetrics}}configureBatchOptimization(e){this.batchOptimization={...this.batchOptimization,...e},console.log("Batch optimization configuration updated:",this.batchOptimization)}async syncBatchToCloudLegacy(e,t){const s=[],r=this.groupOperationsByEntity(e);for(const[n,a]of Object.entries(r))for(let o=0;o<a.length;o+=50){const c=a.slice(o,o+50),l=await this.processCloudBatch(n,c,t);s.push(...l),o+50<a.length&&await new Promise(h=>setTimeout(h,100))}return s}}const S=new me,we={maxRetries:5,initialRetryDelay:1e3,maxRetryDelay:3e5,retryBackoffMultiplier:2,batchSize:10,batchTimeout:5e3,maxConcurrentBatches:3,processingTimeout:3e4,idleCheckInterval:1e4,cleanupInterval:3e5,networkAware:!0,offlineMode:!0,requireWifiForLargeFiles:!0,maxQueueSize:1e4,maxAge:7*24*60*60*1e3};class Se{config;isProcessing=!1;processingTimer=null;cleanupTimer=null;currentBatches=new Map;listeners={};constructor(e={}){this.config={...we,...e},this.initialize()}async initialize(){try{await u.open(),await this.restoreQueueFromStorage(),this.startProcessing(),this.startCleanup()}catch(e){console.error("Failed to initialize LocalOperationService:",e)}}async restoreQueueFromStorage(){try{const e=localStorage.getItem("syncQueue");if(e){const t=JSON.parse(e);for(const i of t){const s=this.convertOperationFormat(i);try{await u.syncQueue.add(s)}catch{console.warn("Operation already exists in database, skipping:",i.id)}}localStorage.removeItem("syncQueue"),console.log(`Restored ${t.length} operations from local storage`)}}catch(e){console.error("Failed to restore queue from storage:",e)}}convertOperationFormat(e){return e.entityType&&e.operationType&&e.entityId?e:{id:e.id,entityType:e.table==="cards"?"card":e.table==="folders"?"folder":e.table==="tags"?"tag":"image",operationType:e.type,entityId:e.localId,data:e.data,timestamp:e.timestamp,retryCount:e.retryCount||0,status:e.status||"pending",localVersion:e.localVersion||1,priority:e.priority||"normal",dependsOn:e.dependsOn||[]}}async addOperation(e){if(!e.entityId||e.entityId.trim()==="")throw new Error("Local ID is required");if(!e.entityType||!["card","folder","tag","image"].includes(e.entityType))throw new Error("Invalid entity type");if(!e.operationType||!["create","update","delete"].includes(e.operationType))throw new Error("Invalid operation type");if(!e.data)throw new Error("Operation data is required");const t=crypto.randomUUID(),i=new Date,s={...e,id:t,timestamp:i,retryCount:0,status:"pending",localVersion:Date.now(),retryDelay:this.config.initialRetryDelay,maxRetries:this.config.maxRetries};this.config.networkAware&&(s.networkInfo=await this.getNetworkInfo());const r=await u.syncQueue.where("entityId").equals(e.entityId).and(n=>n.entityType===e.entityType&&n.status==="pending").first();try{return r?(await u.syncQueue.update(r.id,{data:e.data,previousData:e.previousData,timestamp:i,localVersion:Date.now()}),console.log(`Operation updated in queue: ${r.id}`),r.id):(await u.syncQueue.add(s),this.notifyListeners("operationAdded",s),await this.updateQueueStats(),console.log(`Operation added to queue: ${t}`),t)}catch(n){throw console.error("Failed to add operation to queue:",n),n}}async getPendingOperations(e=this.config.batchSize,t){try{const i=await u.syncQueue.where("status").equals("pending").toArray().then(r=>{const n={critical:4,high:3,normal:2,low:1};return r.sort((a,o)=>{const c=n[o.priority]-n[a.priority];return c!==0?c:a.timestamp.getTime()-o.timestamp.getTime()})}).then(r=>t&&t.length>0?r.filter(n=>t.includes(n.priority)):r).then(r=>r.slice(0,e));return await this.filterReadyOperations(i)}catch(i){return console.error("Failed to get pending operations:",i),[]}}async markOperationProcessing(e){try{await u.syncQueue.update(e,{status:"processing",processingStartedAt:new Date})}catch(t){console.error(`Failed to mark operation ${e} as processing:`,t)}}async markOperationCompleted(e){try{const t=await u.syncQueue.get(e);if(!t)return;await u.syncQueue.update(e,{status:"completed",processingEndedAt:new Date}),this.notifyListeners("operationCompleted",t),await this.updateQueueStats()}catch(t){console.error(`Failed to mark operation ${e} as completed:`,t)}}async markOperationFailed(e,t){try{const i=await u.syncQueue.get(e);if(!i)return;const s=i.retryCount+1,r=i.retryDelay||this.config.initialRetryDelay,n=Math.min(r*this.config.retryBackoffMultiplier,this.config.maxRetryDelay),a={retryCount:s,retryDelay:n,lastError:t.message};s>=i.maxRetries?(a.status="failed",console.warn(`Operation ${e} failed after ${s} attempts`)):(a.status="pending",console.log(`Operation ${e} will retry in ${n}ms (attempt ${s}/${i.maxRetries})`)),await u.syncQueue.update(e,a),this.notifyListeners("operationFailed",i,t),await this.updateQueueStats()}catch(i){console.error(`Failed to mark operation ${e} as failed:`,i)}}async cancelOperation(e,t){try{const i=await u.syncQueue.get(e);if(!i)return;await u.syncQueue.update(e,{status:"cancelled",lastError:t||"Cancelled by user"}),this.notifyListeners("operationFailed",i,new Error(t||"Operation cancelled")),await this.updateQueueStats()}catch(i){console.error(`Failed to cancel operation ${e}:`,i)}}startProcessing(){this.processingTimer&&clearInterval(this.processingTimer),this.processingTimer=setInterval(async()=>{this.isProcessing||await this.processQueue()},this.config.idleCheckInterval)}async processQueue(){if(!(this.isProcessing||this.currentBatches.size>=this.config.maxConcurrentBatches)){this.isProcessing=!0;try{const e=await this.getPendingOperations();if(e.length===0)return;const t=await this.createBatches(e);for(const i of t){const s=crypto.randomUUID(),r=this.processBatch(i,s);this.currentBatches.set(s,r),r.catch(n=>{console.error(`Batch ${s} failed:`,n)}).finally(()=>{this.currentBatches.delete(s)})}}catch(e){console.error("Error processing queue:",e)}finally{this.isProcessing=!1}}}async createBatches(e){const t=[];let i=[];const s=[...e].sort((r,n)=>{const a={critical:4,high:3,normal:2,low:1};return a[n.priority]-a[r.priority]});for(const r of s)i.length>=this.config.batchSize&&(t.push(i),i=[]),!(this.config.requireWifiForLargeFiles&&r.entityType==="image"&&(await this.getNetworkInfo()).connectionType!=="wifi")&&i.push(r);return i.length>0&&t.push(i),t}async processBatch(e,t){try{await Promise.all(e.map(i=>this.markOperationProcessing(i.id))),e.forEach(i=>{this.notifyListeners("operationStarted",i)}),await this.executeBatchSync(e,t),await Promise.all(e.map(i=>this.markOperationCompleted(i.id))),console.log(`Batch ${t} processed successfully (${e.length} operations)`)}catch(i){console.error(`Batch ${t} failed:`,i),await Promise.all(e.map(s=>this.markOperationFailed(s.id,i)))}}async executeBatchSync(e,t){try{const{unifiedSyncService:i}=await F(async()=>{const{unifiedSyncService:r}=await Promise.resolve().then(()=>Q);return{unifiedSyncService:r}},void 0),s=this.groupOperationsByType(e);for(const[r,n]of Object.entries(s))await this.processEntityGroup(r,n,i);console.log(`Batch ${t} sync execution completed`)}catch(i){throw console.error(`Batch ${t} sync execution failed:`,i),i}}groupOperationsByType(e){const t={};for(const i of e)t[i.entityType]||(t[i.entityType]=[]),t[i.entityType].push(i);return t}async processEntityGroup(e,t,i){switch(e){case"card":await this.processCardOperations(t,i);break;case"folder":await this.processFolderOperations(t,i);break;case"tag":await this.processTagOperations(t,i);break;case"image":await this.processImageOperations(t,i);break;default:console.warn(`Unknown entity type: ${e}`)}}async processCardOperations(e,t){await this.processEntityOperations(e,"card",t)}async processEntityOperations(e,t,i){for(const s of e)try{const r={type:s.operationType,entity:t,entityId:s.entityId,data:s.data,priority:s.priority,userId:s.userId,metadata:{source:"local-operation"}};await i.addOperation(r)}catch(r){throw console.error(`Failed to process ${t} operation ${s.id}:`,r),r}}async processFolderOperations(e,t){await this.processEntityOperations(e,"folder",t)}async processTagOperations(e,t){await this.processEntityOperations(e,"tag",t)}async processImageOperations(e,t){await this.processEntityOperations(e,"image",t)}startCleanup(){this.cleanupTimer&&clearInterval(this.cleanupTimer),this.cleanupTimer=setInterval(async()=>{await this.cleanupQueue()},this.config.cleanupInterval)}async cleanupQueue(){try{const e=Date.now(),t=new Date(e-this.config.maxAge);await u.syncQueue.where("timestamp").below(t).delete();const i=await u.syncQueue.where("status").equals("completed").orderBy("timestamp").reverse().offset(1e3).toArray();i.length>0&&await u.syncQueue.bulkDelete(i.map(r=>r.id));const s=await u.syncQueue.count();if(s>this.config.maxQueueSize){const r=s-this.config.maxQueueSize,n=await u.syncQueue.orderBy("timestamp").limit(r).toArray();await u.syncQueue.bulkDelete(n.map(a=>a.id))}console.log("Queue cleanup completed")}catch(e){console.error("Queue cleanup failed:",e)}}async getNetworkInfo(){if(!("connection"in navigator))return{online:navigator.onLine,connectionType:"none",effectiveType:"4g"};const e=navigator.connection;return{online:navigator.onLine,connectionType:this.getConnectionType(e),effectiveType:e.effectiveType||"4g",rtt:e.rtt,downlink:e.downlink}}getConnectionType(e){if(!e)return"none";switch(e.type){case"wifi":case"ethernet":return"wifi";case"cellular":case"bluetooth":return"cellular";default:return"none"}}async filterReadyOperations(e){const t=[];for(const i of e){if(!i.dependsOn||i.dependsOn.length===0){t.push(i);continue}(await u.syncQueue.where("id").anyOf(i.dependsOn).toArray()).every(n=>n.status==="completed")&&t.push(i)}return t}async getQueueStats(){try{const e=await u.syncQueue.toArray(),t={totalOperations:e.length,pendingOperations:0,processingOperations:0,failedOperations:0,completedOperations:0,byType:{card:0,folder:0,tag:0,image:0},byPriority:{critical:0,high:0,normal:0,low:0},byStatus:{pending:0,processing:0,completed:0,failed:0,cancelled:0},averageProcessingTime:0,failureRate:0,oldestPendingAge:0,averageRetryCount:0};for(const n of e){if(t.byType[n.entityType]++,t.byPriority[n.priority]++,t.byStatus[n.status]++,n.status==="completed"&&n.processingStartedAt&&n.processingEndedAt){const a=n.processingEndedAt.getTime()-n.processingStartedAt.getTime();t.averageProcessingTime+=a}t.averageRetryCount+=n.retryCount}t.pendingOperations=t.byStatus.pending,t.processingOperations=t.byStatus.processing,t.failedOperations=t.byStatus.failed,t.completedOperations=t.byStatus.completed;const i=t.byStatus.completed;i>0&&(t.averageProcessingTime/=i),e.length>0&&(t.averageRetryCount/=e.length);const s=e.filter(n=>["completed","failed"].includes(n.status)).length;s>0&&(t.failureRate=t.failedOperations/s);const r=e.filter(n=>n.status==="pending");if(r.length>0){const n=r.reduce((o,c)=>{const l=typeof o.timestamp=="string"?new Date(o.timestamp).getTime():o.timestamp.getTime();return(typeof c.timestamp=="string"?new Date(c.timestamp).getTime():c.timestamp.getTime())<l?c:o}),a=typeof n.timestamp=="string"?new Date(n.timestamp).getTime():n.timestamp.getTime();t.oldestPendingAge=Date.now()-a}return t}catch(e){return console.error("Failed to get queue stats:",e),this.getEmptyStats()}}getEmptyStats(){return{totalOperations:0,pendingOperations:0,processingOperations:0,failedOperations:0,completedOperations:0,byType:{card:0,folder:0,tag:0,image:0},byPriority:{critical:0,high:0,normal:0,low:0},byStatus:{pending:0,processing:0,completed:0,failed:0,cancelled:0},averageProcessingTime:0,failureRate:0,oldestPendingAge:0,averageRetryCount:0}}async updateQueueStats(){try{const e=await this.getQueueStats();this.notifyListeners("queueStatsChanged",e)}catch(e){console.error("Failed to update queue stats:",e)}}addEventListener(e,t){this.listeners[e]=t}removeEventListener(e){delete this.listeners[e]}notifyListeners(e,...t){const i=this.listeners[e];if(i)try{i(...t)}catch(s){console.error(`Error in ${e} listener:`,s)}}async clearQueue(){try{await u.syncQueue.clear(),await this.updateQueueStats(),console.log("Queue cleared successfully")}catch(e){console.error("Failed to clear queue:",e)}}async getOperation(e){try{return await u.syncQueue.get(e)}catch(t){console.error(`Failed to get operation ${e}:`,t);return}}async removeOperation(e){try{await u.syncQueue.delete(e),await this.updateQueueStats()}catch(t){throw console.error(`Failed to remove operation ${e}:`,t),t}}async retryFailedOperations(){try{const e=await u.syncQueue.where("status").equals("failed").toArray();for(const t of e)await u.syncQueue.update(t.id,{status:"pending",retryCount:0,retryDelay:this.config.initialRetryDelay,lastError:void 0});return await this.updateQueueStats(),console.log(`Retried ${e.length} failed operations`),e.length}catch(e){return console.error("Failed to retry failed operations:",e),0}}async clearCompletedOperations(){try{const e=await u.syncQueue.where("status").equals("completed").toArray(),i=e.slice(0,-100);for(const s of i)await u.syncQueue.delete(s.id);return await this.updateQueueStats(),console.log(`Cleared ${i.length} completed operations, kept ${e.length-i.length} recent ones`),i.length}catch(e){return console.error("Failed to clear completed operations:",e),0}}updateConfig(e){if(e.maxRetries!==void 0&&e.maxRetries<0)throw new Error("maxRetries must be non-negative");if(e.batchSize!==void 0&&e.batchSize<=0)throw new Error("batchSize must be positive");if(e.maxQueueSize!==void 0&&e.maxQueueSize<0)throw new Error("maxQueueSize must be non-negative");if(e.processingTimeout!==void 0&&e.processingTimeout<=0)throw new Error("processingTimeout must be positive");if(e.idleCheckInterval!==void 0&&e.idleCheckInterval<=0)throw new Error("idleCheckInterval must be positive");this.config={...this.config,...e},e.idleCheckInterval!==void 0&&this.startProcessing(),e.cleanupInterval!==void 0&&this.startCleanup(),console.log("LocalOperationService config updated")}destroy(){this.processingTimer&&clearInterval(this.processingTimer),this.cleanupTimer&&clearInterval(this.cleanupTimer),Promise.all(this.currentBatches.values()).then(()=>{console.log("LocalOperationService destroyed")})}}const E=new Se;let j=class{isInitialized=!1;authService=null;syncInProgress=!1;metrics=this.getDefaultMetrics();listeners=new Set;lastFullSync=null;constructor(){this.initialize()}getDefaultMetrics(){return{totalOperations:0,successfulOperations:0,failedOperations:0,averageSyncTime:0,lastSyncTime:null,conflictsCount:0,networkQuality:"good"}}initialize(){this.isInitialized||(this.setupNetworkManager(),this.setupDataSyncService(),this.startBackgroundSync(),this.isInitialized=!0,console.log("Unified sync service initialized"))}setupNetworkManager(){v.startMonitoring(),v.addListener({onNetworkStateChanged:this.handleNetworkStateChange.bind(this),onNetworkEvent:this.handleNetworkEvent.bind(this),onSyncReady:this.handleSyncReady.bind(this)})}setupDataSyncService(){S.configureValidation({level:"relaxed",autoRepair:!0,scheduledValidation:!0}),S.configureBatchOptimization({enabled:!0,dynamicBatchSize:!0,adaptiveDelay:!0,networkAware:!0}),S.onSyncStatusChange(e=>{this.handleDataSyncStatusChange(e)})}startBackgroundSync(){setInterval(()=>{this.shouldPerformBackgroundSync()&&this.performIncrementalSync().catch(console.error)},this.getAdaptiveSyncInterval())}async addOperation(e){({...e,id:crypto.randomUUID()});try{const t={type:e.type,entity:e.entity,entityId:e.entityId,userId:e.userId,data:e.data,priority:e.priority,retryCount:0,maxRetries:this.getMaxRetries(e.priority),dependencies:this.getOperationDependencies(e)},i=await C.enqueueOperation(t);return this.updateMetrics({totalOperations:this.metrics.totalOperations+1}),this.shouldProcessImmediately()&&this.processNextOperations(),i}catch(t){throw console.error("Failed to add sync operation:",t),t}}async performFullSync(){if(!(this.syncInProgress||!this.canSync())){this.syncInProgress=!0,this.notifyStatusChange();try{const e=performance.now(),t=await S.performFullSync(SyncDirection.BIDIRECTIONAL);t.state==="error"?(console.warn("DataSyncService failed, falling back to legacy sync"),await this.performLegacyFullSync()):console.log(`DataSyncService completed: ${t.processed} operations`);const i=performance.now()-e;this.lastFullSync=new Date,this.updateMetrics({lastSyncTime:this.lastFullSync,averageSyncTime:(this.metrics.averageSyncTime+i)/2}),console.log(`Unified full sync completed in ${i}ms`)}catch(e){throw console.error("Full sync failed:",e),e}finally{this.syncInProgress=!1,this.notifyStatusChange()}}}async performLegacyFullSync(){await this.processLocalSyncQueue(),await this.syncFromCloud(),await this.processSyncQueue(),await this.detectAndResolveConflicts()}async performIncrementalSync(){if(!(this.syncInProgress||!this.canSync()))try{await S.performIncrementalSync(),await this.processLocalSyncQueue(),await this.processHighPriorityOperations(),await this.checkCloudUpdates()}catch(e){console.error("Incremental sync failed:",e)}}handleNetworkStateChange(e){this.notifyStatusChange(),e.isOnline&&e.canSync&&this.performIncrementalSync().catch(console.error),this.metrics.networkQuality=e.quality}handleNetworkEvent(e){console.log("Network event in sync service:",e.type),e.type==="online"?this.handleNetworkRestored():e.type==="offline"&&this.handleNetworkLost()}handleSyncReady(e){console.log("Sync ready with strategy:",e),!this.syncInProgress&&this.authService?.isAuthenticated()&&this.performIncrementalSync().catch(console.error)}handleNetworkRestored(){console.log("Network restored, resuming sync operations"),C.resume(),this.performIncrementalSync().catch(console.error)}handleNetworkLost(){console.log("Network lost, pausing sync operations"),C.pause()}async syncFromCloud(){if(!this.authService?.isAuthenticated())return;const e=this.authService.getCurrentUser();if(!e)return;const t=this.lastFullSync||new Date(0),[i,s,r]=await Promise.all([this.getCloudData("cards",e.id,t),this.getCloudData("folders",e.id,t),this.getCloudData("tags",e.id,t)]);await Promise.all([this.mergeCloudCards(i),this.mergeCloudFolders(s),this.mergeCloudTags(r)])}async getCloudData(e,t,i){const s=y.from(e).select("*").eq("user_id",t).gte("updated_at",i.toISOString()),{data:r,error:n}=await s;if(n)throw n;return r||[]}async mergeCloudCards(e){for(const t of e){const i=await u.cards?.get(t.id);i?await this.resolveCardConflict(i,t):await u.cards?.add(m.fromCloudCard(t))}}async mergeCloudFolders(e){for(const t of e){const i=await u.folders?.get(t.id);i?await this.resolveFolderConflict(i,t):await u.folders?.add(m.fromCloudFolder(t))}}async mergeCloudTags(e){for(const t of e){const i=await u.tags?.get(t.id);i?await this.resolveTagConflict(i,t):await u.tags?.add(m.fromCloudTag(t))}}async detectAndResolveConflicts(){console.log("Conflict detection delegated to ConflictResolver service")}async resolveCardConflict(e,t){try{const i={localData:e,cloudData:t,entityType:"card",entityId:e.id||t.id,userId:e.userId||t.user_id,context:{networkInfo:await this.getCurrentNetworkInfo(),deviceInfo:await this.getCurrentDeviceInfo()}},s=await R.resolveConflicts(i);s.success&&s.resolvedData?(e.id&&await u.cards?.update(e.id,m.fromCloudCard(s.resolvedData)),(s.resolutionStrategy.includes("local")||s.resolutionDetails?.overwrittenFields?.length>0)&&await this.addOperation({type:"update",entity:"card",entityId:e.id,data:s.resolvedData,priority:"normal",userId:e.userId})):await this.fallbackTimestampResolution(e,t,"card")}catch(i){console.error("Card conflict resolution failed:",i),await this.fallbackTimestampResolution(e,t,"card")}}async resolveFolderConflict(e,t){try{const i={localData:e,cloudData:t,entityType:"folder",entityId:e.id||t.id,userId:e.userId||t.user_id,context:{networkInfo:await this.getCurrentNetworkInfo(),deviceInfo:await this.getCurrentDeviceInfo()}},s=await R.resolveConflicts(i);s.success&&s.resolvedData?(e.id&&await u.folders?.update(e.id,m.fromCloudFolder(s.resolvedData)),(s.resolutionStrategy.includes("local")||s.resolutionDetails?.overwrittenFields?.length>0)&&await this.addOperation({type:"update",entity:"folder",entityId:e.id,data:s.resolvedData,priority:"normal",userId:e.userId})):await this.fallbackTimestampResolution(e,t,"folder")}catch(i){console.error("Folder conflict resolution failed:",i),await this.fallbackTimestampResolution(e,t,"folder")}}async resolveTagConflict(e,t){try{const i={localData:e,cloudData:t,entityType:"tag",entityId:e.id||t.id,userId:e.userId||t.user_id,context:{networkInfo:await this.getCurrentNetworkInfo(),deviceInfo:await this.getCurrentDeviceInfo()}},s=await R.resolveConflicts(i);s.success&&s.resolvedData?(e.id&&await u.tags?.update(e.id,m.fromCloudTag(s.resolvedData)),(s.resolutionStrategy.includes("local")||s.resolutionDetails?.overwrittenFields?.length>0)&&await this.addOperation({type:"update",entity:"tag",entityId:e.id,data:s.resolvedData,priority:"normal",userId:e.userId})):await this.fallbackTimestampResolution(e,t,"tag")}catch(i){console.error("Tag conflict resolution failed:",i),await this.fallbackTimestampResolution(e,t,"tag")}}async fallbackTimestampResolution(e,t,i){const s=new Date(e.updatedAt).getTime(),r=new Date(t.updated_at||t.updatedAt).getTime();if(r>s)switch(i){case"card":await u.cards?.update(t.id,m.fromCloudCard(t));break;case"folder":await u.folders?.update(t.id,m.fromCloudFolder(t));break;case"tag":await u.tags?.update(t.id,m.fromCloudTag(t));break}else s>r&&e.pendingSync&&await this.addOperation({type:"update",entity:i,entityId:e.id,data:e,priority:"normal",userId:e.userId})}async processSyncQueue(){await C.processNextBatch()}async processNextOperations(){if(!this.syncInProgress){this.syncInProgress=!0;try{await C.processNextBatch()}finally{this.syncInProgress=!1}}}async processHighPriorityOperations(){(await C.getOperations({priority:"high",limit:5})).length>0&&await this.processNextOperations()}async processLocalSyncQueue(){if(this.canSync())try{const e=await E.getPendingSyncOperations();if(e.length===0)return;console.log(`Processing ${e.length} local sync operations`);const t=await this.processBatchLocalOperations(e);await E.updateOperationStatuses(t),this.metrics.totalOperations+=t.length,this.metrics.successfulOperations+=t.filter(i=>i.success).length,this.metrics.failedOperations+=t.filter(i=>!i.success).length}catch(e){console.error("Failed to process local sync queue:",e)}}async processBatchLocalOperations(e){const t=[];for(const i of e)try{await this.executeLocalOperation(i),t.push({operationId:i.id,success:!0})}catch(s){t.push({operationId:i.id,success:!1,error:s instanceof Error?s.message:"Unknown error"})}return t}async executeLocalOperation(e){switch(e.operationType){case"create":case"update":case"delete":await this.executeDatabaseOperation(e);break;default:throw new Error(`Unknown operation type: ${e.operationType}`)}}async executeDatabaseOperation(e){const t=e.entityType,i=e.data;switch(e.operationType){case"create":await y.from(t).insert(i).select().single();break;case"update":await y.from(t).update(i).eq("id",e.entityId);break;case"delete":await y.from(t).delete().eq("id",e.entityId);break}}handleDataSyncStatusChange(e){console.log("DataSyncService status change:",e.state,e.direction),this.syncInProgress=e.state==="syncing",e.state==="completed"&&(this.lastFullSync=e.endTime,this.updateMetricsFromDataSync(e)),e.state==="error"&&(console.error("DataSyncService error:",e),this.handleSyncError(e)),this.notifyStatusChange()}updateMetricsFromDataSync(e){if(this.metrics.totalOperations+=e.processed,this.metrics.successfulOperations+=e.successful,this.metrics.failedOperations+=e.failed,this.metrics.conflictsCount+=e.conflicts,this.metrics.lastSyncTime=e.endTime,e.duration){const t=this.metrics.averageSyncTime*(this.metrics.totalOperations-e.processed)+e.duration;this.metrics.averageSyncTime=t/this.metrics.totalOperations}}handleSyncError(e){this.notifyListeners({status:"error",error:"Data sync failed",details:{processed:e.processed,successful:e.successful,failed:e.failed,conflicts:e.conflicts}})}canSync(){const e=v.getCurrentStatus();return e.isOnline&&e.canSync&&this.authService?.isAuthenticated()}shouldProcessImmediately(){return this.canSync()&&!this.syncInProgress}shouldPerformBackgroundSync(){return v.getCurrentStatus().canSync&&!this.syncInProgress&&this.authService?.isAuthenticated()}getAdaptiveSyncInterval(){switch(v.getCurrentStatus().quality){case"excellent":return 60*1e3;case"good":return 2*60*1e3;case"fair":return 5*60*1e3;case"poor":return 10*60*1e3;default:return 5*60*1e3}}getMaxRetries(e){switch(e){case"high":return 5;case"normal":return 3;case"low":return 1}}getOperationDependencies(e){const t=[];return e.entity==="card"&&e.data.folderId&&t.push(`folder_${e.data.folderId}`),t}updateMetrics(e){this.metrics={...this.metrics,...e}}async checkCloudUpdates(){this.lastFullSync&&Date.now()-this.lastFullSync.getTime()>30*60*1e3&&await this.performFullSync()}async getCurrentNetworkInfo(){return"connection"in navigator?navigator.connection:{online:navigator.onLine}}async getCurrentDeviceInfo(){return{userAgent:navigator.userAgent,platform:navigator.platform,language:navigator.language}}notifyStatusChange(){const e=this.getCurrentStatus();this.listeners.forEach(t=>t(e))}notifyListeners(e){this.listeners.forEach(t=>t(e))}setAuthService(e){this.authService=e,e.onAuthStateChange(t=>{t.user&&this.canSync()&&this.performFullSync()})}onStatusChange(e){return this.listeners.add(e),e(this.getCurrentStatus()),()=>{this.listeners.delete(e)}}async getCurrentStatus(){const e=v.getCurrentStatus(),t=await C.getQueueStats();return{isOnline:e.isOnline,lastSyncTime:this.metrics.lastSyncTime,pendingOperations:t.totalOperations,syncInProgress:this.syncInProgress,hasConflicts:this.metrics.conflictsCount>0}}async getMetrics(){return{...this.metrics}}async forceSync(){await this.performFullSync()}async pauseSync(){C.pause(),this.syncInProgress=!0}async resumeSync(){C.resume(),this.syncInProgress=!1,this.processNextOperations()}async getDataSyncStatus(){return{currentState:S.getCurrentState(),currentSession:S.getCurrentSession(),metrics:S.getMetrics()}}async getDataConsistencyReport(e){return await S.getDetailedConsistencyReport(e)}async performDataValidation(e){return await S.manualValidation(e)}async getBatchPerformanceMetrics(){return S.getBatchPerformanceMetrics()}configureDataValidation(e){S.configureValidation(e)}configureBatchOptimization(e){S.configureBatchOptimization(e)}async forceDataSync(e){return await S.forceSync(e)}};const J=new j,A=d=>J.addOperation(d),ve=(d,e)=>{switch(d){case"create":return A({type:"create",entity:"folder",entityId:e.id,data:e,priority:"normal",metadata:{source:"user"}});case"update":return A({type:"update",entity:"folder",entityId:e.id,data:{...e.updates,id:e.id},priority:"normal",metadata:{source:"user"}});case"delete":return A({type:"delete",entity:"folder",entityId:e.id,data:e,priority:"high",metadata:{source:"user"}});case"toggle":return A({type:"update",entity:"folder",entityId:e.id,data:{id:e.id,isExpanded:e.isExpanded},priority:"low",metadata:{source:"user"}})}},Q=Object.freeze(Object.defineProperty({__proto__:null,UnifiedSyncService:j,addSyncOperation:A,triggerFolderSync:ve,unifiedSyncService:J},Symbol.toStringTag,{value:"Module"})),Ce={checkInterval:5e3,qualityCheckInterval:3e4,qualityThresholds:{excellent:{rtt:100,downlink:10},good:{rtt:200,downlink:5},fair:{rtt:500,downlink:1},poor:{rtt:1e3,downlink:.1}},reconnect:{maxAttempts:10,initialDelay:1e3,maxDelay:3e4,backoffMultiplier:2},healthCheck:{enabled:!0,endpoints:["https://www.google.com","https://www.cloudflare.com","https://www.github.com"],timeout:5e3,successThreshold:2},eventFilter:{minQualityChange:.1,debounceTime:1e3}};class ke{config;currentState;isMonitoring=!1;checkTimer=null;qualityTimer=null;reconnectTimer=null;debounceTimer=null;listeners=new Set;stats;startTime;lastOnlineTime;lastOfflineTime;history=[];maxHistoryLength=100;connection;connectionTypes=["wifi","cellular","ethernet","bluetooth","wimax","other","none"];reconnectAttempts=0;isReconnecting=!1;constructor(e={}){this.config={...Ce,...e},this.currentState=this.getInitialNetworkState(),this.stats=this.getInitialStats(),this.startTime=new Date,this.initialize()}initialize(){"connection"in navigator&&(this.connection=navigator.connection),window.addEventListener("online",this.handleOnline.bind(this)),window.addEventListener("offline",this.handleOffline.bind(this)),this.connection&&this.connection.addEventListener("change",this.handleConnectionChange.bind(this))}getInitialNetworkState(){return{online:navigator.onLine,connectionType:this.getConnectionType(),effectiveType:this.getEffectiveType(),downlink:this.connection?.downlink,rtt:this.connection?.rtt,saveData:this.connection?.saveData,deviceMemory:navigator.deviceMemory,hardwareConcurrency:navigator.hardwareConcurrency,timestamp:new Date}}getInitialStats(){return{connectionChanges:0,onlineTime:0,offlineTime:0,averageQuality:0,qualityHistory:[],averageRtt:0,averageDownlink:0,errorCount:0,reconnectAttempts:0,successfulReconnects:0}}startMonitoring(){this.isMonitoring||(this.isMonitoring=!0,this.startPeriodicChecks(),this.emitEvent({type:"connection-change",timestamp:new Date,currentState:this.currentState,details:{action:"monitoring_started"}}))}stopMonitoring(){this.isMonitoring&&(this.isMonitoring=!1,this.stopPeriodicChecks(),this.emitEvent({type:"connection-change",timestamp:new Date,currentState:this.currentState,details:{action:"monitoring_stopped"}}))}getCurrentState(){return{...this.currentState}}getNetworkQuality(){return this.calculateQuality(this.currentState)}getNetworkQualityScore(){return this.calculateQualityScore(this.currentState)}getStats(){return{...this.stats}}async checkNetwork(){const e=await this.getCurrentNetworkInfo();return await this.updateNetworkState(e),e}async performHealthCheck(){if(!this.config.healthCheck.enabled)return this.currentState.online;try{const e=this.config.healthCheck.endpoints.map(r=>this.pingEndpoint(r,this.config.healthCheck.timeout)),i=(await Promise.allSettled(e)).filter(r=>r.status==="fulfilled"&&r.value).length,s=i>=this.config.healthCheck.successThreshold;return console.log(`Health check: ${i}/${this.config.healthCheck.endpoints.length} successful`),s}catch(e){return console.error("Health check failed:",e),!1}}addEventListener(e){this.listeners.add(e)}removeEventListener(e){this.listeners.delete(e)}emitEvent(e){this.config.eventFilter.debounceTime>0?(this.debounceTimer&&clearTimeout(this.debounceTimer),this.debounceTimer=setTimeout(()=>{this.listeners.forEach(t=>{try{t(e)}catch(i){console.error("Error in network event listener:",i)}})},this.config.eventFilter.debounceTime)):this.listeners.forEach(t=>{try{t(e)}catch(i){console.error("Error in network event listener:",i)}})}async handleOnline(){console.log("Network online event detected");const e={...this.currentState};this.currentState.online=!0,this.currentState.lastChange=new Date,this.lastOnlineTime=new Date,this.updateHistory(),this.lastOfflineTime&&(this.stats.offlineTime+=Date.now()-this.lastOfflineTime.getTime(),this.lastOfflineTime=void 0),this.stopReconnectAttempts(),this.emitEvent({type:"online",timestamp:new Date,previousState:e,currentState:this.currentState}),await this.checkNetwork()}handleOffline(){console.log("Network offline event detected");const e={...this.currentState};this.currentState.online=!1,this.currentState.lastChange=new Date,this.lastOfflineTime=new Date,this.updateHistory(),this.lastOnlineTime&&(this.stats.onlineTime+=Date.now()-this.lastOnlineTime.getTime()),this.emitEvent({type:"offline",timestamp:new Date,previousState:e,currentState:this.currentState}),this.startReconnectAttempts()}async handleConnectionChange(){console.log("Network connection change detected");const e={...this.currentState},t=await this.getCurrentNetworkInfo();Math.abs(this.calculateQualityScore(t)-this.calculateQualityScore(e))>=this.config.eventFilter.minQualityChange&&(this.currentState=t,this.currentState.lastChange=new Date,this.updateHistory(),this.stats.connectionChanges++,this.emitEvent({type:"connection-change",timestamp:new Date,previousState:e,currentState:this.currentState}))}async updateNetworkState(e){const t={...this.currentState},i=Math.abs(this.calculateQualityScore(e)-this.calculateQualityScore(t));i>=this.config.eventFilter.minQualityChange&&(this.currentState=e,this.currentState.lastChange=new Date,this.updateHistory(),this.updateQualityHistory(),this.emitEvent({type:"quality-change",timestamp:new Date,previousState:t,currentState:this.currentState,details:{qualityChange:i,previousQuality:this.calculateQuality(t),currentQuality:this.calculateQuality(e)}}))}startPeriodicChecks(){this.checkTimer=setInterval(async()=>{this.isMonitoring&&await this.checkNetwork()},this.config.checkInterval),this.qualityTimer=setInterval(async()=>{this.isMonitoring&&await this.performQualityCheck()},this.config.qualityCheckInterval)}stopPeriodicChecks(){this.checkTimer&&(clearInterval(this.checkTimer),this.checkTimer=null),this.qualityTimer&&(clearInterval(this.qualityTimer),this.qualityTimer=null)}async performQualityCheck(){try{!await this.performHealthCheck()&&this.currentState.online&&(console.warn("Network appears online but health check failed"),this.currentState.online=!1,this.currentState.lastChange=new Date,this.updateHistory(),this.emitEvent({type:"error",timestamp:new Date,currentState:this.currentState,details:{message:"Health check failed despite online status"}}))}catch(e){console.error("Quality check failed:",e),this.stats.errorCount++}}startReconnectAttempts(){this.isReconnecting||(this.isReconnecting=!0,this.reconnectAttempts=0,this.scheduleReconnectAttempt())}stopReconnectAttempts(){this.isReconnecting=!1,this.reconnectTimer&&(clearTimeout(this.reconnectTimer),this.reconnectTimer=null)}scheduleReconnectAttempt(){if(!this.isReconnecting||this.reconnectAttempts>=this.config.reconnect.maxAttempts){this.isReconnecting=!1;return}const e=Math.min(this.config.reconnect.initialDelay*Math.pow(this.config.reconnect.backoffMultiplier,this.reconnectAttempts),this.config.reconnect.maxDelay);this.reconnectTimer=setTimeout(async()=>{this.reconnectAttempts++,this.stats.reconnectAttempts++,console.log(`Reconnect attempt ${this.reconnectAttempts}/${this.config.reconnect.maxAttempts}`);try{if(navigator.onLine&&await this.performHealthCheck()){this.stats.successfulReconnects++,this.isReconnecting=!1,console.log("Reconnect successful"),this.emitEvent({type:"online",timestamp:new Date,currentState:this.currentState,details:{reconnectAttempts:this.reconnectAttempts}}),await this.handleOnline();return}}catch(t){console.error("Reconnect attempt failed:",t)}this.scheduleReconnectAttempt()},e)}async getCurrentNetworkInfo(){const e=this.getInitialNetworkState();if(this.config.healthCheck.enabled)try{const t=await this.performHealthCheck();e.online=t&&navigator.onLine}catch(t){console.warn("Health check failed, using navigator.onLine:",t)}if(e.online)try{const t=await this.getEnhancedNetworkInfo();return{...e,...t}}catch(t){console.warn("Enhanced network info failed, using basic info:",t)}return e}getConnectionType(){if(!this.connection)return"none";const e=this.connection.type;return this.connectionTypes.includes(e)?e:"other"}getEffectiveType(){if(!this.connection)return"unknown";const e=this.connection.effectiveType;return["4g","3g","2g","slow-2g"].includes(e)?e:"unknown"}calculateQuality(e){const t=this.calculateQualityScore(e);return t>=.8?"excellent":t>=.6?"good":t>=.4?"fair":t>=.2?"poor":"offline"}calculateQualityScore(e){if(!e.online)return 0;let t=.5;return e.rtt!==void 0&&(e.rtt<=100?t+=.3:e.rtt<=200?t+=.2:e.rtt<=500&&(t+=.1)),e.downlink!==void 0&&(e.downlink>=10?t+=.3:e.downlink>=5?t+=.2:e.downlink>=1&&(t+=.1)),(e.connectionType==="wifi"||e.connectionType==="ethernet")&&(t+=.1),e.saveData&&(t-=.1),Math.max(0,Math.min(1,t))}updateHistory(){const e={...this.currentState};this.history.push(e),this.history.length>this.maxHistoryLength&&this.history.shift()}updateQualityHistory(){const e=this.getNetworkQuality(),t=this.getNetworkQualityScore();this.stats.qualityHistory.push({timestamp:new Date,quality:e,score:t}),this.stats.qualityHistory.length>100&&(this.stats.qualityHistory=this.stats.qualityHistory.slice(-100));const i=this.stats.qualityHistory.slice(-20);i.length>0&&(this.stats.averageQuality=i.reduce((s,r)=>s+r.score,0)/i.length)}async pingEndpoint(e,t){try{const i=new AbortController,s=setTimeout(()=>i.abort(),t),r=performance.now(),n=await fetch(`${e}/favicon.ico`,{method:"HEAD",signal:i.signal,mode:"no-cors",headers:{"Cache-Control":"no-cache",Pragma:"no-cache"}});clearTimeout(s);const a=performance.now()-r;return this.recordResponseTime(a),!0}catch(i){return this.recordError("ping_failed",{endpoint:e,error:i instanceof Error?i.message:String(i)}),!1}}recordResponseTime(e){this.stats.averageRtt===0?this.stats.averageRtt=e:this.stats.averageRtt=this.stats.averageRtt*.8+e*.2,this.stats.qualityHistory.push({timestamp:new Date,quality:this.calculateQuality(this.currentState),score:this.calculateQualityScore(this.currentState)}),this.stats.qualityHistory.length>100&&(this.stats.qualityHistory=this.stats.qualityHistory.slice(-50))}recordError(e,t){this.stats.errorCount++,this.stats.lastError=new Error(`${e}: ${JSON.stringify(t)}`),this.emitEvent({type:"error",timestamp:new Date,currentState:this.currentState,details:{type:e,details:t}})}async getEnhancedNetworkInfo(){const e=await this.getCurrentNetworkInfo(),t=await this.performQualityAnalysis();return{...e,...t}}async performQualityAnalysis(){const e={};try{const t=await this.measureDownloadSpeed();t>0&&(e.downlink=t);const i=await this.measureLatency();i>0&&(e.rtt=i);const s=await this.measureJitter();s>0&&(e.jitter=s);const r=await this.estimatePacketLoss();r>=0&&(this.stats.packetLoss=r)}catch(t){console.warn("Quality analysis failed:",t)}return e}async measureDownloadSpeed(){try{const e=new Array(1024).fill("test").join(""),t=`data:text/plain;base64,${btoa(e)}`,i=performance.now();await(await fetch(t)).text();const r=performance.now()-i;return e.length/1024/(r/1e3)*8/1024}catch{return 0}}async measureLatency(){try{const e=[];for(let t=0;t<3;t++){const i=performance.now();await fetch("https://www.google.com/favicon.ico",{method:"HEAD",mode:"no-cors",signal:AbortSignal.timeout(3e3)}),e.push(performance.now()-i)}return e.reduce((t,i)=>t+i,0)/e.length}catch{return 0}}async measureJitter(){try{const e=[];for(let s=0;s<5;s++){const r=performance.now();await fetch("https://www.cloudflare.com/favicon.ico",{method:"HEAD",mode:"no-cors",signal:AbortSignal.timeout(2e3)}),e.push(performance.now()-r)}const t=e.reduce((s,r)=>s+r,0)/e.length,i=e.reduce((s,r)=>s+Math.pow(r-t,2),0)/e.length;return Math.sqrt(i)}catch{return 0}}async estimatePacketLoss(){try{let t=0;const i=Array(10).fill(0).map(async()=>{try{await fetch("https://www.github.com/favicon.ico",{method:"HEAD",mode:"no-cors",signal:AbortSignal.timeout(1e3)}),t++}catch{}});return await Promise.allSettled(i),1-t/10}catch{return 0}}async predictNetworkStability(){const e=this.stats.qualityHistory.slice(-10);if(e.length<5)return{isStable:this.currentState.online,confidence:.5,predictedDuration:300,recommendations:["需要更多数据来进行准确预测"]};const t=this.analyzeQualityTrend(e),i=this.calculateStabilityScore(e),s=i>.7&&t!=="degrading",r=Math.min(i,e.length/10),n=this.generateNetworkRecommendations(t,i);return{isStable:s,confidence:r,predictedDuration:this.predictStableDuration(i),recommendations:n}}analyzeQualityTrend(e){if(e.length<3)return"stable";const t=e.slice(-3).map(a=>a.score),i=e.slice(-6,-3).map(a=>a.score),s=t.reduce((a,o)=>a+o,0)/t.length,r=i.reduce((a,o)=>a+o,0)/i.length,n=s-r;return n>.1?"improving":n<-.1?"degrading":"stable"}calculateStabilityScore(e){if(e.length===0)return 0;const t=e.map(n=>n.score),i=t.reduce((n,a)=>n+a,0)/t.length,s=t.reduce((n,a)=>n+Math.pow(a-i,2),0)/t.length,r=Math.sqrt(s);return Math.max(0,1-r/i)}generateNetworkRecommendations(e,t){const i=[];return e==="degrading"?(i.push("网络质量正在下降，建议检查网络连接"),t<.5&&i.push("网络连接不稳定，建议切换到更稳定的网络")):e==="improving"&&i.push("网络质量正在改善"),t>.8?i.push("网络连接稳定，可以进行大量数据同步"):t<.5&&i.push("建议启用数据压缩和离线模式"),i}predictStableDuration(e){return e>.9?3600:e>.7?1800:e>.5?600:300}getNetworkStats(){return{...this.stats,uptime:this.lastOnlineTime?Date.now()-this.lastOnlineTime.getTime():0,downtime:this.lastOfflineTime?Date.now()-this.lastOfflineTime.getTime():0}}getNetworkHistory(){return[...this.history]}getSyncRecommendations(){const e=this.calculateQuality(this.currentState),t=[];switch(e){case"excellent":t.push("可以进行大规模同步操作"),t.push("适合上传大文件");break;case"good":t.push("可以进行常规同步操作");break;case"fair":t.push("建议进行小批量同步"),t.push("避免上传大文件");break;case"poor":t.push("建议暂停同步操作"),t.push("等待网络改善");break;case"offline":t.push("当前离线，无法同步"),t.push("检查网络连接");break}return t}onNetworkChange(e){return this.listeners.add(e),()=>{this.listeners.delete(e)}}async testConnection(e){const t=e||"https://www.google.com";try{const i=new AbortController,s=setTimeout(()=>i.abort(),5e3),r=await fetch(t,{method:"HEAD",signal:i.signal});return clearTimeout(s),r.ok}catch{return!1}}updateConfig(e){if(e.checkInterval&&e.checkInterval<1e3)throw new Error("检查间隔不能小于1000ms");if(e.qualityCheckInterval&&e.qualityCheckInterval<5e3)throw new Error("质量检查间隔不能小于5000ms");this.config={...this.config,...e},this.isMonitoring&&(this.stopPeriodicChecks(),this.startPeriodicChecks())}async measureBandwidth(){try{const e=performance.now(),t=await fetch("https://www.google.com",{method:"GET",cache:"no-cache"}),i=performance.now();if(t.ok){const s=(i-e)/1e3;return s>0?1/s:0}return 0}catch{return 0}}notifyListeners(e){this.listeners.forEach(t=>{try{t(e)}catch(i){console.error("Error in network event listener:",i)}})}destroy(){this.stopMonitoring(),window.removeEventListener("online",this.handleOnline.bind(this)),window.removeEventListener("offline",this.handleOffline.bind(this)),this.connection&&this.connection.removeEventListener("change",this.handleConnectionChange.bind(this)),this.debounceTimer&&clearTimeout(this.debounceTimer)}}const b=new ke;class I{static instance;currentState;syncStrategy;listeners=new Set;circuitBreakers=new Map;pendingRequests=new Map;batchTimer=null;isProcessing=!1;stats={totalRequests:0,successfulRequests:0,failedRequests:0,averageResponseTime:0,lastError:null,circuitBreakerTrips:0};networkHistory=[];constructor(){this.currentState=this.getInitialState(),this.syncStrategy=this.getDefaultStrategy(),this.initialize()}static getInstance(){return I.instance||(I.instance=new I),I.instance}getInitialState(){const e=b.getCurrentState();return{isOnline:e.online,isReliable:this.calculateReliability(e),quality:b.getNetworkQuality(),qualityScore:b.getNetworkQualityScore(),connectionType:e.connectionType,effectiveType:e.effectiveType,downlink:e.downlink,rtt:e.rtt,canSync:this.canPerformSync(e),syncStrategy:this.getDefaultStrategy(),estimatedSyncTime:this.estimateSyncTime(e),lastUpdated:new Date}}getDefaultStrategy(){return{batchSize:10,batchDelay:1e3,connectTimeout:5e3,requestTimeout:3e4,totalTimeout:12e4,maxRetries:3,retryDelay:1e3,retryBackoffMultiplier:2,compressionEnabled:!0,prioritySyncEnabled:!0,backgroundSyncEnabled:!0,circuitBreakerEnabled:!0,failureThreshold:5,recoveryTimeout:6e4}}initialize(){b.addEventListener(this.handleNetworkEvent.bind(this)),this.initializeCircuitBreakers(),this.initializeRequestQueues(),this.startPeriodicChecks(),console.log("NetworkStateDetector initialized")}initializeCircuitBreakers(){["read","write","delete","batch"].forEach(t=>{const i={failureThreshold:this.syncStrategy.failureThreshold,recoveryTimeout:this.syncStrategy.recoveryTimeout,expectedException:["timeout","connection_lost","network_slow"]};this.circuitBreakers.set(t,{status:{state:"closed",failureCount:0,config:i}})})}initializeRequestQueues(){["critical","high","normal","low","background"].forEach(t=>{this.pendingRequests.set(t,[])})}startPeriodicChecks(){setInterval(()=>{this.updateNetworkState()},3e4),setInterval(()=>{this.updateSyncStrategy()},3e5)}handleNetworkEvent(e){switch(console.log("Network event detected:",e.type),this.updateNetworkState(),e.type){case"online":this.handleNetworkRestored();break;case"offline":this.handleNetworkLost();break;case"quality-change":this.handleQualityChange(e);break;case"error":this.handleNetworkError(e);break}}async updateNetworkState(){try{const e=await b.checkNetwork(),t=await b.performHealthCheck(),i={isOnline:e.online&&t,isReliable:this.calculateReliability(e),quality:b.getNetworkQuality(),qualityScore:b.getNetworkQualityScore(),connectionType:e.connectionType,effectiveType:e.effectiveType,downlink:e.downlink,rtt:e.rtt,canSync:this.canPerformSync(e)&&t,syncStrategy:this.syncStrategy,estimatedSyncTime:this.estimateSyncTime(e),lastUpdated:new Date,lastStableTime:e.online?new Date:this.currentState.lastStableTime};this.hasSignificantChange(this.currentState,i)&&(this.currentState=i,this.notifyStateChanged(),i.isOnline&&i.isReliable&&this.processPendingRequests())}catch(e){console.error("Failed to update network state:",e)}}updateSyncStrategy(){const e=this.calculateOptimalStrategy();this.hasStrategyChanged(this.syncStrategy,e)&&(this.syncStrategy=e,this.currentState.syncStrategy=e,this.notifyStrategyChanged())}calculateOptimalStrategy(){const e=this.currentState.quality;this.currentState.qualityScore;const t={...this.getDefaultStrategy()};switch(e){case"excellent":return{...t,batchSize:50,batchDelay:500,requestTimeout:1e4,retryDelay:500,compressionEnabled:!1};case"good":return{...t,batchSize:25,batchDelay:1e3,requestTimeout:2e4,retryDelay:1e3};case"fair":return{...t,batchSize:10,batchDelay:2e3,requestTimeout:3e4,compressionEnabled:!0};case"poor":return{...t,batchSize:5,batchDelay:5e3,requestTimeout:6e4,maxRetries:5,retryDelay:2e3,compressionEnabled:!0};default:return{...t,batchSize:1,batchDelay:1e4,requestTimeout:12e4,maxRetries:10,compressionEnabled:!0}}}calculateReliability(e){if(!e.online)return!1;const t=this.calculateReliabilityFactors(e);return this.calculateOverallReliabilityScore(t)>=.6}calculateReliabilityFactors(e){const t=e.online?1:0;let i=1;e.rtt&&(e.rtt<=100?i=1:e.rtt<=300?i=.8:e.rtt<=1e3?i=.6:e.rtt<=2e3?i=.3:i=.1);let s=.5;e.downlink&&(e.downlink>=10?s=1:e.downlink>=5?s=.8:e.downlink>=1?s=.6:e.downlink>=.5?s=.4:s=.2);const r=this.calculateNetworkStability(),a={ethernet:1,wifi:.9,"5g":.8,"4g":.7,"3g":.4,"2g":.2,unknown:.3}[e.connectionType]||.3;return{connectivity:t,latency:i,bandwidth:s,stability:r,connectionType:a}}calculateOverallReliabilityScore(e){const t={connectivity:.3,latency:.25,bandwidth:.2,stability:.15,connectionType:.1};return e.connectivity*t.connectivity+e.latency*t.latency+e.bandwidth*t.bandwidth+e.stability*t.stability+e.connectionType*t.connectionType}calculateNetworkStability(){const e=Date.now(),t=5*60*1e3,i=this.networkHistory.filter(s=>e-s.timestamp.getTime()<t).length;return i===0?1:i<=2?.8:i<=5?.6:i<=10?.4:.2}canPerformSync(e){return e.online?b.getNetworkQualityScore()>=.3:!1}estimateSyncTime(e){if(!e.online)return 1/0;const t=1e3,i=e.rtt?Math.max(1,e.rtt/100):1,s=e.downlink?Math.max(.5,5/e.downlink):2;return t*i*s}predictNetworkStability(e=30){const t=Date.now(),i=e*60*1e3,s=this.networkHistory.filter(h=>t-h.timestamp.getTime()<=i);if(s.length<5)return{isStable:!0,confidence:.3,predictedDowntime:0,recommendations:["数据不足，建议监控网络状态"]};const n=1-s.filter(h=>!h.networkInfo.online).length/s.length,a=this.calculateOnlineDurations(s),o=a.reduce((h,g)=>h+g,0)/a.length||0,c=this.predictDowntime(s,i),l=this.generateNetworkRecommendations(n,o,c);return{isStable:n>=.8,confidence:Math.min(n,.9),predictedDowntime:c,recommendations:l}}calculateOnlineDurations(e){const t=[];let i=null;for(const s of e)s.networkInfo.online&&i===null?i=s.timestamp.getTime():!s.networkInfo.online&&i!==null&&(t.push(s.timestamp.getTime()-i),i=null);return i!==null&&t.push(Date.now()-i),t}predictDowntime(e,t){const i=e.filter(o=>!o.networkInfo.online);if(i.length===0)return 0;const s=[];let r=null;for(const o of e)!o.networkInfo.online&&r===null?r=o.timestamp.getTime():o.networkInfo.online&&r!==null&&(s.push(o.timestamp.getTime()-r),r=null);if(s.length===0)return 0;const n=s.reduce((o,c)=>o+c,0)/s.length,a=i.length/(t/(60*1e3));return n*a}generateNetworkRecommendations(e,t,i){const s=[];return e<.6&&(s.push("网络连接不稳定，建议切换到更稳定的网络"),s.push("建议启用离线模式")),t<5*60*1e3&&s.push("网络连接持续时间短，建议检查网络设备"),i>10*60*1e3&&s.push("预计网络中断时间较长，建议提前完成重要操作"),e>=.9&&t>30*60*1e3&&s.push("网络状态良好，适合进行大规模同步操作"),s}hasSignificantChange(e,t){return e.isOnline!==t.isOnline||e.isReliable!==t.isReliable||e.quality!==t.quality||Math.abs(e.qualityScore-t.qualityScore)>.1||e.canSync!==t.canSync}hasStrategyChanged(e,t){return e.batchSize!==t.batchSize||e.requestTimeout!==t.requestTimeout||e.compressionEnabled!==t.compressionEnabled||e.maxRetries!==t.maxRetries}handleNetworkRestored(){console.log("Network restored, processing pending requests..."),this.resetAllCircuitBreakers(),this.processPendingRequests()}handleNetworkLost(){console.log("Network lost, pausing sync operations..."),this.batchTimer&&(clearTimeout(this.batchTimer),this.batchTimer=null)}handleQualityChange(e){console.log("Network quality changed:",e.details),this.updateSyncStrategy()}handleNetworkError(e){const t={type:"network_slow",message:"Network quality degraded",timestamp:new Date,details:e.details};this.notifyError(t,"quality_degradation")}checkCircuitBreaker(e){const t=this.circuitBreakers.get(e);if(!t||!this.syncStrategy.circuitBreakerEnabled)return!0;const i=t.status;return i.state==="open"?Date.now()>=(i.nextAttemptTime?.getTime()||0)?(i.state="half_open",console.log(`Circuit breaker for ${e} moved to half-open state`),!0):!1:i.state!=="open"}recordSuccess(e){const t=this.circuitBreakers.get(e);if(!t)return;const i=t.status;i.failureCount=0,i.state="closed",t.timer&&(clearTimeout(t.timer),t.timer=void 0)}recordFailure(e,t){const i=this.circuitBreakers.get(e);if(!i||!this.syncStrategy.circuitBreakerEnabled)return;const s=i.status,r=s.config;r.expectedException&&!r.expectedException.includes(t.type)||(s.failureCount++,s.lastFailureTime=new Date,s.failureCount>=r.failureThreshold&&(s.state="open",s.nextAttemptTime=new Date(Date.now()+r.recoveryTimeout),this.stats.circuitBreakerTrips++,console.log(`Circuit breaker for ${e} tripped: ${s.failureCount} failures`),i.timer&&clearTimeout(i.timer),i.timer=setTimeout(()=>{s.state="half_open",console.log(`Circuit breaker for ${e} moved to half-open state`)},r.recoveryTimeout)))}resetCircuitBreaker(e){const t=this.circuitBreakers.get(e);if(!t)return;const i=t.status;i.failureCount=0,i.state="closed",i.lastFailureTime=void 0,i.nextAttemptTime=void 0,t.timer&&(clearTimeout(t.timer),t.timer=void 0)}resetAllCircuitBreakers(){this.circuitBreakers.forEach((e,t)=>{this.resetCircuitBreaker(t)})}async addSyncRequest(e){if(this.stats.totalRequests++,!this.currentState.canSync){const s={type:"connection_lost",message:"Network not available for sync",timestamp:new Date};return this.stats.failedRequests++,{success:!1,error:s,duration:0,retryCount:0,networkState:this.currentState}}const t=e.type==="batch"?"batch":e.type;if(!this.checkCircuitBreaker(t)){const s={type:"rate_limited",message:"Circuit breaker is open",timestamp:new Date};return this.stats.failedRequests++,{success:!1,error:s,duration:0,retryCount:0,networkState:this.currentState}}const i=this.pendingRequests.get(e.priority);return i.push(e),e.priority==="critical"||i.length>=this.syncStrategy.batchSize?await this.processPriorityQueue(e.priority):this.batchTimer||(this.batchTimer=setTimeout(()=>{this.processAllQueues()},this.syncStrategy.batchDelay)),{success:!0,duration:0,retryCount:0,networkState:this.currentState}}async processPriorityQueue(e){if(this.isProcessing)return;this.isProcessing=!0;const t=this.pendingRequests.get(e);if(t.length===0){this.isProcessing=!1;return}const i=Math.min(t.length,this.syncStrategy.batchSize),s=t.splice(0,i);try{await this.executeBatchRequests(s)}catch(r){console.error("Failed to process batch requests:",r)}finally{this.isProcessing=!1}}async processAllQueues(){if(this.isProcessing)return;this.isProcessing=!0,this.batchTimer=null;const e=["critical","high","normal","low","background"];try{for(const t of e)this.pendingRequests.get(t).length>0&&await this.processPriorityQueue(t)}catch(t){console.error("Failed to process request queues:",t)}finally{this.isProcessing=!1}}async processPendingRequests(){this.currentState.canSync&&!this.isProcessing&&await this.processAllQueues()}async executeBatchRequests(e){for(const t of e)try{const i=await this.executeRequest(t);this.notifySyncCompleted(t,i),i.success?(this.recordSuccess(t.type),this.stats.successfulRequests++):(this.recordFailure(t.type,i.error),this.stats.failedRequests++,this.stats.lastError=i.error)}catch(i){const s={type:"server_error",message:i instanceof Error?i.message:"Unknown error",timestamp:new Date};this.recordFailure(t.type,s),this.stats.failedRequests++,this.stats.lastError=s,this.notifySyncCompleted(t,{success:!1,error:s,duration:0,retryCount:0,networkState:this.currentState})}}async executeRequest(e){const t=Date.now();return await new Promise(i=>setTimeout(i,100)),{success:!0,data:{id:e.id,processed:!0},duration:Date.now()-t,retryCount:e.retryCount,networkState:this.currentState}}addListener(e){this.listeners.add(e)}removeListener(e){this.listeners.delete(e)}notifyStateChanged(){this.listeners.forEach(e=>{try{e.onNetworkStateChanged(this.currentState)}catch(t){console.error("Error in network state listener:",t)}})}notifyError(e,t){this.listeners.forEach(i=>{try{i.onNetworkError(e,t)}catch(s){console.error("Error in network error listener:",s)}})}notifySyncCompleted(e,t){this.listeners.forEach(i=>{try{i.onSyncCompleted(e,t)}catch(s){console.error("Error in sync completion listener:",s)}})}notifyStrategyChanged(){this.listeners.forEach(e=>{try{e.onSyncStrategyChanged(this.syncStrategy)}catch(t){console.error("Error in sync strategy listener:",t)}})}getCurrentState(){return{...this.currentState}}getSyncStrategy(){return{...this.syncStrategy}}getCircuitBreakerStatus(e){const t=this.circuitBreakers.get(e);return t?{...t.status}:null}getStats(){return{...this.stats}}async forceUpdateNetworkState(){await this.updateNetworkState()}reset(){this.resetAllCircuitBreakers(),this.pendingRequests.forEach(e=>e.length=0),this.batchTimer&&(clearTimeout(this.batchTimer),this.batchTimer=null),this.stats={totalRequests:0,successfulRequests:0,failedRequests:0,averageResponseTime:0,lastError:null,circuitBreakerTrips:0}}}const B=I.getInstance();class O{static instance;config;isSyncing=!1;currentSession=null;operationQueue=[];sessions=new Map;conflicts=new Map;stats;syncInterval;versionInfo;eventListeners=new Map;constructor(e){this.config={enabled:!0,autoSync:!0,syncInterval:3e4,maxRetries:3,retryDelay:5e3,offlineMode:!1,networkRequirements:{minBandwidth:1e5,maxLatency:1e3,requiredStability:.8},conflictResolution:{autoResolve:!0,strategy:"newest",threshold:.8},batching:{enabled:!0,maxSize:50,maxWaitTime:1e4,priorityMode:!0},security:{encryption:!0,compression:!0,validation:!0,checksum:!0},debug:!1,logLevel:"info",...e},this.stats=this.initializeStats(),this.versionInfo=this.initializeVersionInfo(),this.initializeEventListeners()}static getInstance(e){return O.instance||(O.instance=new O(e)),O.instance}async start(){if(!this.config.enabled){this.log("Sync service is disabled");return}this.log("Starting unified sync service"),this.config.autoSync&&this.startAutoSync(),await this.recoverPendingOperations(),await this.recoverPendingConflicts(),this.log("Unified sync service started successfully")}async stop(){this.log("Stopping unified sync service"),this.syncInterval&&(clearInterval(this.syncInterval),this.syncInterval=void 0),this.currentSession&&await this.endCurrentSession("paused"),await this.saveCurrentState(),this.log("Unified sync service stopped")}async sync(e){if(this.isSyncing&&!e?.force)throw new Error("Sync already in progress");this.emit("sync:start",{options:e,timestamp:new Date});const t={type:e?.type||"incremental",direction:e?.direction||"bidirectional",entities:e?.entities||["card","folder","tag","image"],conflictResolution:this.config.conflictResolution,priority:"normal",timeout:3e5,retries:this.config.maxRetries},i=await this.startSyncSession(t);try{this.isSyncing=!0,this.currentSession=i;const s=await this.executeSync(i,e);return await this.endCurrentSession("completed"),this.updateStats(s),this.log("Sync completed successfully",s),this.emit("sync:complete",{result:s,timestamp:new Date}),s}catch(s){throw await this.endCurrentSession("failed"),this.log("Sync failed:",s),this.emit("sync:error",{error:s,timestamp:new Date}),s}finally{this.isSyncing=!1,this.currentSession=null}}async addOperation(e){const t={...e,id:this.generateOperationId(),timestamp:new Date,status:"pending",retryCount:0};return this.operationQueue.push(t),this.config.batching.enabled?await this.processBatch():await this.processOperation(t),this.log("Operation added:",t.id),t.id}getStatus(){return{isSyncing:this.isSyncing,currentSession:this.currentSession,pendingOperations:this.operationQueue.length,conflicts:this.conflicts.size,hasConflicts:this.conflicts.size>0,lastSyncTime:this.stats.lastSyncTime,lastSyncTimeMs:this.stats.lastSyncTime?.getTime(),networkStatus:B.getCurrentState(),totalSyncs:this.stats.totalSessions,successfulSyncs:this.stats.successfulSessions,failedSyncs:this.stats.failedSessions,conflictsArray:Array.from(this.conflicts.values())}}getStats(){return{...this.stats}}getConflicts(){return Array.from(this.conflicts.values())}getConflict(e){return this.conflicts.get(e)}async resolveConflict(e,t,i){const s=this.conflicts.get(e);if(!s)throw new Error(`Conflict ${e} not found`);try{return await this.applyConflictResolution(s,t,i),s.resolution=t,s.resolvedAt=new Date,s.resolvedBy="user",s.resolutionData=i,this.conflicts.delete(e),this.stats.conflicts.resolved++,this.stats.conflicts.manualResolved++,this.log("Conflict resolved:",e),!0}catch(r){return this.log("Error resolving conflict:",r),!1}}async autoResolveConflicts(){let e=0;for(const[t,i]of this.conflicts.entries())if(i.resolution==="pending"&&this.config.conflictResolution.autoResolve)try{const s=await this.suggestConflictResolution(i);s.confidence>=this.config.conflictResolution.threshold&&(await this.resolveConflict(t,s.strategy,s.data),e++)}catch(s){this.log("Error auto-resolving conflict:",s)}return this.log(`Auto-resolved ${e} conflicts`),e}async getVersionInfo(){try{const e=await this.getLocalVersions(),t=await this.getCloudVersions();return{localVersion:Math.max(...Object.values(e)),cloudVersion:Math.max(...Object.values(t)),lastSyncTime:this.versionInfo.lastSyncTime,syncHash:this.calculateSyncHash(e,t),entityVersions:{cards:e.cards,folders:e.folders,tags:e.tags,images:e.images}}}catch(e){return this.log("Error getting version info:",e),this.versionInfo}}async getEntityDeltas(e){try{const t=[],i=await this.getDatabaseChanges(e);for(const s of i){const r={id:s.id,type:s.type,operation:s.operation,version:s.version,timestamp:s.timestamp,data:s.data,hash:this.calculateDataHash(s.data)};t.push(r)}return t}catch(t){return this.log("Error getting entity deltas:",t),[]}}async startSyncSession(e){const t={id:this.generateSessionId(),startTime:new Date,status:"running",operations:[],conflicts:[],stats:{totalOperations:0,completedOperations:0,failedOperations:0,conflicts:0,resolvedConflicts:0,syncTime:0,dataSize:0,networkRequests:0},config:e};return this.sessions.set(t.id,t),this.log("Sync session started:",t.id),t}async executeSync(e,t){const i=Date.now(),s=B.getCurrentState();if(!this.isNetworkSufficient(s))throw new Error("Network conditions not sufficient for sync");const r=await this.getVersionInfo();this.versionInfo=r;let n={cards:0,folders:0,tags:0,images:0};const a=[];if(t?.type==="full"||e.config.type==="full"){const o=await this.executeFullSync(e);n=o.syncedEntities,a.push(...o.conflicts)}else{const o=await this.executeIncrementalSync(e,r);n=o.syncedEntities,a.push(...o.conflicts)}return e.stats.syncTime=Date.now()-i,e.stats.conflicts=a.length,e.stats.resolvedConflicts=a.filter(o=>o.resolution!=="pending").length,{success:!0,syncedEntities:n,conflicts:a,syncTime:e.stats.syncTime,networkStats:{bandwidthUsed:e.stats.dataSize,requestsMade:e.stats.networkRequests,averageLatency:e.stats.syncTime/e.stats.networkRequests},versionInfo:r,session:e}}async executeFullSync(e){this.log("Executing full sync");const t=await this.getAllLocalData(),i=await this.getAllCloudData();return await this.compareAndSyncData(t,i,e)}async executeIncrementalSync(e,t){this.log("Executing incremental sync");const i=await this.getEntityDeltas(t.localVersion),s=await this.getCloudEntityDeltas(t.cloudVersion);return await this.applyDeltas(i,s,e)}async processBatch(){if(!this.config.batching.enabled||this.operationQueue.length===0)return;const e=Math.min(this.config.batching.maxSize,this.operationQueue.length),t=this.operationQueue.splice(0,e);try{await Promise.all(t.map(i=>this.processOperation(i)))}catch(i){this.log("Error processing batch:",i),this.operationQueue.unshift(...t)}}async processOperation(e){if(e.status==="pending"){e.status="processing",e.lastAttempt=new Date;try{switch(e.type){case"create":await this.executeCreateOperation(e);break;case"update":await this.executeUpdateOperation(e);break;case"delete":await this.executeDeleteOperation(e);break}e.status="completed",this.log("Operation completed:",e.id)}catch(t){e.status="failed",e.error=t instanceof Error?t.message:String(t),e.retryCount<this.config.maxRetries?(e.retryCount++,e.status="retrying",e.nextAttempt=new Date(Date.now()+this.config.retryDelay*e.retryCount),this.operationQueue.push(e),this.log("Operation scheduled for retry:",e.id)):this.log("Operation failed permanently:",e.id,t)}}}async executeCreateOperation(e){switch(e.entity){case"card":await this.createCard(e.data);break;case"folder":await this.createFolder(e.data);break;case"tag":await this.createTag(e.data);break;case"image":await this.createImage(e.data);break}}async executeUpdateOperation(e){const t=await this.checkForConflict(e);if(t){await this.handleConflict(t,e);return}switch(e.entity){case"card":await this.updateCard(e.entityId,e.data);break;case"folder":await this.updateFolder(e.entityId,e.data);break;case"tag":await this.updateTag(e.entityId,e.data);break;case"image":await this.updateImage(e.entityId,e.data);break}}async executeDeleteOperation(e){switch(e.entity){case"card":await this.deleteCard(e.entityId);break;case"folder":await this.deleteFolder(e.entityId);break;case"tag":await this.deleteTag(e.entityId);break;case"image":await this.deleteImage(e.entityId);break}}async checkForConflict(e){return null}async handleConflict(e,t){if(this.conflicts.set(e.id,e),this.stats.conflicts.total++,this.config.conflictResolution.autoResolve)try{await this.autoResolveConflicts()}catch(i){this.log("Error auto-resolving conflict:",i)}}async suggestConflictResolution(e){return{strategy:"newest",confidence:.9}}async applyConflictResolution(e,t,i){switch(t){case"local":await this.applyLocalResolution(e,i);break;case"cloud":await this.applyCloudResolution(e,i);break;case"merge":await this.applyMergeResolution(e,i);break}}async applyLocalResolution(e,t){const i=t||e.localData;await this.updateEntity(e.entity,e.entityId,i)}async applyCloudResolution(e,t){const i=t||e.cloudData;await this.updateEntity(e.entity,e.entityId,i)}async applyMergeResolution(e,t){const i=t||await this.mergeData(e.localData,e.cloudData);await this.updateEntity(e.entity,e.entityId,i)}async mergeData(e,t){return{...t,...e}}async updateEntity(e,t,i){switch(e){case"card":await this.updateCard(t,i);break;case"folder":await this.updateFolder(t,i);break;case"tag":await this.updateTag(t,i);break;case"image":await this.updateImage(t,i);break}}async createCard(e){await u.cards.add(e)}async updateCard(e,t){await u.cards.update(e,t)}async deleteCard(e){await u.cards.delete(e)}async createFolder(e){await u.folders.add(e)}async updateFolder(e,t){await u.folders.update(e,t)}async deleteFolder(e){await u.folders.delete(e)}async createTag(e){await u.tags.add(e)}async updateTag(e,t){await u.tags.update(e,t)}async deleteTag(e){await u.tags.delete(e)}async createImage(e){await u.images.add(e)}async updateImage(e,t){await u.images.update(e,t)}async deleteImage(e){await u.images.delete(e)}async getAllLocalData(){const[e,t,i,s]=await Promise.all([u.cards.toArray(),u.folders.toArray(),u.tags.toArray(),u.images.toArray()]);return{cards:e,folders:t,tags:i,images:s}}async getAllCloudData(){return{cards:[],folders:[],tags:[],images:[]}}async compareAndSyncData(e,t,i){return{syncedEntities:{cards:0,folders:0,tags:0,images:0},conflicts:[]}}async applyDeltas(e,t,i){return{syncedEntities:{cards:0,folders:0,tags:0,images:0},conflicts:[]}}async getLocalVersions(){return{cards:0,folders:0,tags:0,images:0}}async getCloudVersions(){return{cards:0,folders:0,tags:0,images:0}}async getDatabaseChanges(e){return[]}async getCloudEntityDeltas(e){return[]}calculateSyncHash(e,t){return btoa(JSON.stringify({local:e,cloud:t}))}calculateDataHash(e){return btoa(JSON.stringify(e))}isNetworkSufficient(e){const t=this.config.networkRequirements;return e.bandwidth>=t.minBandwidth&&e.latency<=t.maxLatency&&e.stability>=t.requiredStability}startAutoSync(){console.log("🚫 unified-sync.service.ts 自动同步已禁用，使用 data-sync-service.ts 进行同步"),this.syncInterval&&(clearInterval(this.syncInterval),this.syncInterval=null),this.log("Auto sync disabled to prevent conflicts with data-sync-service.ts")}shouldAutoSync(){return this.config.autoSync&&this.operationQueue.length>0&&B.isOnline()}async recoverPendingOperations(){}async recoverPendingConflicts(){}async endCurrentSession(e){this.currentSession&&(this.currentSession.endTime=new Date,this.currentSession.status=e,this.log("Sync session ended:",this.currentSession.id,e))}updateStats(e){this.stats.totalSessions++,e.success?this.stats.successfulSessions++:this.stats.failedSessions++,this.stats.totalOperations+=e.session.stats.totalOperations,this.stats.successfulOperations+=e.session.stats.completedOperations,this.stats.failedOperations+=e.session.stats.failedOperations,this.stats.averageSyncTime=(this.stats.averageSyncTime*(this.stats.totalSessions-1)+e.syncTime)/this.stats.totalSessions,this.stats.totalDataTransferred+=e.networkStats.bandwidthUsed,this.stats.lastSyncTime=new Date}async saveCurrentState(){}initializeStats(){return{totalSessions:0,successfulSessions:0,failedSessions:0,totalOperations:0,successfulOperations:0,failedOperations:0,averageSyncTime:0,totalDataTransferred:0,lastSyncTime:null,conflicts:{total:0,resolved:0,autoResolved:0,manualResolved:0}}}initializeVersionInfo(){return{localVersion:0,cloudVersion:0,lastSyncTime:new Date,syncHash:"",entityVersions:{cards:0,folders:0,tags:0,images:0}}}initializeEventListeners(){}generateOperationId(){return`op_${Date.now()}_${Math.random().toString(36).substr(2,9)}`}generateSessionId(){return`session_${Date.now()}_${Math.random().toString(36).substr(2,9)}`}generateConflictId(){return`conflict_${Date.now()}_${Math.random().toString(36).substr(2,9)}`}log(e,...t){this.config.debug&&this.config.logLevel!=="none"&&console.log(`[UnifiedSync] ${e}`,...t)}on(e,t){this.eventListeners.has(e)||this.eventListeners.set(e,[]),this.eventListeners.get(e).push(t)}off(e,t){const i=this.eventListeners.get(e);if(i){const s=i.indexOf(t);s>-1&&i.splice(s,1)}}emit(e,...t){const i=this.eventListeners.get(e);i&&i.forEach(s=>{try{s(...t)}catch(r){console.error(`Error in event listener for ${e}:`,r)}})}}const T=O.getInstance();new Date().toISOString();class be{available;waiting=[];constructor(e){this.available=e}async acquire(){if(this.available>0){this.available--;return}return new Promise(e=>{this.waiting.push(e)})}release(){if(this.available++,this.waiting.length>0&&this.available>0){const e=this.waiting.shift();e&&(this.available--,e())}}}class Te{isOffline=!navigator.onLine;networkInfo={status:navigator.onLine?"online":"offline",lastChanged:new Date};offlineOperations=[];conflicts=[];offlineStartTime;syncTimer;reconnectAttempts=0;maxReconnectAttempts=10;listeners={};constructor(){this.initializeOfflineManager()}getNetworkStatus(){return{...this.networkInfo}}isCurrentlyOffline(){return this.isOffline}async getOfflineStats(){const e=await this.getPendingOfflineOperations(),t=await this.getCompletedOfflineOperations(),i=await this.getFailedOfflineOperations();return{isOffline:this.isOffline,offlineDuration:this.calculateOfflineDuration(),pendingOperations:e.length,completedOfflineOperations:t.length,failedOperations:i.length,averageResponseTime:this.calculateAverageResponseTime(),dataSyncedOnResume:this.calculateDataSyncedOnResume(),lastSyncTime:await this.getLastSyncTime(),estimatedBandwidthSaved:this.calculateEstimatedBandwidthSaved(e)}}async executeOfflineOperation(e){const t={...e,id:crypto.randomUUID(),timestamp:new Date,retryCount:0};try{e.dependencies&&e.dependencies.length>0&&await this.validateDependencies(e.dependencies);const i=await this.performLocalOperation(t);return await this.storeOfflineOperation(t),this.listeners.onOfflineOperation&&this.listeners.onOfflineOperation(t),{success:!0,data:i,operationId:t.id}}catch(i){return console.error("Offline operation failed:",i),t.priority="high",await this.storeOfflineOperation(t),{success:!1,error:i instanceof Error?i.message:String(i),operationId:t.id}}}async executeBatchOfflineOperations(e){const t=crypto.randomUUID(),i=[];try{const s=e.filter(n=>n.dependencies&&n.dependencies.length>0).flatMap(n=>n.dependencies);s.length>0&&await this.validateDependencies(s);const r=this.sortOperationsByPriority(e);for(const n of r){const a=await this.executeOfflineOperation(n);i.push(a)}return{success:i.every(n=>n.success),results:i,batchId:t}}catch(s){return console.error("Batch offline operations failed:",s),{success:!1,results:i.map(r=>({...r,success:!1,error:s instanceof Error?s.message:String(s)})),batchId:t}}}async getPendingOfflineOperations(){return await f.transaction("r",[f.syncQueue],async()=>(await f.syncQueue.where("status").equals("pending").toArray()).map(t=>this.convertSyncOperationToOfflineOperation(t)))}async retryFailedOperations(){const e=await this.getFailedOfflineOperations();let t=0;for(const i of e)try{await this.retryOperation(i),t++}catch(s){console.warn(`Failed to retry operation ${i.id}:`,s)}return t}async handleNetworkRecovery(){console.log("Network recovered, analyzing sync strategy...");const e=performance.now(),t=await this.getOfflineStats();try{const i=await this.assessNetworkQuality(),s=await this.determineSyncStrategy(t,i);console.log(`Using sync strategy: ${s.strategy}`),this.notifySyncProgress(0,t.pendingOperations);const r=await this.executeSmartSync(s,t);r.conflicts.length>0&&await this.handleConflicts(r.conflicts),await this.performPostSyncOptimizations(r,i);const n=await this.getOfflineStats();this.notifySyncComplete(n),console.log(`Smart offline sync completed in ${(performance.now()-e).toFixed(2)}ms`),console.log(`Sync results: ${r.syncedOperations} operations, ${r.conflicts.length} conflicts`)}catch(i){console.error("Smart offline sync failed:",i),await this.handleSyncError(i,t),this.listeners.onError&&this.listeners.onError(i instanceof Error?i:new Error(String(i)))}}async assessNetworkQuality(){const e=navigator.connection,t={isStable:!0,bandwidth:"good",latency:"low",reliability:.9,recommendedStrategy:"immediate"};e&&(e.downlink&&(e.downlink>=20?(t.bandwidth="excellent",t.recommendedStrategy="immediate"):e.downlink>=10?(t.bandwidth="good",t.recommendedStrategy="immediate"):e.downlink>=3?(t.bandwidth="fair",t.recommendedStrategy="batched"):e.downlink>=1?(t.bandwidth="poor",t.recommendedStrategy="conservative"):(t.bandwidth="poor",t.recommendedStrategy="prioritized")),e.rtt&&(e.rtt<=50?t.latency="low":e.rtt<=150?(t.latency="medium",t.recommendedStrategy="batched"):e.rtt<=500?(t.latency="high",t.recommendedStrategy="conservative"):(t.latency="high",t.recommendedStrategy="prioritized")),e.type==="cellular"?(t.reliability=.7,(e.effectiveType==="slow-2g"||e.effectiveType==="2g")&&(t.recommendedStrategy="conservative")):e.type==="wifi"?t.reliability=.9:e.type==="ethernet"&&(t.reliability=.95));const i=await this.testConnectionStability();t.isStable=i.isStable,t.reliability*=i.stabilityFactor,t.isStable||(t.recommendedStrategy="conservative");const s=await this.calculateHistoricalReliability();return t.reliability*=s,t}async testConnectionStability(){const e=["https://www.google.com/favicon.ico","https://www.cloudflare.com/favicon.ico"],s=(await Promise.allSettled(e.map(n=>fetch(n,{method:"HEAD",mode:"no-cors"})))).filter(n=>n.status==="fulfilled").length/e.length;return{isStable:s>=.8,stabilityFactor:s}}determineRecommendedStrategy(e){return e.isStable&&e.bandwidth==="excellent"&&e.latency==="low"?"immediate":e.reliability>=.8&&e.bandwidth!=="poor"?"batched":e.reliability>=.6?"prioritized":"conservative"}async determineSyncStrategy(e,t){return{strategy:t.recommendedStrategy,batchSize:this.calculateOptimalBatchSize(e,t),delayBetweenBatches:this.calculateBatchDelay(t),priorityFilter:this.determinePriorityFilter(e,t),maxConcurrentOperations:this.calculateMaxConcurrent(t),timeout:this.calculateOperationTimeout(t),retryStrategy:this.determineRetryStrategy(t)}}calculateOptimalBatchSize(e,t){let i=10;switch(t.bandwidth){case"excellent":i=50;break;case"good":i=30;break;case"fair":i=15;break;case"poor":i=5;break}return e.pendingOperations>100&&(i=Math.min(i,20)),i}calculateBatchDelay(e){switch(e.bandwidth){case"excellent":return 100;case"good":return 300;case"fair":return 500;case"poor":return 1e3;default:return 500}}determinePriorityFilter(e,t){return t.reliability<.7?["critical","high"]:e.pendingOperations>50?["critical","high","normal"]:["critical","high","normal","low"]}calculateMaxConcurrent(e){switch(e.latency){case"low":return e.bandwidth==="excellent"?5:3;case"medium":return 2;case"high":return 1;default:return 2}}calculateOperationTimeout(e){let t=1e4;switch(e.latency){case"high":t*=2;break;case"medium":t*=1.5;break}switch(e.bandwidth){case"poor":t*=1.5;break;case"fair":t*=1.2;break}return t}determineRetryStrategy(e){return e.isStable&&e.reliability>=.8?{maxRetries:3,initialDelay:1e3,maxDelay:5e3,backoffMultiplier:2}:{maxRetries:5,initialDelay:2e3,maxDelay:15e3,backoffMultiplier:2.5}}async executeSmartSync(e,t){const s=(await this.getPendingOfflineOperations()).filter(c=>e.priorityFilter.includes(c.priority)),r=this.createOptimalBatches(s,e.batchSize),n={success:!0,syncedOperations:0,conflicts:[],errors:[]},a=new be(e.maxConcurrentOperations),o=r.map(async(c,l)=>{await a.acquire();try{l>0&&await new Promise(g=>setTimeout(g,e.delayBetweenBatches));const h=await this.executeBatchWithRetry(c,e.retryStrategy,e.timeout);n.syncedOperations+=h.syncedCount,n.conflicts.push(...h.conflicts),n.errors.push(...h.errors),this.notifySyncProgress(n.syncedOperations,s.length)}catch(h){n.errors.push(`Batch ${l} failed: ${h}`)}finally{a.release()}});return await Promise.all(o),n.success=n.errors.length===0,n}createOptimalBatches(e,t){const i=[],s={critical:4,high:3,normal:2,low:1},r=[...e].sort((n,a)=>s[a.priority]-s[n.priority]);for(let n=0;n<r.length;n+=t)i.push(r.slice(n,n+t));return i}async executeBatchWithRetry(e,t,i){let s=null;for(let r=1;r<=t.maxRetries;r++)try{return await this.executeBatchWithTimeout(e,i)}catch(n){if(s=n instanceof Error?n:new Error(String(n)),r===t.maxRetries)break;const a=Math.min(t.initialDelay*Math.pow(t.backoffMultiplier,r-1),t.maxDelay);console.log(`Retry ${r}/${t.maxRetries} after ${a}ms`),await new Promise(o=>setTimeout(o,a))}return{syncedCount:0,conflicts:[],errors:[s?.message||"Batch execution failed after all retries"]}}async executeBatchWithTimeout(e,t){const i=new Promise((r,n)=>{setTimeout(()=>n(new Error("Operation timeout")),t)}),s=this.executeBatchOperations(e);try{return await Promise.race([s,i])}catch(r){throw r instanceof Error&&r.message==="Operation timeout"?new Error(`Batch operation timed out after ${t}ms`):r}}async executeBatchOperations(e){let t=0;const i=[],s=[];for(const r of e)try{const n=await this.syncOperation(r);n.success?t++:n.conflict?i.push(n.conflict):s.push(n.error||`Operation ${r.id} failed`)}catch(n){s.push(`Operation ${r.id} error: ${n}`)}return{syncedCount:t,conflicts:i,errors:s}}async performPostSyncOptimizations(e,t){e.success&&e.errors.length===0&&await this.cleanupOldSyncState(),t.bandwidth==="excellent"&&t.isStable&&await this.preloadRemoteData(),await this.updateNetworkHistory(t)}async handleSyncError(e,t){console.error("Sync error occurred, attempting recovery...",e),e.message?.includes("timeout")?await this.scheduleReducedSync():e.message?.includes("network")?await this.scheduleDelayedSync():await this.scheduleRetrySync()}async scheduleReducedSync(){setTimeout(async()=>{(await this.getOfflineStats()).pendingOperations>0&&(console.log("Executing reduced sync..."),await this.syncCriticalOperationsOnly())},5e3)}async scheduleDelayedSync(){setTimeout(async()=>{(await this.getOfflineStats()).pendingOperations>0&&(console.log("Executing delayed sync..."),await this.handleNetworkRecovery())},3e4)}async scheduleRetrySync(){setTimeout(async()=>{(await this.getOfflineStats()).pendingOperations>0&&(console.log("Retrying sync..."),await this.handleNetworkRecovery())},1e4)}async syncCriticalOperationsOnly(){const t=(await this.getPendingOfflineOperations()).filter(i=>i.priority==="critical");if(t.length>0){const i=await this.executeBatchOperations(t);console.log(`Critical sync completed: ${i.syncedCount}/${t.length}`)}}async cleanupOldSyncState(){try{const e=Object.keys(localStorage).filter(t=>t.startsWith("offlineBackup_")).sort();if(e.length>3&&e.slice(0,e.length-3).forEach(i=>localStorage.removeItem(i)),f.offlineState){const t=await f.offlineState.orderBy("timestamp").reverse().offset(5).toArray();for(const i of t)await f.offlineState.delete(i.id)}}catch(e){console.warn("Failed to cleanup old sync state:",e)}}async preloadRemoteData(){try{console.log("Preloading remote data...")}catch(e){console.warn("Failed to preload remote data:",e)}}async updateNetworkHistory(e){try{const t="networkQualityHistory",i=JSON.parse(localStorage.getItem(t)||"[]");i.push({timestamp:new Date().toISOString(),...e}),i.length>100&&i.splice(0,i.length-100),localStorage.setItem(t,JSON.stringify(i))}catch(t){console.warn("Failed to update network history:",t)}}async performOfflineSync(){const e=await this.getPendingOfflineOperations(),t=[],i=[],s=[],r=e.filter(l=>l.priority==="critical"),n=e.filter(l=>l.priority==="high"),a=e.filter(l=>l.priority==="normal"),o=e.filter(l=>l.priority==="low"),c=[...r,...n,...a,...o];for(let l=0;l<c.length;l++){const h=c[l];try{if(!navigator.onLine)throw new Error("Network lost during sync");const g=await this.syncOperation(h);g.success?t.push(h.id):g.conflict?i.push(g.conflict):s.push(g.error||`Sync failed for operation ${h.id}`),this.notifySyncProgress(l+1,c.length),l%10===0&&await new Promise(p=>setTimeout(p,100))}catch(g){const p=g instanceof Error?g.message:String(g);if(s.push(`Operation ${h.id} failed: ${p}`),p.includes("network")||p.includes("Network")){console.warn("Network error during sync, pausing...");break}}}return{success:s.length===0,syncedOperations:t.length,conflicts:i,errors:s}}async detectConflicts(e,t){if(!t)return null;const i=await this.getLocalDataForEntity(e.entity,e.entityId);if(!i)return null;const s=new Date(e.timestamp),r=new Date(t.updatedAt||t.createdAt);return s>r?{id:crypto.randomUUID(),entityType:e.entity,entityId:e.entityId||"",localData:i,remoteData:t,conflictType:this.determineConflictType(e,i,t),timestamp:new Date,resolution:"pending"}:null}async handleConflicts(e){for(const t of e)try{const i=await this.resolveConflict(t);i==="manual"?(this.conflicts.push(t),this.listeners.onConflict&&this.listeners.onConflict(t)):await this.applyConflictResolution(t,i)}catch(i){console.error(`Failed to resolve conflict ${t.id}:`,i),t.resolution="manual",this.conflicts.push(t)}}async resolveConflict(e){switch(e.conflictType){case"simultaneous_edit":return await this.attemptSmartMerge(e);case"delete_conflict":return"manual";case"structure_conflict":return"local";default:return"manual"}}async attemptSmartMerge(e){const t=this.extractContentForMerge(e.localData),i=this.extractContentForMerge(e.remoteData);if(this.calculateContentSimilarity(t,i)>.8){const s=new Date(e.localData.updatedAt||e.localData.createdAt),r=new Date(e.remoteData.updatedAt||e.remoteData.createdAt);return s>r?"local":"remote"}return"manual"}setEventListeners(e){this.listeners={...this.listeners,...e}}notifyNetworkChange(e){this.listeners.onNetworkChange&&this.listeners.onNetworkChange(e)}notifySyncProgress(e,t){this.listeners.onSyncProgress&&this.listeners.onSyncProgress({completed:e,total:t})}notifySyncComplete(e){this.listeners.onSyncComplete&&this.listeners.onSyncComplete(e)}initializeOfflineManager(){this.setupNetworkListeners(),this.setupConnectionMonitoring(),this.loadOfflineState(),this.startPeriodicSync()}setupNetworkListeners(){window.addEventListener("online",()=>{this.handleNetworkChange(!0)}),window.addEventListener("offline",()=>{this.handleNetworkChange(!1)})}setupConnectionMonitoring(){if("connection"in navigator){const e=navigator.connection;e.addEventListener("change",()=>{this.updateConnectionInfo(e)}),this.updateConnectionInfo(e)}}startPeriodicSync(){console.log("🚫 offline-manager.ts 定期同步已禁用，使用 data-sync-service.ts 进行同步"),this.syncTimer&&(clearInterval(this.syncTimer),this.syncTimer=null),console.log("⚠️ 离线管理器定期同步已禁用，防止服务冲突")}cleanup(){this.syncTimer&&clearInterval(this.syncTimer),window.removeEventListener("online",this.handleNetworkChange),window.removeEventListener("offline",this.handleNetworkChange)}async handleNetworkChange(e){const t=this.networkInfo.status,i=e?"online":"offline";this.isOffline=!e,this.networkInfo={...this.networkInfo,status:i,lastChanged:new Date},t==="offline"&&i==="online"?(this.reconnectAttempts=0,await this.handleNetworkRecovery()):t==="online"&&i==="offline"&&(this.offlineStartTime=new Date),this.notifyNetworkChange(this.networkInfo)}updateConnectionInfo(e){this.networkInfo={...this.networkInfo,effectiveType:e.effectiveType,downlink:e.downlink,rtt:e.rtt,saveData:e.saveData,connectionType:this.determineConnectionType(e)}}determineConnectionType(e){if(e.type)switch(e.type){case"wifi":return"wifi";case"cellular":return"cellular";case"ethernet":return"ethernet";default:return"unknown"}return e.effectiveType&&["4g","5g"].includes(e.effectiveType)?e.effectiveType==="5g"?"wifi":"cellular":"unknown"}async validateDependencies(e){const i=(await this.getPendingOfflineOperations()).map(r=>r.id),s=e.filter(r=>!i.includes(r));if(s.length>0)throw new Error(`Dependencies not found: ${s.join(", ")}`)}async performLocalOperation(e){switch(e.type){case"create":return E.createCard(e.data,e.userId);case"update":return E.updateCard(e.entityId,e.data,e.userId);case"delete":return E.deleteCard(e.entityId,e.userId);default:throw new Error(`Unsupported operation type: ${e.type}`)}}async storeOfflineOperation(e){try{await f.syncQueue.add({id:e.id,type:e.type,entity:e.entity,entityId:e.entityId,userId:e.userId,data:e.data,priority:e.priority,timestamp:e.timestamp,retryCount:e.retryCount,maxRetries:e.maxRetries,error:void 0})}catch(t){throw console.error("Failed to store offline operation:",t),t}}async syncOperation(e){try{const t=await this.fetchRemoteData(e.entity,e.entityId),i=await this.detectConflicts(e,t);return i?{success:!1,conflict:i}:(await new Promise(s=>setTimeout(s,100)),await f.syncQueue.where("id").equals(e.id).modify({status:"completed"}),{success:!0})}catch(t){return{success:!1,error:t instanceof Error?t.message:String(t)}}}async fetchRemoteData(e,t){return null}async getLocalDataForEntity(e,t){switch(e){case"card":return t?f.cards.get(t):null;case"folder":return t?f.folders.get(t):null;case"tag":return t?f.tags.get(t):null;default:return null}}determineConflictType(e,t,i){return e.type==="delete"?"delete_conflict":this.hasStructureChanged(t,i)?"structure_conflict":"simultaneous_edit"}hasStructureChanged(e,t){const i=new Set(Object.keys(e)),s=new Set(Object.keys(t));return i.size!==s.size||![...i].every(r=>s.has(r))}extractContentForMerge(e){return e.frontContent&&e.backContent?JSON.stringify({front:e.frontContent,back:e.backContent}):JSON.stringify(e)}calculateContentSimilarity(e,t){const i=this.calculateLevenshteinDistance(e,t),s=Math.max(e.length,t.length);return s>0?1-i/s:1}calculateLevenshteinDistance(e,t){const i=Array(t.length+1).fill(null).map(()=>Array(e.length+1).fill(null));for(let s=0;s<=e.length;s++)i[0][s]=s;for(let s=0;s<=t.length;s++)i[s][0]=s;for(let s=1;s<=t.length;s++)for(let r=1;r<=e.length;r++){const n=e[r-1]===t[s-1]?0:1;i[s][r]=Math.min(i[s][r-1]+1,i[s-1][r]+1,i[s-1][r-1]+n)}return i[t.length][e.length]}async applyConflictResolution(e,t){e.resolution=t}async loadOfflineState(){try{const e=await this.loadFromIndexedDB();if(e){await this.restoreOfflineState(e);return}const t=localStorage.getItem("offlineManagerState");if(t){const i=JSON.parse(t);await this.restoreOfflineState(i),await this.saveToIndexedDB(i),localStorage.removeItem("offlineManagerState")}}catch(e){console.warn("Failed to load offline state:",e)}}async saveOfflineState(){try{const e=await this.createOfflineStateSnapshot();await this.saveToIndexedDB(e),await this.saveToLocalStorage(e),await this.createIncrementalBackup(e)}catch(e){console.warn("Failed to save offline state:",e),await this.saveToLocalStorageFallback()}}async createOfflineStateSnapshot(){const e=await this.getPendingOfflineOperations(),t=this.conflicts,i=await this.getOfflineStats();return{version:this.getCurrentStateVersion(),timestamp:new Date().toISOString(),offlineStartTime:this.offlineStartTime?.toISOString(),reconnectAttempts:this.reconnectAttempts,networkInfo:this.networkInfo,pendingOperations:e.map(s=>this.serializeOfflineOperation(s)),conflicts:t.map(s=>this.serializeConflict(s)),stats:this.serializeStats(i),checksum:await this.calculateStateChecksum(e,t)}}async saveToIndexedDB(e){try{await f.transaction("rw",[f.syncQueue],async()=>{f.offlineState||await f.version(f.ver+1).stores({offlineState:"++id,version,timestamp,checksum"}),await f.offlineState?.clear(),await f.offlineState?.add({version:e.version,timestamp:new Date(e.timestamp),data:JSON.stringify(e),checksum:e.checksum,compressed:!0})})}catch(t){throw console.warn("Failed to save to IndexedDB:",t),t}}async loadFromIndexedDB(){try{if(!f.offlineState)return null;const e=await f.offlineState.orderBy("timestamp").reverse().first();if(!e)return null;if(e.compressed){const t=this.decompressData(e.data),i=JSON.parse(t);if(await this.verifyStateChecksum(i))return i}return null}catch(e){return console.warn("Failed to load from IndexedDB:",e),null}}async saveToLocalStorage(e){try{const t=this.compressData(JSON.stringify(e));localStorage.setItem("offlineManagerState",t)}catch(t){console.warn("Failed to save to localStorage:",t)}}async saveToLocalStorageFallback(){try{const e={offlineStartTime:this.offlineStartTime?.toISOString(),reconnectAttempts:this.reconnectAttempts,timestamp:new Date().toISOString()};localStorage.setItem("offlineManagerState",JSON.stringify(e))}catch(e){console.warn("Fallback save failed:",e)}}async createIncrementalBackup(e){try{const t=`offlineBackup_${Date.now()}`,i={timestamp:e.timestamp,version:e.version,pendingCount:e.pendingOperations.length,conflictsCount:e.conflicts.length,compressed:!0},s=Object.keys(localStorage).filter(r=>r.startsWith("offlineBackup_")).sort();s.length>=10&&s.slice(0,s.length-9).forEach(n=>localStorage.removeItem(n)),localStorage.setItem(t,JSON.stringify(i))}catch(t){console.warn("Failed to create incremental backup:",t)}}compressData(e){try{return btoa(encodeURIComponent(e))}catch{return e}}decompressData(e){try{return decodeURIComponent(atob(e))}catch{return e}}getCurrentStateVersion(){return`1.0.${Date.now()}`}async calculateStateChecksum(e,t){const i=JSON.stringify({operations:e.length,conflicts:t.length,timestamp:Date.now()});let s=0;for(let r=0;r<i.length;r++){const n=i.charCodeAt(r);s=(s<<5)-s+n,s=s&s}return Math.abs(s).toString(16)}async verifyStateChecksum(e){try{const t=e.pendingOperations.map(r=>this.deserializeOfflineOperation(r)),i=e.conflicts.map(r=>this.deserializeConflict(r));return await this.calculateStateChecksum(t,i)===e.checksum}catch{return!1}}async restoreOfflineState(e){if(this.offlineStartTime=e.offlineStartTime?new Date(e.offlineStartTime):void 0,this.reconnectAttempts=e.reconnectAttempts||0,e.networkInfo&&(this.networkInfo={...this.networkInfo,...e.networkInfo,lastChanged:new Date(e.networkInfo.lastChanged||Date.now())}),e.pendingOperations)try{const t=e.pendingOperations.map(i=>this.deserializeOfflineOperation(i));await this.validateAndRestoreOperations(t)}catch(t){console.warn("Failed to restore pending operations:",t)}e.conflicts&&(this.conflicts=e.conflicts.map(t=>this.deserializeConflict(t)))}serializeOfflineOperation(e){return{...e,timestamp:e.timestamp.toISOString()}}deserializeOfflineOperation(e){return{...e,timestamp:new Date(e.timestamp)}}serializeConflict(e){return{...e,timestamp:e.timestamp.toISOString()}}deserializeConflict(e){return{...e,timestamp:new Date(e.timestamp)}}serializeStats(e){return{...e,lastSyncTime:e.lastSyncTime?.toISOString()}}async validateAndRestoreOperations(e){const t=e.filter(i=>i.id&&i.type&&i.entity&&i.timestamp);for(const i of t)try{await this.storeOfflineOperation(i)}catch(s){console.warn(`Failed to restore operation ${i.id}:`,s)}}calculateOfflineDuration(){return this.offlineStartTime?Date.now()-this.offlineStartTime.getTime():0}calculateAverageResponseTime(){return 50}calculateDataSyncedOnResume(){return 0}calculateEstimatedBandwidthSaved(e){return e.length*1024}async getLastSyncTime(){try{const e=await f.syncQueue.where("status").equals("completed").orderBy("timestamp").reverse().first();return e?new Date(e.timestamp):void 0}catch{return}}async getCompletedOfflineOperations(){try{return(await f.syncQueue.where("status").equals("completed").toArray()).map(t=>this.convertSyncOperationToOfflineOperation(t))}catch{return[]}}async getFailedOfflineOperations(){try{return(await f.syncQueue.where("status").equals("failed").toArray()).map(t=>this.convertSyncOperationToOfflineOperation(t))}catch{return[]}}convertSyncOperationToOfflineOperation(e){return{id:e.id,type:e.type,entity:e.entity,entityId:e.entityId,userId:e.userId,data:e.data,priority:e.priority,timestamp:new Date(e.timestamp),retryCount:e.retryCount,maxRetries:e.maxRetries,status:e.status}}sortOperationsByPriority(e){const t={critical:4,high:3,normal:2,low:1};return[...e].sort((i,s)=>t[s.priority]-t[i.priority])}async retryOperation(e){await f.syncQueue.where("id").equals(e.id).modify({status:"pending",retryCount:e.retryCount+1})}async calculateHistoricalReliability(){try{const e=new Date(Date.now()-36e5),t=await f.syncQueue.where("timestamp").above(e).toArray();return t.length===0?1:t.filter(s=>s.status==="completed").length/t.length}catch{return .9}}async predictAndPreventConflicts(e){const t=[];for(const i of e)if(i.entityId){const s=await this.checkPotentialConflict(i);s&&t.push(s)}return t}async checkPotentialConflict(e){try{const t=await f.syncQueue.where("entity").equals(e.entity).and(r=>r.entityId===e.entityId).reverse().limit(5).toArray();if(t.length===0)return null;const i=new Date(Date.now()-5*60*1e3),s=t.filter(r=>new Date(r.timestamp)>i&&r.id!==e.id);return s.length>0?{id:crypto.randomUUID(),entityType:e.entity,entityId:e.entityId,localData:e.data,remoteData:s[0].data,conflictType:"simultaneous_edit",timestamp:new Date,resolution:"pending"}:null}catch{return null}}async generatePerformanceOptimization(){const e=await this.getOfflineStats(),t=[],i=[];return e.averageResponseTime>100&&(t.push("建议启用操作批处理以减少响应时间"),i.push(.3)),e.pendingOperations>50&&(t.push("建议增加同步频率或优化队列管理"),i.push(.4)),e.failedOperations>e.completedOfflineOperations*.1&&(t.push("建议检查网络连接并优化重试策略"),i.push(.5)),{recommendations:t,predictedImprovements:i}}async compressOfflineData(e){const t=[];let i=0,s=0;for(const r of e)if(i+=JSON.stringify(r.data).length,JSON.stringify(r.data).length>1024){const n={...r,data:await this.compressData(r.data)};t.push(n),s+=JSON.stringify(n.data).length}else t.push(r),s+=JSON.stringify(r.data).length;return{compressed:t,compressionRatio:i>0?s/i:1}}}const U=new Te;class De{isInitialized=!1;config;constructor(e){this.config={enabled:!0,autoSync:!0,syncInterval:3e4,maxRetries:3,retryDelay:5e3,offlineMode:!1,networkRequirements:{minBandwidth:1e5,maxLatency:1e3,requiredStability:.8},conflictResolution:{autoResolve:!0,strategy:"newest",threshold:.8},batching:{enabled:!0,maxSize:50,maxWaitTime:1e4,priorityMode:!0},security:{encryption:!0,compression:!0,validation:!0,checksum:!0},debug:!1,logLevel:"info",...e}}async initialize(){if(!this.isInitialized)try{await u.open(),v.getCurrentStatus().isOnline?console.log("Cloud sync service initialized successfully."):console.warn("Network is offline. Sync service initialized in offline mode."),this.isInitialized=!0}catch(e){throw console.error("Failed to initialize cloud sync service:",e),e}}async sync(e){this.isInitialized||await this.initialize();const t=Date.now(),i=e?.entities||["card","folder","tag","image"];try{if(!v.getCurrentStatus().isOnline)throw new Error("Network is offline. Cannot sync.");const r={cards:0,folders:0,tags:0,images:0},n=[];i.includes("card")&&await this.syncCards(),i.includes("folder")&&await this.syncFolders(),i.includes("tag")&&await this.syncTags(),i.includes("image")&&await this.syncImages();const a=Date.now()-t;return{syncedEntities:r,conflicts:n,syncTime:a,networkStats:{bandwidthUsed:0,requestsMade:0,averageLatency:0}}}catch(s){throw console.error("Direct sync failed:",s),s}}getStatus(){const e=v.getCurrentStatus(),t=this.getPendingOperationsCount();return{isSyncing:!1,lastSyncTime:null,pendingOperations:t,conflicts:0,networkStatus:this.convertNetworkStatus(e),syncHealth:this.calculateSyncHealth({pendingOperations:t})}}getConflicts(){return T.getConflicts().map(t=>({id:t.id,entityId:t.entityId,entityType:t.entity,conflictType:t.conflictType,localData:t.localData,cloudData:t.cloudData,timestamp:t.timestamp,resolution:t.resolution}))}async resolveConflict(e,t){try{return await T.resolveConflict(e,t)}catch(i){return console.error("Failed to resolve conflict:",i),!1}}async autoResolveConflicts(){try{return await T.autoResolveConflicts()}catch(e){return console.error("Failed to auto-resolve conflicts:",e),0}}async getVersionInfo(){try{const e=await T.getVersionInfo();return{localVersion:e.localVersion,cloudVersion:e.cloudVersion,lastSyncTime:e.lastSyncTime,syncHash:e.syncHash}}catch(e){throw console.error("Failed to get version info:",e),e}}getSyncStats(){return T.getStats()}async addSyncOperation(e){try{const t={type:e.type,entity:this.convertTableToEntity(e.table),entityId:e.localId,data:e.data,priority:"normal",metadata:{source:"user"}};return await T.addOperation(t)}catch(t){throw console.error("Failed to add sync operation:",t),t}}async startAutoSync(){this.isInitialized||await this.initialize(),console.warn("Auto sync is handled automatically by unified sync service")}async stopAutoSync(){await T.stop(),this.isInitialized=!1}checkNetworkStatus(){return v.getCurrentStatus()}getOfflineOperations(){return U.getPendingOperations()}async clearOfflineOperations(){await U.clearOperations()}async syncCards(){try{const e=await u.cards.where("pendingSync").equals(!0).toArray();for(const t of e){const{data:i,error:s}=await y.from("cards").upsert({id:t.id,user_id:t.userId,front_content:t.frontContent,back_content:t.backContent,style:t.style,folder_id:t.folderId,sync_version:t.syncVersion+1,updated_at:new Date().toISOString()}).select();if(s){console.error("Failed to sync card:",s);continue}await u.cards.update(t.id,{pendingSync:!1,syncVersion:t.syncVersion+1,lastSyncAt:new Date})}}catch(e){throw console.error("Error syncing cards:",e),e}}async syncFolders(){try{const e=await u.folders.where("pendingSync").equals(!0).toArray();for(const t of e){const{data:i,error:s}=await y.from("folders").upsert({id:t.id,user_id:t.userId,name:t.name,parent_id:t.parentId,sync_version:t.syncVersion+1,updated_at:new Date().toISOString()}).select();if(s){console.error("Failed to sync folder:",s);continue}await u.folders.update(t.id,{pendingSync:!1,syncVersion:t.syncVersion+1,lastSyncAt:new Date})}}catch(e){throw console.error("Error syncing folders:",e),e}}async syncTags(){try{const e=await u.tags.where("pendingSync").equals(!0).toArray();for(const t of e){const{data:i,error:s}=await y.from("tags").upsert({id:t.id,user_id:t.userId,name:t.name,color:t.color,sync_version:t.syncVersion+1,updated_at:new Date().toISOString()}).select();if(s){console.error("Failed to sync tag:",s);continue}await u.tags.update(t.id,{pendingSync:!1,syncVersion:t.syncVersion+1,lastSyncAt:new Date})}}catch(e){throw console.error("Error syncing tags:",e),e}}async syncImages(){try{const e=await u.images.where("pendingSync").equals(!0).toArray();for(const t of e){const{data:i,error:s}=await y.from("images").upsert({id:t.id,user_id:t.userId,card_id:t.cardId,file_name:t.fileName,file_path:t.filePath,cloud_url:t.cloudUrl,metadata:t.metadata,sync_version:t.syncVersion+1,updated_at:new Date().toISOString()}).select();if(s){console.error("Failed to sync image:",s);continue}await u.images.update(t.id,{pendingSync:!1,syncVersion:t.syncVersion+1,lastSyncAt:new Date})}}catch(e){throw console.error("Error syncing images:",e),e}}async calculatePendingOperations(){try{const[e,t,i,s]=await Promise.all([u.cards.where("pendingSync").equals(!0).count(),u.folders.where("pendingSync").equals(!0).count(),u.tags.where("pendingSync").equals(!0).count(),u.images.where("pendingSync").equals(!0).count()]);return e+t+i+s}catch(e){return console.error("Error calculating pending operations:",e),0}}getPendingOperationsCount(){return 0}convertNetworkStatus(e){return e.isOnline?e.bandwidth<1e5||e.latency>1e3?"poor":"online":"offline"}calculateSyncHealth(e){const{conflicts:t,pendingOperations:i}=e;return t>10?"critical":t>5||i>20?"warning":t>0||i>5?"good":"excellent"}convertTableToEntity(e){return{cards:"card",folders:"folder",tags:"tag",images:"image"}[e]||"card"}}const Me=new De;new Date().toISOString();export{ye as a,T as b,Me as c,u as d,Ee as e,G as i,ve as t,J as u};
