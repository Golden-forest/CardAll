import React, { createContext, useContext, useState, useEffect, useCallback, useRef } from 'react'

// 可访问性设置接口
export interface AccessibilitySettings {
  highContrast: boolean
  reducedMotion: boolean
  largeText: boolean
  screenReader: boolean
  keyboardOnly: boolean
  focusVisible: boolean
  announcements: boolean
  colorBlindSupport: boolean
}

// 默认设置
const defaultSettings: AccessibilitySettings = {
  highContrast: false,
  reducedMotion: false,
  largeText: false,
  screenReader: false,
  keyboardOnly: false,
  focusVisible: true,
  announcements: true,
  colorBlindSupport: false
}

// Context
interface AccessibilityContextType {
  settings: AccessibilitySettings
  updateSetting: (key: keyof AccessibilitySettings, value: boolean) => void
  toggleSetting: (key: keyof AccessibilitySettings) => void
  resetSettings: () => void
  announce: (message: string) => void
  isInitialized: boolean
}

const AccessibilityContext = createContext<AccessibilityContextType | undefined>(undefined)

// 内部hook实现
function useAccessibilityInternal() {
  const [settings, setSettings] = useState<AccessibilitySettings>(defaultSettings)
  const [isInitialized, setIsInitialized] = useState(false)
  const announcementsRef = useRef<HTMLDivElement>(null)
  
  // 从本地存储加载设置
  useEffect(() => {
    try {
      const savedSettings = localStorage.getItem('accessibility-settings')
      if (savedSettings) {
        const parsed = JSON.parse(savedSettings)
        setSettings({ ...defaultSettings, ...parsed })
      }
      
      // 检测用户偏好
      const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches
      const prefersHighContrast = window.matchMedia('(prefers-contrast: high)').matches
      
      if (prefersReducedMotion) {
        setSettings(prev => ({ ...prev, reducedMotion: true }))
      }
      
      if (prefersHighContrast) {
        setSettings(prev => ({ ...prev, highContrast: true }))
      }
      
      setIsInitialized(true)
    } catch (error) {
      console.error('Failed to load accessibility settings:', error)
      setIsInitialized(true)
    }
  }, [])

  // 保存设置到本地存储
  useEffect(() => {
    if (isInitialized) {
      try {
        localStorage.setItem('accessibility-settings', JSON.stringify(settings))
      } catch (error) {
        console.error('Failed to save accessibility settings:', error)
      }
    }
  }, [settings, isInitialized])

  // 应用设置到文档
  useEffect(() => {
    if (!isInitialized) return

    const root = document.documentElement
    
    // 高对比度
    if (settings.highContrast) {
      root.classList.add('high-contrast')
    } else {
      root.classList.remove('high-contrast')
    }
    
    // 减少动画
    if (settings.reducedMotion) {
      root.classList.add('reduced-motion')
    } else {
      root.classList.remove('reduced-motion')
    }
    
    // 大字体
    if (settings.largeText) {
      root.classList.add('large-text')
    } else {
      root.classList.remove('large-text')
    }
    
    // 色盲支持
    if (settings.colorBlindSupport) {
      root.classList.add('color-blind')
    } else {
      root.classList.remove('color-blind')
    }
    
    // 焦点可见
    if (settings.focusVisible) {
      root.classList.add('focus-visible')
    } else {
      root.classList.remove('focus-visible')
    }
    
    // 键盘专用模式
    if (settings.keyboardOnly) {
      root.classList.add('keyboard-only')
    } else {
      root.classList.remove('keyboard-only')
    }
    
    // 屏幕阅读器优化
    if (settings.screenReader) {
      root.setAttribute('aria-live', 'polite')
    } else {
      root.removeAttribute('aria-live')
    }
  }, [settings, isInitialized])

  // 更新单个设置
  const updateSetting = useCallback((key: keyof AccessibilitySettings, value: boolean) => {
    setSettings(prev => ({ ...prev, [key]: value }))
    announce(`Accessibility setting ${key} ${value ? 'enabled' : 'disabled'}`)
  }, [])

  // 切换设置
  const toggleSetting = useCallback((key: keyof AccessibilitySettings) => {
    setSettings(prev => {
      const newValue = !prev[key]
      announce(`Accessibility setting ${key} ${newValue ? 'enabled' : 'disabled'}`)
      return { ...prev, [key]: newValue }
    })
  }, [])

  // 重置所有设置
  const resetSettings = useCallback(() => {
    setSettings(defaultSettings)
    announce('All accessibility settings reset to default')
  }, [])

  // 键盘快捷键处理
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      // 检查是否按住了Alt键
      if (!e.altKey) return
      
      // 根据按下的键执行对应操作
      switch (e.key.toLowerCase()) {
        case 'h':
          e.preventDefault()
          toggleSetting('highContrast')
          break
        case 'r':
          e.preventDefault()
          toggleSetting('reducedMotion')
          break
        case 'l':
          e.preventDefault()
          toggleSetting('largeText')
          break
        case 's':
          e.preventDefault()
          toggleSetting('screenReader')
          break
        case 'f':
          e.preventDefault()
          toggleSetting('focusVisible')
          break
        case 'a':
          e.preventDefault()
          toggleSetting('announcements')
          break
        case 'c':
          e.preventDefault()
          toggleSetting('colorBlindSupport')
          break
        case '?':
          e.preventDefault()
          announce('Keyboard shortcuts: Alt+H (high contrast), Alt+R (reduced motion), Alt+L (large text), Alt+S (screen reader), Alt+F (focus visible), Alt+A (announcements), Alt+C (color blind), Alt+? (shortcuts)')
          break
      }
    }

    document.addEventListener('keydown', handleKeyDown)
    return () => document.removeEventListener('keydown', handleKeyDown)
  }, [toggleSetting])

  // 检测键盘专用模式
  useEffect(() => {
    const handleFirstTab = (e: KeyboardEvent) => {
      if (e.key === 'Tab') {
        updateSetting('keyboardOnly', true)
        // 移除监听器，只需要检测第一次
        document.removeEventListener('keydown', handleFirstTab)
      }
    }

    const handleMouseMove = () => {
      updateSetting('keyboardOnly', false)
    }

    document.addEventListener('keydown', handleFirstTab)
    document.addEventListener('mousemove', handleMouseMove)

    return () => {
      document.removeEventListener('keydown', handleFirstTab)
      document.removeEventListener('mousemove', handleMouseMove)
    }
  }, [updateSetting])

  // 屏幕阅读器公告
  const announce = useCallback((message: string) => {
    if (!settings.announcements) return

    if (!announcementsRef.current) {
      announcementsRef.current = document.createElement('div')
      announcementsRef.current.setAttribute('aria-live', 'polite')
      announcementsRef.current.setAttribute('aria-atomic', 'true')
      announcementsRef.current.className = 'sr-only'
      document.body.appendChild(announcementsRef.current)
    }

    const announcement = document.createElement('div')
    announcement.textContent = message
    announcementsRef.current.appendChild(announcement)

    // 清理旧的公告
    setTimeout(() => {
      if (announcementsRef.current?.contains(announcement)) {
        announcementsRef.current.removeChild(announcement)
      }
    }, 1000)
  }, [settings.announcements])

  // 导出设置供其他组件使用
  const contextValue = {
    settings,
    updateSetting,
    toggleSetting,
    resetSettings,
    announce,
    isInitialized
  }

  return contextValue
}

// Provider component
export function AccessibilityProvider(props: { children: React.ReactNode }) {
  const accessibility = useAccessibilityInternal()
  
  return (
    <AccessibilityContext.Provider value={accessibility}>
      {props.children}
    </AccessibilityContext.Provider>
  )
}

// Hook to use accessibility context
export function useAccessibilityContext() {
  const context = useContext(AccessibilityContext)
  if (context === undefined) {
    throw new Error('useAccessibilityContext must be used within an AccessibilityProvider')
  }
  return context
}

// Public hook for using accessibility (legacy support)
export function useAccessibility() {
  return useAccessibilityContext()
}

// 键盘快捷键映射
export interface KeyboardShortcuts {
  toggleHighContrast: string[]
  toggleReducedMotion: string[]
  toggleLargeText: string[]
  toggleScreenReader: string[]
  toggleFocusVisible: string[]
  toggleAnnouncements: string[]
  toggleColorBlind: string[]
  showShortcuts: string[]
}

export const defaultShortcuts: KeyboardShortcuts = {
  toggleHighContrast: ['Alt', 'H'],
  toggleReducedMotion: ['Alt', 'R'],
  toggleLargeText: ['Alt', 'L'],
  toggleScreenReader: ['Alt', 'S'],
  toggleFocusVisible: ['Alt', 'F'],
  toggleAnnouncements: ['Alt', 'A'],
  toggleColorBlind: ['Alt', 'C'],
  showShortcuts: ['Alt', '?']
}

// 可访问性工具函数
export const accessibilityUtils = {
  // 生成唯一的ARIA ID
  generateId: (prefix: string) => `${prefix}-${Math.random().toString(36).substr(2, 9)}`,
  
  // 检查颜色对比度
  checkContrast: (color1: string, color2: string): number => {
    // 简化的对比度计算
    // 实际应用中可以使用更精确的算法
    return 4.5 // 返回模拟值
  },
  
  // 检查元素是否在视口中
  isInViewport: (element: HTMLElement): boolean => {
    const rect = element.getBoundingClientRect()
    return (
      rect.top >= 0 &&
      rect.left >= 0 &&
      rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
      rect.right <= (window.innerWidth || document.documentElement.clientWidth)
    )
  },
  
  // 将元素滚动到视口中
  scrollToElement: (element: HTMLElement, behavior: ScrollBehavior = 'smooth') => {
    element.scrollIntoView({ behavior, block: 'center', inline: 'nearest' })
  },
  
  // 管理焦点陷阱
  trapFocus: (container: HTMLElement) => {
    const focusableElements = container.querySelectorAll(
      'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
    )
    const firstElement = focusableElements[0] as HTMLElement
    const lastElement = focusableElements[focusableElements.length - 1] as HTMLElement

    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Tab') {
        if (e.shiftKey) {
          if (document.activeElement === firstElement) {
            e.preventDefault()
            lastElement.focus()
          }
        } else {
          if (document.activeElement === lastElement) {
            e.preventDefault()
            firstElement.focus()
          }
        }
      }
    }

    container.addEventListener('keydown', handleKeyDown)
    return () => container.removeEventListener('keydown', handleKeyDown)
  },
  
  // 检测屏幕阅读器
  detectScreenReader: (): boolean => {
    // 简化的检测方法
    return false
  },
  
  // 获取最佳字体大小
  getOptimalFontSize: (baseSize: number, largeText: boolean): number => {
    return largeText ? baseSize * 1.2 : baseSize
  },
  
  // 获取最佳动画时长
  getOptimalAnimationDuration: (baseDuration: number, reducedMotion: boolean): number => {
    return reducedMotion ? 0 : baseDuration
  }
}