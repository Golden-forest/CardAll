/**
 * 冲突系统测试
 *
 * 测试冲突检测、解决和UI交互的完整流程
 */

import * as React from 'react'
import { render, screen, fireEvent, waitFor, act, renderHook } from '@testing-library/react'
import { ConflictPanel } from '@/components/conflict/conflict-panel'
import { useConflicts } from '@/hooks/use-conflicts'
import { unifiedSyncService } from '@/services/core/sync/unified-sync.service'
import { performanceMonitor } from '@/services/ui/performance-monitor'

// Mock 同步服务
jest.mock('@/services/core/sync/unified-sync.service', () => ({
  unifiedSyncService: {
    getStatus: jest.fn(),
    getConflicts: jest.fn(),
    getConflict: jest.fn(),
    resolveConflict: jest.fn(),
    autoResolveConflicts: jest.fn(),
    sync: jest.fn(),
    on: jest.fn(),
    off: jest.fn()
  }
}))

// Mock 性能监控服务
jest.mock('@/services/ui/performance-monitor', () => ({
  performanceMonitor: {
    startConflictDetection: jest.fn(),
    startConflictResolution: jest.fn(),
    startBatchOperation: jest.fn(),
    trackUserInteraction: jest.fn(),
    getRealtimeMetrics: jest.fn()
  }
}))

describe('ConflictSystem', () => {
  const mockConflicts = [
    {
      id: 'conflict_1',
      type: 'card_content',
      entityType: 'card',
      entityId: 'card_1',
      timestamp: new Date('2024-01-01T10:00:00'),
      sourceDevice: 'device_1',
      severity: 'high' as const,
      status: 'pending' as const,
      createdAt: new Date('2024-01-01T10:00:00'),
      localVersion: {
        content: {
          frontContent: { title: '本地标题', content: '本地内容' },
          backContent: { title: '背面本地', content: '背面内容' }
        }
      },
      remoteVersion: {
        content: {
          frontContent: { title: '远程标题', content: '远程内容' },
          backContent: { title: '背面远程', content: '背面内容' }
        }
      },
      conflictFields: ['title', 'content']
    },
    {
      id: 'conflict_2',
      type: 'folder_name',
      entityType: 'folder',
      entityId: 'folder_1',
      timestamp: new Date('2024-01-01T11:00:00'),
      sourceDevice: 'device_2',
      severity: 'medium' as const,
      status: 'pending' as const,
      createdAt: new Date('2024-01-01T11:00:00'),
      localVersion: { name: '本地文件夹名' },
      remoteVersion: { name: '远程文件夹名' }
    }
  ]

  const mockSyncStatus = {
    isSyncing: false,
    currentSession: null,
    pendingOperations: 2,
    conflicts: 2,
    hasConflicts: true,
    lastSyncTime: new Date('2024-01-01T09:00:00'),
    networkStatus: { online: true },
    totalSyncs: 10,
    successfulSyncs: 8,
    failedSyncs: 2,
    conflictsArray: mockConflicts
  }

  beforeEach(() => {
    jest.clearAllMocks()

    // 设置默认的mock返回值
    ;(unifiedSyncService.getStatus as jest.Mock).mockReturnValue(mockSyncStatus)
    ;(unifiedSyncService.getConflicts as jest.Mock).mockReturnValue(mockConflicts)
    ;(unifiedSyncService.getConflict as jest.Mock).mockImplementation((id) =>
      mockConflicts.find(c => c.id === id)
    )
    ;(unifiedSyncService.resolveConflict as jest.Mock).mockResolvedValue(true)
    ;(unifiedSyncService.autoResolveConflicts as jest.Mock).mockResolvedValue(1)
    ;(performanceMonitor.getRealtimeMetrics as jest.Mock).mockReturnValue({
      renderTime: 50,
      memoryUsage: 50 * 1024 * 1024,
      networkLatency: 100
    })
  })

  describe('ConflictPanel', () => {
    it('应该正确渲染冲突面板', () => {
      render(<ConflictPanel isOpen={true} onClose={jest.fn()} />)

      expect(screen.getByText('冲突管理中心')).toBeInTheDocument()
      expect(screen.getByText('2 待解决')).toBeInTheDocument()
      expect(screen.getByText('在线')).toBeInTheDocument()
    })

    it('应该显示冲突列表', () => {
      render(<ConflictPanel isOpen={true} onClose={jest.fn()} />)

      expect(screen.getByText('本地标题')).toBeInTheDocument()
      expect(screen.getByText('远程标题')).toBeInTheDocument()
      expect(screen.getByText('本地文件夹名')).toBeInTheDocument()
    })

    it('应该支持搜索冲突', async () => {
      render(<ConflictPanel isOpen={true} onClose={jest.fn()} />)

      const searchInput = screen.getByPlaceholderText('搜索冲突...')
      fireEvent.change(searchInput, { target: { value: '文件夹' } })

      await waitFor(() => {
        expect(screen.getByText('本地文件夹名')).toBeInTheDocument()
        expect(screen.queryByText('本地标题')).not.toBeInTheDocument()
      })
    })

    it('应该支持过滤冲突', async () => {
      render(<ConflictPanel isOpen={true} onClose={jest.fn()} />)

      // 点击高优先级过滤
      const highPriorityButton = screen.getByText('高优先级')
      fireEvent.click(highPriorityButton)

      await waitFor(() => {
        expect(screen.getByText('本地标题')).toBeInTheDocument()
        expect(screen.queryByText('本地文件夹名')).not.toBeInTheDocument()
      })
    })

    it('应该支持选择多个冲突', async () => {
      render(<ConflictPanel isOpen={true} onClose={jest.fn()} />)

      const checkboxes = screen.getAllByRole('checkbox')
      fireEvent.click(checkboxes[0])
      fireEvent.click(checkboxes[1])

      expect(screen.getByText('已选择 2 个冲突')).toBeInTheDocument()
    })

    it('应该支持批量解决冲突', async () => {
      render(<ConflictPanel isOpen={true} onClose={jest.fn()} />)

      // 选择两个冲突
      const checkboxes = screen.getAllByRole('checkbox')
      fireEvent.click(checkboxes[0])
      fireEvent.click(checkboxes[1])

      // 批量保留本地版本
      const batchLocalButton = screen.getByText('批量保留本地')
      fireEvent.click(batchLocalButton)

      await waitFor(() => {
        expect(unifiedSyncService.resolveConflict).toHaveBeenCalledTimes(2)
      })
    })

    it('应该支持查看冲突详情', async () => {
      render(<ConflictPanel isOpen={true} onClose={jest.fn()} />)

      const viewDetailButton = screen.getAllByText('查看详情')[0]
      fireEvent.click(viewDetailButton)

      await waitFor(() => {
        expect(screen.getByText('冲突详情')).toBeInTheDocument()
      })
    })

    it('应该支持刷新冲突列表', async () => {
      render(<ConflictPanel isOpen={true} onClose={jest.fn()} />)

      const refreshButton = screen.getByText('刷新')
      fireEvent.click(refreshButton)

      await waitFor(() => {
        expect(unifiedSyncService.getStatus).toHaveBeenCalled()
      })
    })

    it('应该正确处理同步状态', async () => {
      ;(unifiedSyncService.getStatus as jest.Mock).mockReturnValue({
        ...mockSyncStatus,
        isSyncing: true,
        pendingOperations: 5
      })

      render(<ConflictPanel isOpen={true} onClose={jest.fn()} />)

      expect(screen.getByText('同步中...')).toBeInTheDocument()
      expect(screen.getByText('5 待同步')).toBeInTheDocument()
    })

    it('应该正确处理离线状态', async () => {
      ;(unifiedSyncService.getStatus as jest.Mock).mockReturnValue({
        ...mockSyncStatus,
        networkStatus: { online: false }
      })

      render(<ConflictPanel isOpen={true} onClose={jest.fn()} />)

      expect(screen.getByText('离线')).toBeInTheDocument()
    })
  })

  describe('useConflicts Hook', () => {
    let hookResult: any

    const TestComponent = () => {
      hookResult = useConflicts()
      return <div>Test</div>
    }

    beforeEach(() => {
      render(<TestComponent />)
    })

    it('应该提供正确的状态', () => {
      expect(hookResult.conflicts).toEqual(mockConflicts)
      expect(hookResult.isResolving).toBe(false)
      expect(hookResult.isLoading).toBe(false)
      expect(hookResult.error).toBe(null)
    })

    it('应该提供统计信息', () => {
      const stats = hookResult.getStats()
      expect(stats.totalConflicts).toBe(2)
      expect(stats.pendingConflicts).toBe(2)
      expect(stats.resolvedConflicts).toBe(0)
    })

    it('应该提供过滤方法', () => {
      const pendingConflicts = hookResult.getPendingConflicts()
      expect(pendingConflicts).toHaveLength(2)

      const highPriorityConflicts = hookResult.getHighPriorityConflicts()
      expect(highPriorityConflicts).toHaveLength(1)
    })

    it('应该支持解决冲突', async () => {
      await hookResult.resolveConflict('conflict_1', {
        type: 'local',
        reason: '保留本地版本'
      })

      expect(unifiedSyncService.resolveConflict).toHaveBeenCalledWith(
        'conflict_1',
        'local',
        undefined
      )
    })

    it('应该支持批量解决冲突', async () => {
      await hookResult.batchResolveConflicts(['conflict_1', 'conflict_2'], {
        type: 'local',
        reason: '批量保留本地'
      })

      expect(unifiedSyncService.resolveConflict).toHaveBeenCalledTimes(2)
    })

    it('应该支持自动解决冲突', async () => {
      const resolvedCount = await hookResult.autoResolveConflicts()

      expect(unifiedSyncService.autoResolveConflicts).toHaveBeenCalled()
      expect(resolvedCount).toBe(1)
    })

    it('应该支持检测新冲突', async () => {
      await hookResult.detectConflicts()

      expect(unifiedSyncService.sync).toHaveBeenCalledWith({
        type: 'incremental',
        direction: 'bidirectional'
      })
    })

    it('应该支持获取冲突详情', async () => {
      const details = await hookResult.getConflictDetails('conflict_1')

      expect(details).toBeTruthy()
      expect(details?.id).toBe('conflict_1')
    })

    it('应该正确处理错误', async () => {
      ;(unifiedSyncService.resolveConflict as jest.Mock).mockRejectedValue(
        new Error('解决失败')
      )

      await hookResult.resolveConflict('conflict_1', {
        type: 'local',
        reason: '测试'
      })

      expect(hookResult.error).toBe('解决失败')
    })
  })

  describe('性能监控集成', () => {
    it('应该在冲突解决时跟踪性能', async () => {
      const { result } = renderHook(() => useConflicts(), {
        wrapper: ({ children }) => (
          <ConflictPanelProvider>{children}</ConflictPanelProvider>
        )
      })

      await result.current.resolveConflict('conflict_1', {
        type: 'local',
        reason: '测试'
      })

      expect(performanceMonitor.startConflictResolution).toHaveBeenCalled()
      expect(performanceMonitor.trackUserInteraction).toHaveBeenCalledWith(
        'resolve_conflict',
        expect.any(Number),
        true
      )
    })

    it('应该在批量操作时跟踪性能', async () => {
      const { result } = renderHook(() => useConflicts(), {
        wrapper: ({ children }) => (
          <ConflictPanelProvider>{children}</ConflictPanelProvider>
        )
      })

      await result.current.batchResolveConflicts(['conflict_1'], {
        type: 'local',
        reason: '测试'
      })

      expect(performanceMonitor.startBatchOperation).toHaveBeenCalled()
    })
  })

  describe('错误处理', () => {
    it('应该处理网络错误', async () => {
      ;(unifiedSyncService.resolveConflict as jest.Mock).mockRejectedValue(
        new Error('网络连接失败')
      )

      render(<ConflictPanel isOpen={true} onClose={jest.fn()} />)

      const resolveButton = screen.getAllByText('保留本地')[0]
      fireEvent.click(resolveButton)

      await waitFor(() => {
        expect(screen.getByText('网络连接失败')).toBeInTheDocument()
      })
    })

    it('应该处理权限错误', async () => {
      ;(unifiedSyncService.resolveConflict as jest.Mock).mockRejectedValue(
        new Error('权限不足')
      )

      render(<ConflictPanel isOpen={true} onClose={jest.fn()} />)

      const resolveButton = screen.getAllByText('保留本地')[0]
      fireEvent.click(resolveButton)

      await waitFor(() => {
        expect(screen.getByText('权限不足')).toBeInTheDocument()
      })
    })

    it('应该处理并发冲突', async () => {
      ;(unifiedSyncService.resolveConflict as jest.Mock).mockRejectedValue(
        new Error('冲突已被其他用户解决')
      )

      render(<ConflictPanel isOpen={true} onClose={jest.fn()} />)

      const resolveButton = screen.getAllByText('保留本地')[0]
      fireEvent.click(resolveButton)

      await waitFor(() => {
        expect(screen.getByText('冲突已被其他用户解决')).toBeInTheDocument()
      })
    })
  })

  describe('可访问性', () => {
    it('应该支持键盘导航', () => {
      render(<ConflictPanel isOpen={true} onClose={jest.fn()} />)

      const firstConflict = screen.getByText('本地标题').closest('div')
      fireEvent.keyDown(firstConflict!, { key: 'Enter' })

      expect(screen.getByText('查看详情')).toBeInTheDocument()
    })

    it('应该提供适当的ARIA标签', () => {
      render(<ConflictPanel isOpen={true} onClose={jest.fn()} />)

      expect(screen.getByRole('dialog')).toHaveAttribute('aria-modal', 'true')
      expect(screen.getByRole('dialog')).toHaveAttribute('aria-labelledby', expect.any(String))
    })

    it('应该支持屏幕阅读器', () => {
      render(<ConflictPanel isOpen={true} onClose={jest.fn()} />)

      const statusElement = screen.getByText('2 待解决')
      expect(statusElement).toHaveAttribute('aria-live', 'polite')
    })
  })
})

// 辅助组件
const ConflictPanelProvider = ({ children }: { children: React.ReactNode }) => {
  return <div>{children}</div>
}