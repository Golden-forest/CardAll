# 卡片全屏功能问题分析与修复计划

## 问题原因

1. **根本原因**：全屏状态管理设计有误
   - 每个 `CardSide` 组件都独立管理 `isFullscreen` 状态
   - 当任何卡片调用 `requestFullscreen()` 时，整个文档进入全屏模式
   - 所有卡片的 `fullscreenchange` 监听器都会触发，导致所有卡片的 `isFullscreen` 状态都变为 `true`
   - 多个卡片同时应用全屏样式，最终只有一个卡片可见（通常是最后渲染或样式优先级最高的）

2. **技术细节**：
   - 使用 `document.documentElement.requestFullscreen()` 进入全屏，影响整个文档
   - 全局 `fullscreenchange` 事件被所有卡片组件监听
   - 每个卡片组件都尝试应用全屏样式，导致样式冲突

## 修复思路

### 方案1：全局状态管理（推荐）

1. **实现思路**：
   - 创建全局 Context 或使用现有状态管理系统，跟踪当前全屏卡片的 ID
   - 只有当前全屏卡片才显示为全屏样式
   - 进入/退出全屏时更新全局状态

2. **关键修改**：
   - 创建 `FullscreenContext` 管理全屏状态
   - 每个卡片组件从 Context 获取当前全屏卡片 ID
   - 只有当卡片 ID 匹配时才应用全屏样式

### 方案2：直接操作 DOM 元素

1. **实现思路**：
   - 在 `toggleFullscreen` 函数中直接操作当前卡片元素
   - 不依赖全局 `fullscreenchange` 事件更新所有卡片状态
   - 确保只有触发全屏的卡片应用全屏样式

2. **关键修改**：
   - 修改 `toggleFullscreen` 函数，只处理当前卡片
   - 移除或修改 `fullscreenchange` 事件处理逻辑
   - 确保样式只应用到当前卡片

### 方案3：改进现有逻辑

1. **实现思路**：
   - 保留每个组件的独立状态
   - 改进 `fullscreenchange` 事件处理，只让触发全屏的组件响应
   - 添加标识区分哪个组件触发了全屏

2. **关键修改**：
   - 添加 `isFullscreenInitiator` 状态
   - 只有触发全屏的组件才在 `fullscreenchange` 事件中更新状态

## 推荐方案：方案1（全局状态管理）

### 修复步骤

1. 创建 `FullscreenContext` 用于全局管理全屏状态
2. 在 `App` 或顶层组件中提供 `FullscreenContext`
3. 修改 `CardSide` 组件，使用 `FullscreenContext` 管理全屏状态
4. 更新 `toggleFullscreen` 函数，设置全局全屏卡片 ID
5. 修改样式应用逻辑，只有当前全屏卡片才应用全屏样式
6. 测试多张卡片的全屏切换功能

## 风险评估

- **风险级别**：低
  - 修复逻辑相对简单，不涉及核心功能
  - 只修改全屏相关的代码，影响范围小
  - 可以通过局部测试验证修复效果

- **潜在风险点**：
  - 全局状态管理可能引入新的状态冲突
  - 需要确保退出全屏时正确清理状态
  - 多卡片场景下的性能影响

- **风险缓解措施**：
  - 仔细设计全局状态的更新逻辑
  - 添加完整的状态清理机制
  - 进行充分的测试，包括边界情况

## 预期效果

- 点击任何卡片的全屏按钮，只有该卡片进入全屏模式
- 退出全屏后，卡片恢复正常显示
- 多张卡片之间的全屏切换互不影响
- 保持原有的用户体验和交互方式

## 实施时间

- 开发时间：约1-2小时
- 测试时间：约30分钟
- 总时间：约1.5-2.5小时