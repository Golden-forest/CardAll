# 卡片拖拽功能详细实现说明

## 对现有布局的影响

**不会破坏现有布局**，实现方案采用**增量修改**方式：

1. **保留核心布局算法**：现有的 `useMasonryLayout` hook 核心逻辑保持不变
2. **仅添加排序支持**：新增对卡片顺序变化的响应，不修改瀑布流布局计算方式
3. **兼容现有组件接口**：不改变 `OptimizedMasonryGrid` 组件的输入输出接口
4. **渐进式实现**：先实现基础拖拽，再逐步添加高级功能

## 编辑状态下禁用拖拽

实现方式：
```typescript
// 在 EnhancedFlipCard 组件中添加判断
const isDraggable = !isEditing; // 假设 isEditing 是卡片编辑状态

// 传递给 SortableItem
<SortableItem
  id={card.id}
  disabled={!isDraggable}
>
  {/* 卡片内容 */}
</SortableItem>
```

## 简化动效实现

先实现**基础拖拽功能**，暂不添加复杂动效：

1. 移除抖动动画需求
2. 保留拖拽过程中的视觉反馈（如半透明、阴影变化）
3. 使用 dnd-kit 自带的拖拽指示器
4. 待基础功能稳定后，可后续添加动效

## 部分卡片情况下的重排逻辑

当用户点击文件夹或书签，只显示部分卡片时，拖拽重排逻辑如下：

### 1. 数据层面

- **当前显示的卡片数组**：`visibleCards`（根据文件夹/书签过滤后的卡片）
- **拖拽操作**：仅影响当前显示的卡片顺序
- **数据更新**：拖拽结束后，更新整个卡片数组中对应卡片的相对位置

### 2. 布局计算逻辑

```typescript
// 拖拽结束后的处理流程
const handleDragEnd = (event: DragEndEvent) => {
  const { active, over } = event;
  if (!over) return;

  // 1. 从当前显示的卡片数组中找到拖拽前后的位置
  const oldIndex = visibleCards.findIndex(card => card.id === active.id);
  const newIndex = visibleCards.findIndex(card => card.id === over.id);
  if (oldIndex === -1 || newIndex === -1) return;

  // 2. 重新排序当前显示的卡片
  const reorderedVisibleCards = arrayMove(visibleCards, oldIndex, newIndex);

  // 3. 更新完整卡片数组中对应卡片的位置
  // 找到完整数组中当前显示卡片的位置范围
  const fullArrayIndices = reorderedVisibleCards.map(card => 
    allCards.findIndex(c => c.id === card.id)
  );
  
  // 4. 生成新的完整卡片数组，保持非显示卡片位置不变
  const newAllCards = [...allCards];
  reorderedVisibleCards.forEach((card, index) => {
    newAllCards[fullArrayIndices[index]] = card;
  });

  // 5. 通知父组件更新卡片顺序
  onCardsReorder(newAllCards);
};
```

### 3. 布局更新逻辑

- **仅重排可见卡片**：拖拽过程中，仅调整当前可见卡片的位置
- **不影响未显示卡片**：未显示的卡片在完整数组中的位置保持不变
- **拖拽结束后统一更新**：拖拽结束后，根据新的顺序重新计算所有可见卡片的布局
- **保留瀑布流特性**：重排后依然保持瀑布流布局，卡片填充到最短列

## 核心重排算法

1. **找到拖拽卡片在可见数组中的旧位置和新位置**
2. **重新排序可见数组**
3. **将可见数组的新顺序映射到完整卡片数组**
4. **保持非可见卡片在完整数组中的相对顺序不变**
5. **根据新的完整数组重新计算布局**

## 实现步骤调整

1. **实现基础拖拽功能**：集成 dnd-kit，实现卡片拖拽和排序
2. **添加编辑状态判断**：编辑中的卡片禁用拖拽
3. **实现部分卡片重排逻辑**：确保在文件夹/书签视图下正常工作
4. **优化布局更新性能**：减少不必要的重计算
5. **测试各种场景**：完整卡片、部分卡片、编辑状态等

## 风险控制

1. **布局一致性**：每次拖拽结束后强制重新计算所有可见卡片位置
2. **数据一致性**：确保可见卡片顺序与完整数组顺序同步
3. **性能优化**：
   - 拖拽过程中仅更新必要的卡片位置
   - 使用节流减少布局计算频率
   - 利用 React.memo 避免不必要的组件重渲染
4. **边界情况处理**：
   - 空卡片列表
   - 只有一张卡片
   - 拖拽到列表开头/结尾

## 预期效果

- **基础拖拽功能**：卡片可自由拖拽排序
- **编辑状态禁用**：编辑中的卡片无法拖拽
- **部分卡片支持**：在文件夹/书签视图下正常工作
- **布局稳定性**：拖拽后保持瀑布流布局，无重叠
- **性能流畅**：拖拽过程中无明显卡顿

## 后续扩展

待基础功能稳定后，可逐步添加：
1. 拖拽动效（如抖动、阴影变化）
2. 自动吸附功能
3. 拖拽过程中的占位符
4. 更精细的拖拽控制（如限制拖拽方向）